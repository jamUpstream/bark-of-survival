<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=0.5, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, orientation=landscape">
    <title>Bark of Survival</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Cinzel:wght@400;700&family=Rajdhani:wght@400;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --blood-red: #8B0000;
            --dark-bg: #0a0a0a;
            --wood-brown: #3d2817;
            --gold: #d4af37;
            --stone-gray: #2c2c2c;
            --danger-red: #ff3333;
            --health-green: #00ff00;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1410 100%);
            color: #fff;
            overflow: hidden;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="4" fill="rgba(212,175,55,0.6)"/></svg>') 10 10, auto;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overscroll-behavior: none;
        }

        /* Mobile stability / safe-area */
        body {
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
            overscroll-behavior: none;
        }

        #canvasWrap {
            width: 100vw;
            height: calc(var(--vh, 1vh) * 100);
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #hud {
            padding-top: calc(1rem + env(safe-area-inset-top));
            padding-left: calc(1rem + env(safe-area-inset-left));
            padding-right: calc(1rem + env(safe-area-inset-right));
        }

        #mainMenu,
        #characterSelect,
        #shop,
        #options,
        #levelUpScreen,
        #gameOverScreen,
        #victoryScreen {
            padding-top: calc(2rem + env(safe-area-inset-top));
            padding-left: calc(2rem + env(safe-area-inset-left));
            padding-right: calc(2rem + env(safe-area-inset-right));
            padding-bottom: calc(2rem + env(safe-area-inset-bottom));
        }

        /* Prevent huge UI on narrow phones */
        @media (max-width: 520px) {
            .health-bar-container {
                min-width: 220px;
            }

            .stat-box {
                min-width: 90px;
                padding: 0.4rem 0.6rem;
            }

            .stat-value {
                font-size: 1.4rem;
            }

            .xp-bar-container {
                max-width: 92vw;
            }

            .back-btn {
                top: calc(1rem + env(safe-area-inset-top));
                left: calc(1rem + env(safe-area-inset-left));
            }
        }



        #gameCanvas {
            display: block;
            background: radial-gradient(circle at 50% 50%, #1a1a1a 0%, #0a0a0a 100%);
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.8);
            image-rendering: pixelated;
        }

        /* Main Menu */
        #mainMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background:
                linear-gradient(180deg, rgba(139, 0, 0, 0.1) 0%, transparent 50%, rgba(139, 0, 0, 0.1) 100%),
                radial-gradient(circle at 30% 30%, rgba(61, 40, 23, 0.3) 0%, transparent 50%),
                #0a0a0a;
            z-index: 1000;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .game-title {
            font-family: 'Cinzel', serif;
            font-size: 4.5rem;
            font-weight: 600;
            color: #d4af37;
            text-shadow: 0 0 25px rgba(212, 175, 55, 0.4);
            letter-spacing: 0.45rem;
            margin: 0;
            text-align: center;
            line-height: 1.05;
            white-space: nowrap;
            /* desktop: keep single line */
            width: auto;
            max-width: 92vw;
            /* prevent overflow on narrow desktops */
        }

        @keyframes titleGlow {
            from {
                text-shadow: 0 0 20px rgba(212, 175, 55, 0.3), 0 5px 10px rgba(139, 0, 0, 0.6), 0 10px 30px rgba(0, 0, 0, 0.9);
            }

            to {
                text-shadow: 0 0 30px rgba(212, 175, 55, 0.6), 0 5px 10px rgba(139, 0, 0, 0.9), 0 10px 40px rgba(0, 0, 0, 1);
            }
        }

        .game-subtitle {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.5rem;
            color: #888;
            margin-bottom: 3rem;
            letter-spacing: 0.5rem;
            text-transform: uppercase;

            text-align: center;
            width: min(92vw, 520px);
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .menu-btn {
            font-family: 'Bebas Neue', cursive;
            font-size: 2rem;
            padding: 1rem 3rem;
            background: linear-gradient(135deg, var(--wood-brown) 0%, #2d1e0f 100%);
            border: 3px solid var(--gold);
            color: var(--gold);
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.2rem;
            text-transform: uppercase;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        .menu-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(212, 175, 55, 0.3), transparent);
            transition: left 0.5s;
        }

        .menu-btn:hover::before {
            left: 100%;
        }

        .menu-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(212, 175, 55, 0.4);
            border-color: #fff;
            color: #fff;
        }

        /* Character Selection */
        #characterSelect {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.95);
            z-index: 999;
            padding: 2rem;
            overflow-y: auto;
        }

        .char-select-title {
            font-family: 'Cinzel', serif;
            font-size: 3rem;
            color: var(--gold);
            text-align: center;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }

        .characters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .character-card {
            background: linear-gradient(135deg, var(--stone-gray) 0%, #1a1a1a 100%);
            border: 3px solid var(--wood-brown);
            padding: 2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .character-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 3px solid var(--gold);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .character-card:hover::after,
        .character-card.locked:hover::after {
            opacity: 0;
        }

        .character-card:not(.locked):hover::after {
            opacity: 1;
        }

        .character-card:not(.locked):hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 40px rgba(212, 175, 55, 0.4);
        }

        .character-card.locked {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .character-card.locked::before {
            content: 'üîí';
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 2rem;
            z-index: 1;
        }

        .char-name {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            color: var(--gold);
            margin-bottom: 1rem;
            text-align: center;
        }

        .char-type {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.2rem;
            color: #888;
            margin-bottom: 1rem;
            text-align: center;
            letter-spacing: 0.2rem;
        }

        .char-stats {
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid var(--gold);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        .char-description {
            font-size: 1rem;
            line-height: 1.6;
            color: #ccc;
            margin: 1rem 0;
        }

        .char-price {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.5rem;
            color: var(--gold);
            text-align: center;
            margin-top: 1rem;
        }

        .back-btn {
            position: fixed;
            top: calc(1rem + env(safe-area-inset-top));
            left: calc(1rem + env(safe-area-inset-left));
            z-index: 3000;
            font-family: 'Bebas Neue', cursive;
            font-size: 1.5rem;
            padding: 0.55rem 1.4rem;
            background: rgba(44, 44, 44, 0.95);
            border: 2px solid var(--gold);
            color: var(--gold);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .back-btn:hover {
            background: var(--wood-brown);
            transform: translateX(-5px);
        }

        /* Shop */
        #shop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.95);
            z-index: 999;
            padding: 2rem;
            overflow-y: auto;
        }

        .shop-title {
            font-family: 'Cinzel', serif;
            font-size: 3rem;
            color: var(--gold);
            text-align: center;
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }

        .currency-display {
            font-family: 'Bebas Neue', cursive;
            font-size: 2rem;
            color: var(--gold);
            text-align: center;
            margin-bottom: 2rem;
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 1rem;
            display: none;
            z-index: 100;
            pointer-events: none;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
            width: 100%;
            box-sizing: border-box;
        }

        .health-bar-container {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--gold);
            padding: 0.5rem 1rem;
            min-width: 300px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            box-sizing: border-box;
        }

        .health-label {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.2rem;
            color: var(--gold);
            margin-bottom: 0.3rem;
            letter-spacing: 0.1rem;
        }

        .health-bar {
            height: 30px;
            background: #1a1a1a;
            border: 2px solid #000;
            position: relative;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--danger-red) 0%, var(--health-green) 100%);
            transition: width 0.3s ease;
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Bebas Neue', cursive;
            font-size: 1.2rem;
            color: #fff;
            text-shadow: 0 0 5px #000;
        }

        .stats-container {
            display: flex;
            gap: 1rem;
            box-sizing: border-box;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--gold);
            padding: 0.5rem 1rem;
            text-align: center;
            min-width: 120px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            box-sizing: border-box;
        }

        .stat-label {
            font-family: 'Bebas Neue', cursive;
            font-size: 0.9rem;
            color: #888;
            letter-spacing: 0.1rem;
        }

        .stat-value {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.8rem;
            color: var(--gold);
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .xp-bar-container {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--gold);
            padding: 0.5rem 1rem;
            margin-top: 1rem;
            max-width: 500px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            box-sizing: border-box;
        }

        .xp-label {
            font-family: 'Bebas Neue', cursive;
            font-size: 1rem;
            color: var(--gold);
            margin-bottom: 0.3rem;
            letter-spacing: 0.1rem;
        }

        .xp-bar {
            height: 20px;
            background: #1a1a1a;
            border: 2px solid #000;
            position: relative;
            overflow: hidden;
        }

        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a90e2 0%, #00d4ff 100%);
            transition: width 0.3s ease;
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3);
        }

        /* Level Up */
        #levelUpScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 500;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease-in;
        }

        .levelup-container {
            background: linear-gradient(135deg, var(--stone-gray) 0%, #1a1a1a 100%);
            border: 4px solid var(--gold);
            padding: 2rem;
            max-width: 900px;
            box-shadow: 0 0 50px rgba(212, 175, 55, 0.5);
        }

        .levelup-title {
            font-family: 'Cinzel', serif;
            font-size: 3rem;
            color: var(--gold);
            text-align: center;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .upgrades-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }

        .upgrade-card {
            background: rgba(0, 0, 0, 0.5);
            border: 3px solid var(--wood-brown);
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upgrade-card:hover {
            border-color: var(--gold);
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(212, 175, 55, 0.3);
        }

        .upgrade-name {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            color: var(--gold);
            margin-bottom: 0.5rem;
        }

        .upgrade-description {
            font-size: 1rem;
            color: #ccc;
            line-height: 1.4;
        }

        /* Game Over */
        #gameOverScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(139, 0, 0, 0.9);
            z-index: 600;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.5s ease-in;
        }

        .gameover-container {
            text-align: center;
            background: linear-gradient(135deg, var(--stone-gray) 0%, #1a1a1a 100%);
            border: 4px solid var(--danger-red);
            padding: 3rem;
            box-shadow: 0 0 50px rgba(139, 0, 0, 0.8);
        }

        .gameover-title {
            font-family: 'Cinzel', serif;
            font-size: 4rem;
            color: var(--danger-red);
            margin-bottom: 1rem;
            text-shadow: 0 0 30px rgba(255, 51, 51, 0.8);
        }

        .gameover-stats {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.5rem;
            color: #fff;
            margin: 2rem 0;
            line-height: 2;
        }

        .gameover-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        /* Victory */
        #victoryScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 100, 0, 0.9);
            z-index: 600;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.5s ease-in;
        }

        .victory-container {
            text-align: center;
            background: linear-gradient(135deg, var(--stone-gray) 0%, #1a1a1a 100%);
            border: 4px solid var(--gold);
            padding: 3rem;
            box-shadow: 0 0 50px rgba(212, 175, 55, 0.8);
        }

        .victory-title {
            font-family: 'Cinzel', serif;
            font-size: 4rem;
            color: var(--gold);
            margin-bottom: 1rem;
            text-shadow: 0 0 30px rgba(212, 175, 55, 1);
            animation: victoryGlow 1.5s ease-in-out infinite alternate;
        }

        @keyframes victoryGlow {
            from {
                text-shadow: 0 0 30px rgba(212, 175, 55, 0.8);
            }

            to {
                text-shadow: 0 0 50px rgba(212, 175, 55, 1), 0 0 80px rgba(255, 215, 0, 0.6);
            }
        }

        @keyframes toastPulse {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.05);
            }
        }

        /* Responsive */

        /* Stats Panel */
        #statsPanel {
            position: fixed;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--gold);
            padding: 1rem;
            max-width: 250px;
            display: none;
            z-index: 90;
            font-family: 'Rajdhani', sans-serif;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        }

        .stats-panel-title {
            font-family: 'Bebas Neue';
            color: var(--gold);
            font-size: 1.2rem;
            margin-bottom: 0.8rem;
            text-align: center;
            border-bottom: 1px solid var(--gold);
            padding-bottom: 0.5rem;
        }

        .stats-panel-item {
            display: flex;
            justify-content: space-between;
            padding: 0.3rem 0;
            font-size: 0.9rem;
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
        }

        .stats-panel-label {
            color: #aaa;
        }

        .stats-panel-value {
            color: #fff;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .game-title {
                font-size: 3.2rem;
                white-space: normal;
                width: min(92vw, 520px);
                letter-spacing: 0.25rem;
            }

            .characters-grid {
                grid-template-columns: 1fr;
            }

            .upgrades-grid {
                grid-template-columns: 1fr;
            }

            .stats-container {
                flex-direction: column;
            }

            #statsPanel {
                left: 10px;
                max-width: 200px;
                padding: 0.8rem;
            }

            .stats-panel-title {
                font-size: 1rem;
            }

            .stats-panel-item {
                font-size: 0.8rem;
            }

        }

        /* Keep animated GIF <img> elements in the DOM so browsers advance frames */
        #gifPreload {
            position: fixed;
            left: -9999px;
            top: -9999px;
            width: 1px;
            height: 1px;
            overflow: hidden;
            opacity: 0;
            pointer-events: none;
        }

        #gifPreload img {
            width: 1px;
            height: 1px;
        }


        /* DOM sprite overlay (ensures GIF animations always play) */
        #spriteOverlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 2;
        }

        .dom-sprite {
            position: absolute;
            left: 0;
            top: 0;
            transform: translate(-50%, -50%);
            image-rendering: pixelated;
            will-change: transform;
        }


        .enemy-sprite {
            filter: drop-shadow(0 0 10px rgba(180, 210, 255, 0.55));
            image-rendering: pixelated;
        }

        .enemy-sprite.boss {
            filter: drop-shadow(0 0 14px rgba(255, 80, 80, 0.55));
        }

        .dom-sprite.flip {
            transform: translate(-50%, -50%) scaleX(-1);
        }

        /* Mobile Virtual Joystick */
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            pointer-events: none;
            z-index: 200;
        }

        #joystickContainer {
            position: fixed;
            left: 0;
            top: 0;
            width: 140px;
            height: 140px;
            display: none;
            z-index: 2500;
            pointer-events: none;
        }

        #joystickBase {
            position: absolute;
            width: 140px;
            height: 140px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(212, 175, 55, 0.3) 0%, rgba(212, 175, 55, 0.1) 70%, transparent 100%);
            border: 3px solid rgba(212, 175, 55, 0.5);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 20px rgba(212, 175, 55, 0.2);
        }

        #joystickStick {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(212, 175, 55, 0.9) 0%, rgba(139, 0, 0, 0.7) 100%);
            border: 3px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7), 0 0 10px rgba(212, 175, 55, 0.8);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: none;
        }

        #joystickStick.active {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.9), 0 0 20px rgba(212, 175, 55, 1);
        }

        /* Mobile responsive adjustments */
        /* Mobile - Small phones (‚â§480px) */
        @media (max-width: 480px) {
            #mobileControls {
                display: block;
            }

            body {
                overscroll-behavior: none;
                -webkit-user-select: none;
                user-select: none;
            }

            #gameCanvas {
                touch-action: none;
            }

            /* Menu */
            .game-title {
                font-size: 1.8rem;
                letter-spacing: 0.1rem;
                margin-bottom: 0.5rem;
            }

            .game-subtitle {
                font-size: 0.8rem;
                margin-bottom: 1.5rem;
                letter-spacing: 0.3rem;
            }

            .menu-btn {
                font-size: 1rem;
                padding: 0.5rem 1.5rem;
            }

            /* Character/Shop screens */
            .char-select-title,
            .shop-title {
                font-size: 1.3rem;
                margin-bottom: 1rem;
            }

            .characters-grid {
                grid-template-columns: 1fr;
                padding: 0.5rem;
                gap: 1rem;
            }

            .character-card {
                padding: 1rem;
            }

            .char-name {
                font-size: 1.2rem;
            }

            .char-type {
                font-size: 0.9rem;
            }

            .stat-row {
                font-size: 0.85rem;
            }

            .char-description {
                font-size: 0.8rem;
                line-height: 1.4;
            }

            .char-price {
                font-size: 1rem;
            }

            /* Level up */
            .levelup-title {
                font-size: 1.5rem;
                margin-bottom: 1rem;
            }

            .upgrades-grid {
                grid-template-columns: 1fr;
                gap: 0.8rem;
            }

            .upgrade-card {
                padding: 0.8rem;
            }

            .upgrade-name {
                font-size: 1rem;
                margin-bottom: 0.3rem;
            }

            .upgrade-description {
                font-size: 0.75rem;
            }

            /* HUD */
            #hud {
                padding: 0.3rem;
            }

            .hud-top {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.3rem;
                margin-bottom: 0.3rem;
            }

            .health-bar-container {
                min-width: 100%;
                max-width: 100%;
                padding: 0.3rem 0.5rem;
            }

            .health-label {
                font-size: 0.8rem;
                margin-bottom: 0.2rem;
            }

            .health-bar {
                height: 20px;
            }

            .health-text {
                font-size: 0.9rem;
            }

            .stats-container {
                flex-direction: row;
                width: 100%;
                justify-content: space-between;
                gap: 0.3rem;
                box-sizing: border-box;
                max-width: 100%;
            }

            .stat-box {
                min-width: 0;
                flex: 1;
                padding: 0.3rem 0.4rem;
                box-sizing: border-box;
                overflow: hidden;
            }

            .stat-label {
                font-size: 0.65rem;
            }

            .stat-value {
                font-size: 1.1rem;
            }

            .xp-bar-container {
                max-width: 100%;
                width: 100%;
                padding: 0.3rem 0.5rem;
                margin-top: 0.3rem;
                box-sizing: border-box;
            }

            .xp-label {
                font-size: 0.7rem;
            }

            .xp-bar {
                height: 15px;
            }

            /* Game Over/Victory */
            .gameover-title,
            .victory-title {
                font-size: 2rem;
            }

            .gameover-stats {
                font-size: 1rem;
                line-height: 1.8;
                margin: 1rem 0;
            }

            .gameover-container,
            .victory-container {
                padding: 1.5rem;
            }

            /* Joystick */
            #joystickContainer {
                width: 100px;
                height: 100px;
                bottom: 10px;
                left: 10px;
            }

            #joystickBase {
                width: 100px;
                height: 100px;
            }

            #joystickStick {
                width: 45px;
                height: 45px;
            }

            /* Back button */
            .back-btn {
                font-size: 1rem;
                padding: 0.3rem 1rem;
            }
        }

        /* Tablet - Medium screens (481px - 768px) */
        @media (min-width: 481px) and (max-width: 768px) {
            #mobileControls {
                display: block;
            }

            body {
                overscroll-behavior: none;
                -webkit-user-select: none;
                user-select: none;
            }

            #gameCanvas {
                touch-action: none;
            }

            /* Menu */
            .game-title {
                font-size: 2.5rem;
                letter-spacing: 0.15rem;
            }

            .game-subtitle {
                font-size: 1rem;
                margin-bottom: 2rem;
            }

            .menu-btn {
                font-size: 1.3rem;
                padding: 0.6rem 2rem;
            }

            /* Character/Shop */
            .char-select-title,
            .shop-title {
                font-size: 1.8rem;
            }

            .characters-grid {
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: 1.5rem;
            }

            .character-card {
                padding: 1.3rem;
            }

            .char-name {
                font-size: 1.4rem;
            }

            /* Level up */
            .levelup-title {
                font-size: 1.8rem;
            }

            .upgrades-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .upgrade-card {
                padding: 1rem;
            }

            /* HUD */
            #hud {
                padding: 0.4rem;
            }

            .hud-top {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.4rem;
            }

            .health-bar-container {
                min-width: 100%;
                max-width: 100%;
                width: 100%;
                box-sizing: border-box;
            }

            .stats-container {
                flex-direction: row;
                width: 100%;
                max-width: 100%;
                justify-content: space-between;
                gap: 0.5rem;
                box-sizing: border-box;
            }

            .stat-box {
                min-width: 0;
                flex: 1;
                box-sizing: border-box;
            }

            /* Joystick */
            #joystickContainer {
                width: 120px;
                height: 120px;
                bottom: 15px;
                left: 15px;
            }

            #joystickBase {
                width: 120px;
                height: 120px;
            }

            #joystickStick {
                width: 50px;
                height: 50px;
            }
        }

        /* Laptop - Medium-large screens (769px - 1366px) */
        @media (min-width: 769px) and (max-width: 1366px) {

            /* Slightly smaller than desktop but maintain readability */
            .game-title {
                font-size: 4rem;
            }

            .game-subtitle {
                font-size: 1.3rem;
            }

            .menu-btn {
                font-size: 1.7rem;
                padding: 0.9rem 2.5rem;
            }

            .char-select-title,
            .shop-title {
                font-size: 2.5rem;
            }

            .character-card {
                padding: 1.8rem;
            }

            .char-name {
                font-size: 1.8rem;
            }

            .levelup-title {
                font-size: 2.5rem;
            }

            .upgrade-name {
                font-size: 1.3rem;
            }

            /* HUD adjustments for laptop */
            .health-bar-container {
                min-width: 280px;
            }

            .stat-box {
                min-width: 110px;
            }

            .stat-value {
                font-size: 1.6rem;
            }

            .xp-bar-container {
                max-width: 450px;
            }
        }

        /* Desktop - Large screens (>1366px) */
        /* Default styles are for desktop, no media query needed */
        /* All original sizes remain unchanged */

        /* Prevent text selection on mobile */
        * {
            -webkit-tap-highlight-color: transparent;
        }

        /* --- Mobile/Tablet UI fixes (does NOT affect desktop) --- */
        @media (max-width: 900px) {

            /* Keep panels clear of the back button */
            #shop,
            #characterSelect,
            #options {
                padding-top: calc(6.25rem + env(safe-area-inset-top));
            }

            /* In-game HUD order: Health -> XP -> Timer/Level/Kills */
            #hud {
                left: 50%;
                top: calc(1rem + env(safe-area-inset-top));
                transform: translateX(-50%);
                width: min(520px, calc(100vw - 2rem - env(safe-area-inset-left) - env(safe-area-inset-right)));
            }

            .hud-top {
                display: contents;
            }

            .health-bar-container {
                grid-area: health;
            }

            .xp-bar-container {
                grid-area: xp;
            }

            .stats-container {
                grid-area: stats;
            }

            #hud {
                display: grid !important;
                grid-template-areas:
                    "health"
                    "xp"
                    "stats";
                gap: 0.75rem;
            }

            .stats-container {
                width: 100%;
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 0.6rem;
            }

            /* Defeated UI polish */
            #gameOverScreen .game-over-content,
            #victoryScreen .game-over-content {
                width: min(420px, calc(100vw - 2rem));
                margin: 0 auto;
                padding: 0 0.75rem;
            }

            #gameOverScreen .game-over-title {
                font-size: 3rem;
                letter-spacing: 0.08em;
            }
        }

        /* Tablet tuning */
        @media (min-width: 901px) and (max-width: 1200px) {
            #hud {
                left: 1.25rem;
                top: 1.25rem;
                width: 520px;
            }
        }

        /* Upgrade Activation Animations */
        @keyframes upgradeActivate {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }

            50% {
                transform: scale(1.3);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 0;
            }
        }

        .upgrade-flash {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            animation: upgradeActivate 1s ease-out forwards;
        }

        @keyframes permanentGlow {

            0%,
            100% {
                opacity: 0.6;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.1);
            }
        }


        /* Landscape Mode Enforcement for Mobile */
        @media (max-width: 768px) {
            body {
                zoom: 0.5;
                /* 50% zoom for mobile */
                -moz-transform: scale(0.5);
                -moz-transform-origin: 0 0;
            }
        }

        /* Portrait Mode Warning Overlay */
        #landscapeWarning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 99999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            padding: 2rem;
        }

        #landscapeWarning .rotate-icon {
            font-size: 5rem;
            margin-bottom: 2rem;
            animation: rotateDevice 2s ease-in-out infinite;
        }

        #landscapeWarning h2 {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            color: var(--gold);
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.6);
        }

        #landscapeWarning p {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.2rem;
            color: #aaa;
            max-width: 400px;
        }

        @keyframes rotateDevice {

            0%,
            100% {
                transform: rotate(0deg);
            }

            25% {
                transform: rotate(-90deg);
            }

            50% {
                transform: rotate(-90deg);
            }

            75% {
                transform: rotate(-90deg);
            }
        }

        /* Desktop - no zoom */
        @media (min-width: 769px) {
            body {
                zoom: 1;
            }
        }
    </style>
</head>

<body>

    <!-- Landscape Mode Warning (Mobile Only) -->
    <div id="landscapeWarning">
        <div class="rotate-icon">üì± ‚Üª</div>
        <h2>ROTATE YOUR DEVICE</h2>
        <p>Please rotate your device to landscape mode for the best gaming experience.</p>
    </div>

    <div id="gifPreload" aria-hidden="true"></div>

    <!-- Stats Panel -->
    <div id="statsPanel">
        <div class="stats-panel-title">CURRENT STATS</div>
        <div class="stats-panel-item">
            <span class="stats-panel-label">Damage:</span>
            <span class="stats-panel-value" id="statDamage">0</span>
        </div>
        <div class="stats-panel-item">
            <span class="stats-panel-label">Attack Speed:</span>
            <span class="stats-panel-value" id="statAttackSpeed">0</span>
        </div>
        <div class="stats-panel-item">
            <span class="stats-panel-label">Move Speed:</span>
            <span class="stats-panel-value" id="statMoveSpeed">0</span>
        </div>
        <div class="stats-panel-item">
            <span class="stats-panel-label">Crit Chance:</span>
            <span class="stats-panel-value" id="statCritChance">0%</span>
        </div>
        <div class="stats-panel-item">
            <span class="stats-panel-label">Max HP:</span>
            <span class="stats-panel-value" id="statMaxHP">0</span>
        </div>
        <div class="stats-panel-item">
            <span class="stats-panel-label">Defense:</span>
            <span class="stats-panel-value" id="statDefense">0</span>
        </div>
        <div class="stats-panel-item">
            <span class="stats-panel-label">XP Mult:</span>
            <span class="stats-panel-value" id="statXPMult">1x</span>
        </div>
        <div class="stats-panel-item">
            <span class="stats-panel-label">Dodge:</span>
            <span class="stats-panel-value" id="statDodge">0%</span>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="mainMenu">
        <h1 class="game-title">BARK OF SURVIVAL</h1>
        <p class="game-subtitle">Fight ‚Ä¢ Survive ‚Ä¢ Evolve</p>
        <div class="menu-buttons">
            <button class="menu-btn" onclick="showCharacterSelect()">Start Game</button>
            <button class="menu-btn" onclick="showShop()">Shop</button>
            <button class="menu-btn" onclick="showOptions()">Options</button>
        </div>
    </div>

    <!-- Character Selection -->
    <div id="characterSelect">
        <button class="back-btn" onclick="backToMenu()">‚Üê Back</button>
        <h2 class="char-select-title">Choose Your Survivor</h2>
        <div class="characters-grid">
            <div class="character-card" onclick="selectCharacter(0)">
                <h3 class="char-name">Rex</h3>
                <p class="char-type">The Brawler</p>
                <div class="char-stats">
                    <div class="stat-row">
                        <span>Range:</span>
                        <span>‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Speed:</span>
                        <span>‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Damage:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Attack Rate:</span>
                        <span>‚≠ê‚≠ê‚≠ê</span>
                    </div>
                </div>
                <p class="char-description">
                    A close-combat specialist who delivers devastating punches. High damage at short range, perfect for
                    aggressive players who like to get up close and personal.
                </p>
                <p class="char-price">Available</p>
            </div>

            <div class="character-card locked" id="archerCard">
                <h3 class="char-name">Luna</h3>
                <p class="char-type">The Ranger</p>
                <div class="char-stats">
                    <div class="stat-row">
                        <span>Range:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Speed:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Damage:</span>
                        <span>‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Attack Rate:</span>
                        <span>‚≠ê‚≠ê‚≠ê</span>
                    </div>
                </div>
                <p class="char-description">
                    A skilled archer with exceptional range. Fires arrows that pierce through enemies. Ideal for players
                    who prefer keeping their distance.
                </p>
                <p class="char-price">Cost: 500 Bones</p>
            </div>

            <div class="character-card locked" id="swordCard">
                <h3 class="char-name">Blade</h3>
                <p class="char-type">The Swordsman</p>
                <div class="char-stats">
                    <div class="stat-row">
                        <span>Range:</span>
                        <span>‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Speed:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Damage:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Attack Rate:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                </div>
                <p class="char-description">
                    A lightning-fast swordsman with balanced range and high attack speed. Slices through enemies with
                    rapid strikes. For skilled players who value precision.
                </p>
                <p class="char-price">Cost: 1000 Bones</p>
            </div>
        </div>
    </div>

    <!-- Shop -->
    <div id="shop">
        <button class="back-btn" onclick="backToMenu()">‚Üê Back</button>
        <h2 class="shop-title">Survivor's Shop</h2>
        <div class="currency-display">Bones: <span id="shopCurrency">0</span></div>
        <div class="characters-grid">
            <div class="character-card locked" id="shopArcherCard">
                <h3 class="char-name">Luna</h3>
                <p class="char-type">The Ranger</p>
                <div class="char-stats">
                    <div class="stat-row">
                        <span>Range:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Speed:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Damage:</span>
                        <span>‚≠ê‚≠ê‚≠ê</span>
                    </div>
                </div>
                <p class="char-description">
                    A skilled archer with exceptional range. Fires arrows that pierce through enemies.
                </p>
                <p class="char-price">Cost: 500 Bones</p>
                <button class="menu-btn" style="width: 100%; margin-top: 1rem; font-size: 1.5rem; padding: 0.5rem;"
                    onclick="buyCharacter(1, 500)">Purchase</button>
            </div>

            <div class="character-card locked" id="shopSwordCard">
                <h3 class="char-name">Blade</h3>
                <p class="char-type">The Swordsman</p>
                <div class="char-stats">
                    <div class="stat-row">
                        <span>Range:</span>
                        <span>‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Speed:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Damage:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                </div>
                <p class="char-description">
                    A lightning-fast swordsman with balanced range and high attack speed.
                </p>
                <p class="char-price">Cost: 1000 Bones</p>
                <button class="menu-btn" style="width: 100%; margin-top: 1rem; font-size: 1.5rem; padding: 0.5rem;"
                    onclick="buyCharacter(2, 1000)">Purchase</button>
            </div>

            <!-- Permanent Upgrades Section -->
            <div class="character-card" id="shopHealthUpgrade"
                style="background: linear-gradient(135deg, #1a4d1a 0%, #0d260d 100%);">
                <h3 class="char-name">Health Boost</h3>
                <p class="char-type">Permanent Upgrade</p>
                <p class="char-description">
                    Start each run with +10 Max Health. Stacks with each purchase.
                </p>
                <p class="char-price">Cost: <span id="healthUpgradeCost">200</span> Bones</p>
                <button class="menu-btn" style="width: 100%; margin-top: 1rem; font-size: 1.5rem; padding: 0.5rem;"
                    onclick="buyPermanentUpgrade('health', 200)">Purchase</button>
            </div>

            <div class="character-card" id="shopDamageUpgrade"
                style="background: linear-gradient(135deg, #4d1a1a 0%, #260d0d 100%);">
                <h3 class="char-name">Power Surge</h3>
                <p class="char-type">Permanent Upgrade</p>
                <p class="char-description">
                    Start each run with +3 Base Damage. Stacks with each purchase.
                </p>
                <p class="char-price">Cost: <span id="damageUpgradeCost">300</span> Bones</p>
                <button class="menu-btn" style="width: 100%; margin-top: 1rem; font-size: 1.5rem; padding: 0.5rem;"
                    onclick="buyPermanentUpgrade('damage', 300)">Purchase</button>
            </div>

            <div class="character-card" id="shopSpeedUpgrade"
                style="background: linear-gradient(135deg, #1a1a4d 0%, #0d0d26 100%);">
                <h3 class="char-name">Swift Feet</h3>
                <p class="char-type">Permanent Upgrade</p>
                <p class="char-description">
                    Start each run with +5% Movement Speed. Stacks with each purchase.
                </p>
                <p class="char-price">Cost: <span id="speedUpgradeCost">250</span> Bones</p>
                <button class="menu-btn" style="width: 100%; margin-top: 1rem; font-size: 1.5rem; padding: 0.5rem;"
                    onclick="buyPermanentUpgrade('speed', 250)">Purchase</button>
            </div>

            <div class="character-card" id="shopXPUpgrade"
                style="background: linear-gradient(135deg, #4d4d1a 0%, #26260d 100%);">
                <h3 class="char-name">Wisdom</h3>
                <p class="char-type">Permanent Upgrade</p>
                <p class="char-description">
                    Gain +10% more XP from all sources. Stacks with each purchase.
                </p>
                <p class="char-price">Cost: <span id="xpUpgradeCost">400</span> Bones</p>
                <button class="menu-btn" style="width: 100%; margin-top: 1rem; font-size: 1.5rem; padding: 0.5rem;"
                    onclick="buyPermanentUpgrade('xp', 400)">Purchase</button>
            </div>
        </div>
    </div>

    <!-- Options Screen -->
    <div id="options"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10,10,10,0.95); z-index: 999; padding: 2rem; overflow-y: auto;">
        <button class="back-btn" onclick="backToMenu()">‚Üê Back</button>
        <h2 class="shop-title">Options</h2>

        <div style="max-width: 800px; margin: 2rem auto; display: flex; flex-direction: column; gap: 2rem;">


            <!-- Audio -->
            <div class="character-card" style="background: linear-gradient(135deg, #1a2a2a 0%, #0e1414 100%);">
                <h3 class="char-name">Audio</h3>
                <p class="char-description">Toggle background music and sound effects.</p>
                <div style="display:flex; gap:12px; flex-wrap:wrap; margin-top:12px;">
                    <button id="musicToggleBtn" class="menu-btn" style="min-width:160px;" onclick="toggleMusic()">Music:
                        ON</button>
                    <button id="sfxToggleBtn" class="menu-btn" style="min-width:160px;" onclick="toggleSfx()">SFX:
                        ON</button>
                </div>
            </div>

            <!-- Game Info -->
            <div class="character-card" style="background: linear-gradient(135deg, #2c2c2c 0%, #1a1a1a 100%);">
                <h3 class="char-name">Game Information</h3>
                <div class="char-stats">
                    <div class="stat-row">
                        <span>Total Bones:</span>
                        <span id="optionsCurrency" style="color: var(--gold);">0</span>
                    </div>
                    <div class="stat-row">
                        <span>Characters Unlocked:</span>
                        <span id="optionsCharacters" style="color: var(--gold);">1/3</span>
                    </div>
                    <div class="stat-row">
                        <span>Permanent Upgrades:</span>
                        <span id="optionsUpgrades" style="color: var(--gold);">0</span>
                    </div>
                </div>
            </div>

            <!-- Danger Zone -->
            <div class="character-card"
                style="background: linear-gradient(135deg, #4d1a1a 0%, #260d0d 100%); border-color: var(--danger-red);">
                <h3 class="char-name" style="color: var(--danger-red);">‚ö† Danger Zone</h3>
                <p class="char-description" style="margin: 1rem 0;">
                    <strong>Warning:</strong> This will permanently delete ALL progress including:
                </p>
                <ul style="list-style: none; padding: 0; margin: 1rem 0; color: #ccc;">
                    <li>‚Ä¢ All Bones (currency)</li>
                    <li>‚Ä¢ Unlocked Characters (Luna & Blade)</li>
                    <li>‚Ä¢ All Permanent Upgrades</li>
                    <li>‚Ä¢ All game progress</li>
                </ul>
                <p class="char-description" style="margin: 1rem 0; color: var(--danger-red);">
                    This action <strong>CANNOT</strong> be undone!
                </p>
                <button class="menu-btn"
                    style="width: 100%; margin-top: 1rem; font-size: 1.5rem; padding: 0.5rem; background: linear-gradient(135deg, var(--danger-red) 0%, #8B0000 100%); border-color: var(--danger-red);"
                    onclick="confirmResetGame()">
                    Reset Entire Game
                </button>
            </div>

            <!-- Credits -->
            <div class="character-card" style="background: linear-gradient(135deg, #1a1a4d 0%, #0d0d26 100%);">
                <h3 class="char-name">About</h3>
                <p class="char-description">
                    <strong>Bark of Survival</strong><br>
                    A roguelike survival game where you fight endless waves of ghosts.<br><br>
                    Survive, upgrade, and evolve to become the ultimate survivor!
                </p>
            </div>

        </div>
    </div>

    <!-- Game Canvas -->
    <div id="canvasWrap" style="position:relative; width:100%; height:100%;">
        <canvas id="gameCanvas"></canvas>
        <div id="spriteOverlay"></div>
    </div>

    <!-- Mobile Controls -->
    <div id="mobileControls">
        <div id="joystickContainer">
            <div id="joystickBase"></div>
            <div id="joystickStick"></div>
        </div>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-top">
            <div class="health-bar-container">
                <div class="health-label">HEALTH</div>
                <div class="health-bar">
                    <div class="health-fill" id="healthFill"></div>
                    <div class="health-text" id="healthText">100/100</div>
                </div>
            </div>
            <div class="stats-container">
                <div class="stat-box">
                    <div class="stat-label">TIMER</div>
                    <div class="stat-value" id="timerValue">5:00</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">LEVEL</div>
                    <div class="stat-value" id="levelValue">1</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">KILLS</div>
                    <div class="stat-value" id="killsValue">0</div>
                </div>
            </div>
        </div>
        <div class="xp-bar-container">
            <div class="xp-label">EXPERIENCE</div>
            <div class="xp-bar">
                <div class="xp-fill" id="xpFill"></div>
            </div>
        </div>
    </div>

    <!-- Level Up Screen -->
    <div id="levelUpScreen">
        <div class="levelup-container">
            <h2 class="levelup-title">LEVEL UP!</h2>
            <div class="upgrades-grid" id="upgradesGrid"></div>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen">
        <div class="gameover-container">
            <h2 class="gameover-title">DEFEATED</h2>
            <div class="gameover-stats">
                <div>Time Survived: <span id="finalTime">0:00</span></div>
                <div>Enemies Slain: <span id="finalKills">0</span></div>
                <div>Level Reached: <span id="finalLevel">1</span></div>
                <div>Bones Earned: <span id="bonesEarned">0</span></div>
            </div>
            <div class="gameover-buttons">
                <button class="menu-btn" onclick="restartGame()">Try Again</button>
                <button class="menu-btn" onclick="backToMenu()">Main Menu</button>
            </div>
        </div>
    </div>

    <!-- Victory Screen -->
    <div id="victoryScreen">
        <div class="victory-container">
            <h2 class="victory-title">VICTORY!</h2>
            <div class="gameover-stats">
                <div>You Survived!</div>
                <div>Enemies Slain: <span id="victoryKills">0</span></div>
                <div>Level Reached: <span id="victoryLevel">1</span></div>
                <div>Bones Earned: <span id="victoryBones">0</span></div>
            </div>
            <div class="gameover-buttons">
                <button class="menu-btn" onclick="restartGame()">Play Again</button>
                <button class="menu-btn" onclick="backToMenu()">Main Menu</button>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        // Tileset world (open-world feel)
        const TILESET_PATH = 'Tiles/tile_set.png'; // from your tileset tester
        const TILE_SIZE = 32;   // source tile size (px in atlas)
        const TILE_SCALE = 2;   // draw scale (pixel-art upscale)
        const TILE_PX = TILE_SIZE * TILE_SCALE;

        const MAP_W = 140;
        const MAP_H = 140;

        // Tile indices (linear index into atlas). Tweak these to make the map look good.
        let FLOOR_TILE = 0;           // main ground tile index
        let FLOOR_VARIANTS = [0, 0, 0, 0, 1, 2, 3]; // weighted variants (edit as you like)
        let WALL_TILE = 1;            // border/wall tile index
        let DECOR_TILES = [4, 5, 6, 7]; // occasional decor tiles

        // Procedural map generator (visual only; no collision yet)
        function regenMap(seed = Math.random() * 999999) {
            // --- Patch noise helpers (fast, deterministic; creates clustered ‚Äúblobs‚Äù)
            // (this replaces per-cell randomness that caused a checker/speckle look)
            function hash2(ix, iy) {
                // deterministic pseudo-random 0..1 from int coords (+seed)
                let n = (ix * 374761393 + iy * 668265263) ^ (ix * iy);
                n = (n ^ (n >> 13)) * 1274126177;
                n = (n ^ (n >> 16)) >>> 0;
                // mix seed
                n = (n + (seed | 0)) >>> 0;
                return n / 4294967295;
            }
            const smoothstep = (t) => t * t * (3 - 2 * t);
            const lerp = (a, b, t) => a + (b - a) * t;

            // Value noise sampled on a coarse grid; larger cell => bigger patches.
            function valueNoise(x, y, cellSize = 14) {
                const gx = Math.floor(x / cellSize), gy = Math.floor(y / cellSize);
                const fx = (x / cellSize) - gx, fy = (y / cellSize) - gy;

                const v00 = hash2(gx, gy);
                const v10 = hash2(gx + 1, gy);
                const v01 = hash2(gx, gy + 1);
                const v11 = hash2(gx + 1, gy + 1);

                const sx = smoothstep(fx), sy = smoothstep(fy);
                const ix0 = lerp(v00, v10, sx);
                const ix1 = lerp(v01, v11, sx);
                return lerp(ix0, ix1, sy);
            }

            // Dedupe variants so thresholds map to distinct tiles
            const uniqVariants = Array.from(new Set([FLOOR_TILE, ...(FLOOR_VARIANTS || [])]))
                .filter(v => Number.isFinite(v) && v >= 0);
            const alt1 = uniqVariants[1] ?? FLOOR_TILE;
            const alt2 = uniqVariants[2] ?? alt1;
            const alt3 = uniqVariants[3] ?? alt2;

            // Style knobs
            const PATCH_SIZE = 14;      // 10‚Äì18 feels good
            const DECOR_RATE = 0.012;   // 1.2% decor density
            for (let y = 0; y < MAP_H; y++) {
                for (let x = 0; x < MAP_W; x++) {
                    // solid border
                    if (x === 0 || y === 0 || x === MAP_W - 1 || y === MAP_H - 1) { map[y][x] = WALL_TILE; continue; }

                    // Clustered floor variants (patches instead of per-cell randomness)
                    const n = valueNoise(x, y, PATCH_SIZE);

                    // Big patches of alt1, smaller patches of alt2, rare accents alt3
                    let t = FLOOR_TILE;
                    if (n > 0.78) t = alt1;
                    if (n > 0.88) t = alt2;
                    if (n > 0.95) t = alt3;

                    // Sprinkle decor: only on mid-tone areas so it doesn't overwhelm
                    if (DECOR_TILES.length) {
                        const d = hash2(x * 19, y * 19);
                        if (d < DECOR_RATE && n > 0.35 && n < 0.75) {
                            t = DECOR_TILES[Math.floor(hash2(x + 111, y + 111) * DECOR_TILES.length)];
                        }
                    }

                    map[y][x] = t;
                }
            }
        }

        // Initialize empty map first, then generate
        const map = Array.from({ length: MAP_H }, () => Array.from({ length: MAP_W }, () => FLOOR_TILE));
        regenMap();

        const WORLD = { w: MAP_W * TILE_PX, h: MAP_H * TILE_PX };
        const camera = { x: WORLD.w / 2, y: WORLD.h / 2 };

        const tileset = new Image();
        tileset.decoding = 'async';
        let tilesetReady = false;
        let tilesPerRow = 1;

        tileset.onload = () => {
            tilesetReady = true;
            tilesPerRow = Math.max(1, Math.floor(tileset.naturalWidth / TILE_SIZE));
        };
        tileset.onerror = () => {
            tilesetReady = false;
            console.warn('Tileset failed to load:', TILESET_PATH);
        };
        tileset.src = TILESET_PATH;

        const CAMERA_LERP = 0.12; // lower = smoother (more floaty)
        const TIME_SCALE = 0.80;  // global pacing (lower = slower) - CONSTANT, never modify!
        Object.freeze({ TIME_SCALE }); // Ensure it cannot be changed

        function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

        // Mobile-only play boundary to prevent viewport/DOM jitter when traveling too far
        const MOBILE_PLAY_BOUNDS = { w: 1000, h: 1000 }; // in world pixels
        let IS_MOBILE = window.matchMedia('(max-width: 600px)').matches;

        function updateDeviceFlags() {
            IS_MOBILE = window.matchMedia('(max-width: 600px)').matches;
        }
        window.addEventListener('resize', updateDeviceFlags, { passive: true });

        function getPlayBounds() {
            // Default: whole world
            let minX = 0, minY = 0, maxX = WORLD.w, maxY = WORLD.h;

            // Mobile: constrain to a centered box
            if (IS_MOBILE) {
                const bw = Math.min(MOBILE_PLAY_BOUNDS.w, WORLD.w);
                const bh = Math.min(MOBILE_PLAY_BOUNDS.h, WORLD.h);
                minX = (WORLD.w - bw) / 2;
                minY = (WORLD.h - bh) / 2;
                maxX = minX + bw;
                maxY = minY + bh;
            }
            return { minX, minY, maxX, maxY };
        }

        function clampCameraToBounds() {
            const b = getPlayBounds();

            // Clamp camera so the viewport stays within bounds.
            // If bounds are smaller than the viewport, lock camera to bounds center.
            const halfW = canvas.width / 2;
            const halfH = canvas.height / 2;

            const minCamX = b.minX + halfW;
            const maxCamX = b.maxX - halfW;
            const minCamY = b.minY + halfH;
            const maxCamY = b.maxY - halfH;

            if (minCamX > maxCamX) camera.x = (b.minX + b.maxX) / 2;
            else camera.x = clamp(camera.x, minCamX, maxCamX);

            if (minCamY > maxCamY) camera.y = (b.minY + b.maxY) / 2;
            else camera.y = clamp(camera.y, minCamY, maxCamY);
        }

        // Tileset helper
        function tileToSrc(tileIndex) {
            const sx = (tileIndex % tilesPerRow) * TILE_SIZE;
            const sy = Math.floor(tileIndex / tilesPerRow) * TILE_SIZE;
            return { sx, sy };
        }

        // Draw visible world tiles (called every frame)
        function drawTiles() {
            // View bounds in world coords
            const left = camera.x - canvas.width / 2;
            const top = camera.y - canvas.height / 2;

            const startTx = Math.max(0, Math.floor(left / TILE_PX) - 1);
            const startTy = Math.max(0, Math.floor(top / TILE_PX) - 1);
            const endTx = Math.min(MAP_W - 1, Math.floor((left + canvas.width) / TILE_PX) + 1);
            const endTy = Math.min(MAP_H - 1, Math.floor((top + canvas.height) / TILE_PX) + 1);

            for (let ty = startTy; ty <= endTy; ty++) {
                for (let tx = startTx; tx <= endTx; tx++) {
                    const tileIndex = map[ty][tx] ?? 0;
                    const wx = tx * TILE_PX;
                    const wy = ty * TILE_PX;

                    if (tilesetReady) {
                        const { sx, sy } = tileToSrc(tileIndex);
                        ctx.drawImage(
                            tileset,
                            sx, sy, TILE_SIZE, TILE_SIZE,
                            wx, wy, TILE_PX, TILE_PX
                        );
                    } else {
                        // fallback: dark checker
                        const isDark = ((tx + ty) % 2) === 0;
                        ctx.fillStyle = isDark ? '#0a0a0a' : '#0c0c0c';
                        ctx.fillRect(wx, wy, TILE_PX, TILE_PX);
                    }
                }
            }

            // soft vignette (screen-space) - draw after resetting transform elsewhere
        }


        // --- DOM sprite overlay (fixes GIFs freezing in canvas for some characters) ---

        const ENEMY_SPRITES = {
            normal: {
                walk: 'assets/walk_4.gif',
                hurt: 'assets/hurt_4.gif',
                dead: 'assets/dead_4.gif'
            },
            boss: {
                walk: 'assets/walk_5.gif',
                // boss only has one sprite provided; reuse walk for all states
                hurt: 'assets/walk_5.gif',
                dead: 'assets/walk_5.gif'
            }
        };

        const USE_DOM_SPRITES = true;
        const spriteOverlay = document.getElementById('spriteOverlay');
        let playerDomImg = null;

        function ensurePlayerDomImg() {
            if (playerDomImg) return playerDomImg;
            playerDomImg = document.createElement('img');
            playerDomImg.className = 'dom-sprite';
            playerDomImg.alt = 'player';
            // keep it ‚Äúvisible‚Äù for GIF frame advancement
            playerDomImg.decoding = 'async';
            playerDomImg.loading = 'eager';
            spriteOverlay && spriteOverlay.appendChild(playerDomImg);
            return playerDomImg;
        }

        function setPlayerDomSprite(src, x, y, w, h, facingRight, bobY) {
            if (!USE_DOM_SPRITES || !spriteOverlay) return;
            const el = ensurePlayerDomImg();
            if (!el) return;
            if (src && el.src !== src) el.src = src;
            el.style.width = Math.max(1, w) + 'px';
            el.style.height = Math.max(1, h) + 'px';
            const flip = facingRight ? 1 : -1;
            // position in SCREEN coords (camera already applied)
            el.style.left = x + 'px';
            el.style.top = (y + (bobY || 0)) + 'px';
            el.style.transform = `translate(-50%, -50%) scaleX(${flip})`;
        }

        function hidePlayerDomSprite() {
            if (playerDomImg) playerDomImg.style.width = '0px';
        }

        // Enemy DOM sprites (ghosts)
        const enemyDomImgs = new Map(); // id -> <img>
        function ensureEnemyDomImg(enemy) {
            if (!USE_DOM_SPRITES || !spriteOverlay) return null;
            if (!enemy.id) enemy.id = 'e' + Math.random().toString(16).slice(2);
            if (enemyDomImgs.has(enemy.id)) return enemyDomImgs.get(enemy.id);
            const img = document.createElement('img');
            img.className = 'dom-sprite enemy-sprite';
            img.style.left = '0px';
            img.style.top = '0px';
            img.style.width = '0px';
            img.style.height = '0px';
            img.style.transform = 'translate(-50%, -50%)';
            spriteOverlay.appendChild(img);
            enemyDomImgs.set(enemy.id, img);
            return img;
        }
        function removeEnemyDomImg(enemy) {
            if (!enemy || !enemy.id) return;
            const el = enemyDomImgs.get(enemy.id);
            if (el) el.remove();
            enemyDomImgs.delete(enemy.id);
        }
        function setEnemyDomSprite(enemy, src, screenX, screenY, sizePx = 64, opacity = 1) {
            if (!USE_DOM_SPRITES || !spriteOverlay) return;
            const el = ensureEnemyDomImg(enemy);
            if (!el) return;
            if (el.dataset.src !== src) {
                el.dataset.src = src;
                el.src = src + (src.includes('?') ? '&' : '?') + 'v=' + Date.now(); // bust cache for gif frame resets
            }
            el.style.width = sizePx + 'px';
            el.style.height = sizePx + 'px';
            el.style.left = screenX + 'px';
            el.style.top = screenY + 'px';
            el.style.opacity = opacity;

            // Flip sprite to face the player
            const scaleX = enemy.facingRight ? 1 : -1;
            el.style.transform = `translate(-50%, -50%) scaleX(${scaleX})`;
        }
        function removeEnemyAtIndex(arr, idx) {
            const e = arr[idx];
            removeEnemyDomImg(e);
            arr.splice(idx, 1);
        }

        function clearDomSprites() {
            // Clear any lingering DOM sprite overlays between runs (prevents "stuck" ghosts / player sprites)
            try {
                if (playerDomImg) {
                    playerDomImg.remove();
                    playerDomImg = null;
                }
                enemyDomImgs.forEach((img) => { try { img.remove(); } catch (e) { } });
                enemyDomImgs.clear();
                if (spriteOverlay) spriteOverlay.innerHTML = '';
            } catch (e) {
                // no-op
            }
        }


        // Make canvas fullscreen
        function setVhUnit() {
            // Fix 100vh issues on mobile browsers (address bar / toolbars)
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }

        function resizeCanvas() {
            setVhUnit();
            const w = Math.max(1, Math.floor(window.innerWidth));
            const h = Math.max(1, Math.floor(window.innerHeight));
            canvas.width = w;
            canvas.height = h;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 200));
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', resizeCanvas);
            window.visualViewport.addEventListener('scroll', resizeCanvas);
        }

        // Sprite loading system
        const sprites = {
            loaded: false,
            images: {},
            loadStatus: {} // Track loading status
        };

        function loadSprites() {
            return new Promise((resolve) => {
                const spriteNames = [
                    'attack_1', 'dead_1', 'hurt_1', 'idle_1', 'walk_1',
                    'attack_2', 'dead_2', 'hurt_2', 'idle_2', 'walk_2',
                    'attack_3', 'dead_3', 'hurt_3', 'idle_3', 'walk_3',
                    'walk_4', 'hurt_4', 'dead_4', 'walk_5'

                ];

                let loaded = 0;
                const total = spriteNames.length;

                spriteNames.forEach(name => {
                    const img = new Image();

                    // Important: Set crossOrigin before src for local files
                    img.crossOrigin = "anonymous";

                    img.onload = () => {
                        loaded++;
                        sprites.loadStatus[name] = 'loaded';
                        console.log(`‚úì Loaded: ${name}.gif (${img.naturalWidth}x${img.naturalHeight})`);
                        if (loaded === total) {
                            sprites.loaded = true;
                            console.log('‚úì All sprites loaded successfully!');
                            console.log('Status:', sprites.loadStatus);
                            resolve();
                        }
                    };

                    img.onerror = (e) => {
                        loaded++;
                        sprites.loadStatus[name] = 'failed';
                        console.error(`‚úó Failed to load ${name}.gif - Check if file exists in assets/ folder`);
                        if (loaded === total) {
                            sprites.loaded = true;
                            console.log('Status:', sprites.loadStatus);
                            resolve();
                        }
                    };

                    // Force reload without cache
                    const timestamp = Date.now();
                    img.src = `assets/${name}.gif?nocache=${timestamp}`;
                    sprites.images[name] = img;

                    // Attach to hidden DOM container so GIF frames advance reliably
                    const preload = document.getElementById('gifPreload');
                    if (preload) preload.appendChild(img);
                });
            });
        }

        // Load sprites on page load
        loadSprites();

        // Game state
        const gameState = {
            screen: 'menu', // menu, playing, levelup, gameover, victory
            paused: false,
            currency: parseInt(localStorage.getItem('barkCurrency') || '0'),
            unlockedCharacters: JSON.parse(localStorage.getItem('barkUnlocked') || '[true, false, false]'),
            permanentUpgrades: JSON.parse(localStorage.getItem('barkPermanent') || '{"health":0,"damage":0,"speed":0,"xp":0}')
        };

        // Character definitions
        const characters = [
            {
                name: 'Rex',
                type: 'brawler',
                baseHealth: 100,
                baseDamage: 8,
                attackRange: 50,
                attackSpeed: 1.1, // seconds
                moveSpeed: 170,
                projectileSpeed: 0,
                animPrefix: '1',
                spriteScale: 0.50 // Smaller on-canvas render
            },
            {
                name: 'Luna',
                type: 'archer',
                baseHealth: 80,
                baseDamage: 7,
                attackRange: 200,
                attackSpeed: 1.15,
                moveSpeed: 185,
                projectileSpeed: 520,
                animPrefix: '2',
                spriteScale: 0.50
            },
            {
                name: 'Blade',
                type: 'swordsman',
                baseHealth: 90,
                baseDamage: 7,
                attackRange: 80,
                attackSpeed: 0.95,
                moveSpeed: 190,
                projectileSpeed: 0,
                animPrefix: '3',
                spriteScale: 0.50
            }
        ];

        // Player
        const player = {
            x: 0,
            y: 0,
            radius: 14,
            health: 100,
            maxHealth: 100,
            damage: 15,
            attackRange: 50,
            attackSpeed: 0.8,
            lastAttack: 0,
            moveSpeed: 3,
            projectileSpeed: 0,
            xp: 0,
            level: 1,
            xpToNext: 60,
            kills: 0,
            character: null,
            animState: 'idle',
            animStateTimer: 0,
            facingRight: true,
            upgrades: [],
            dead: false
        };


        // Advanced Sound System
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        const sounds = {
            playPunch: () => {
                try {
                    const osc = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain); osc2.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.1);
                    osc2.type = 'sine';
                    osc2.frequency.setValueAtTime(60, audioCtx.currentTime);
                    osc2.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.08);
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.12);
                    osc.start(); osc2.start();
                    osc.stop(audioCtx.currentTime + 0.12);
                    osc2.stop(audioCtx.currentTime + 0.12);
                } catch (e) { }
            },
            playArrow: () => {
                try {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    const filter = audioCtx.createBiquadFilter();
                    osc.connect(filter); filter.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(1200, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.2);
                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(2000, audioCtx.currentTime);
                    filter.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.2);
                    filter.Q.value = 3;
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.2);
                } catch (e) { }
            },
            playSwordSlash: () => {
                try {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    const filter = audioCtx.createBiquadFilter();
                    osc.connect(filter); filter.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.1);
                    filter.type = 'highpass';
                    filter.frequency.setValueAtTime(800, audioCtx.currentTime);
                    filter.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.1);
                    filter.Q.value = 5;
                    gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.1);
                } catch (e) { }
            },
            playOrbPickup: () => {
                try {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain); gain.connect(audioCtx.destination);
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(880, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(1320, audioCtx.currentTime + 0.15);
                    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.15);
                } catch (e) { }
            },
            playUltimate: () => {
                try {
                    const osc = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain); osc2.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.4);
                    osc2.type = 'sine';
                    osc2.frequency.setValueAtTime(300, audioCtx.currentTime);
                    osc2.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.4);
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                    osc.start(); osc2.start();
                    osc.stop(audioCtx.currentTime + 0.4);
                    osc2.stop(audioCtx.currentTime + 0.4);
                } catch (e) { }
            }
        };

        const bossFireballs = [];
        const ultimateEffects = [];

        // Input handling
        const keys = {};
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        // Tile tuning hotkeys (so you can quickly find good-looking indices)
        window.addEventListener('keydown', (e) => {
            // [ and ] cycle FLOOR_TILE
            if (e.code === 'BracketLeft') { FLOOR_TILE = Math.max(0, FLOOR_TILE - 1); FLOOR_VARIANTS = [FLOOR_TILE, FLOOR_TILE, FLOOR_TILE, FLOOR_TILE, FLOOR_TILE + 1, FLOOR_TILE + 2]; regenMap(); }
            if (e.code === 'BracketRight') { FLOOR_TILE = FLOOR_TILE + 1; FLOOR_VARIANTS = [FLOOR_TILE, FLOOR_TILE, FLOOR_TILE, FLOOR_TILE, FLOOR_TILE + 1, FLOOR_TILE + 2]; regenMap(); }
            // ; and ' cycle WALL_TILE
            if (e.code === 'Semicolon') { WALL_TILE = Math.max(0, WALL_TILE - 1); regenMap(); }
            if (e.code === 'Quote') { WALL_TILE = WALL_TILE + 1; regenMap(); }
            // R regenerates map noise
            if (e.code === 'KeyR') { regenMap(); }
        });

        // Mouse for mobile touch
        let mouseX = 0;
        let mouseY = 0;
        let touching = false;

        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('touchstart', (e) => {
            // Prevent page scrolling / pull-to-refresh while playing
            e.preventDefault();
            touching = true;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            touching = false;
        });

        // Virtual Joystick for Mobile
        const joystick = {
            active: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            deltaX: 0,
            deltaY: 0,
            maxDistance: 50
        };

        const joystickContainer = document.getElementById('joystickContainer');
        const joystickStick = document.getElementById('joystickStick');

        // Floating joystick (touch): appears where you touch, not locked to a corner
        if (joystickContainer && joystickStick) {
            const JOY_SIZE = 140;
            const JOY_RADIUS = JOY_SIZE / 2;

            function showJoystickAt(x, y) {
                joystickContainer.style.display = 'block';
                joystickContainer.style.left = (x - JOY_RADIUS) + 'px';
                joystickContainer.style.top = (y - JOY_RADIUS) + 'px';
                joystick.startX = x;
                joystick.startY = y;
                joystickStick.classList.add('active');
                joystickStick.style.left = '50%';
                joystickStick.style.top = '50%';
            }

            function hideJoystick() {
                joystick.active = false;
                joystick.deltaX = 0;
                joystick.deltaY = 0;
                joystick.currentX = 0;
                joystick.currentY = 0;
                joystickStick.classList.remove('active');
                joystickContainer.style.display = 'none';
                joystickStick.style.left = '50%';
                joystickStick.style.top = '50%';
            }

            function updateJoystickFromTouch(touch) {
                const dx = touch.clientX - joystick.startX;
                const dy = touch.clientY - joystick.startY;

                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                const limitedDistance = Math.min(distance, joystick.maxDistance);

                joystick.currentX = Math.cos(angle) * limitedDistance;
                joystick.currentY = Math.sin(angle) * limitedDistance;

                joystick.deltaX = joystick.currentX / joystick.maxDistance;
                joystick.deltaY = joystick.currentY / joystick.maxDistance;

                joystickStick.style.left = `calc(50% + ${joystick.currentX}px)`;
                joystickStick.style.top = `calc(50% + ${joystick.currentY}px)`;
            }

            // Use document-level listeners so the joystick can start anywhere (left half by default)
            document.addEventListener('touchstart', (e) => {
                if (gameState.screen !== 'playing') return;
                if (!e.touches || !e.touches.length) return;

                const t = e.touches[0];

                // Only allow joystick start on left half of the screen
                if (t.clientX > window.innerWidth * 0.6) return;

                // Ignore touches on UI buttons/panels
                const target = e.target;
                if (target && (target.closest && target.closest('button, .btn, .upgrade-card, .character-card, .shop-item, .options-panel'))) {
                    return;
                }

                e.preventDefault();
                joystick.active = true;
                touching = false;
                showJoystickAt(t.clientX, t.clientY);
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (gameState.screen !== 'playing') return;
                if (!joystick.active) return;
                if (!e.touches || !e.touches.length) return;

                e.preventDefault();
                updateJoystickFromTouch(e.touches[0]);
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (joystick.active) hideJoystick();
            }, { passive: true });

            document.addEventListener('touchcancel', (e) => {
                if (joystick.active) hideJoystick();
            }, { passive: true });
        }
        // Enemies
        const enemies = [];

        let enemyIdSeq = 1;
        const enemySpawnRate = 2.0; // seconds (slower initial pace)
        let lastEnemySpawn = 0;

        // Projectiles
        const projectiles = [];

        // Slash effects for melee attacks
        const slashEffects = [];

        // Explosion effects for explosive strikes
        // SFX on explosion spawn

        const explosionEffects = [];

        // XP Orbs
        const xpOrbs = [];

        // Game timer
        let gameTimer = 300; // 5 minutes in seconds
        let lastTimerUpdate = 0;
        let _lastHitSfx = 0; // throttle hit sfx
        let _lastDeathSfx = 0;

        // Upgrade system
        const upgradePool = [
            { name: 'Health Boost', description: '+20 Max Health', apply: (p) => { p.maxHealth += 20; p.health += 20; } },
            { name: 'Damage Up', description: '+5 Damage', apply: (p) => { p.damage += 5; } },
            {
                name: 'Attack Speed', description: '+20% Faster Attacks', apply: (p) => {
                    const oldSpeed = p.attackSpeed;
                    p.attackSpeed *= 0.8;
                    console.log('Attack Speed upgraded:', oldSpeed, '->', p.attackSpeed);
                }
            },
            {
                name: 'Move Speed', description: '+15% Movement Speed', apply: (p) => {
                    const oldSpeed = p.moveSpeed;
                    p.moveSpeed *= 1.15;
                    console.log('Move Speed upgraded:', oldSpeed, '->', p.moveSpeed);
                }
            },
            { name: 'Extended Range', description: '+30% Attack Range', apply: (p) => { p.attackRange *= 1.3; } },
            { name: 'Life Steal', description: 'Heal 2 HP per kill', apply: (p) => { p.upgrades.push('lifesteal'); } },
            { name: 'Double Shot', description: 'Fire 2 additional projectiles', apply: (p) => { p.upgrades.push('doubleshot'); } },
            { name: 'Piercing', description: 'Attacks pierce enemies', apply: (p) => { p.upgrades.push('pierce'); } },
            { name: 'Critical Strike', description: '20% chance for 2x damage', apply: (p) => { p.upgrades.push('crit'); } },
            { name: 'Regeneration', description: 'Heal 1 HP per second', apply: (p) => { p.upgrades.push('regen'); } },
            {
                name: 'Bone Boomerang',
                description: 'Orbiting bones deal damage',
                apply: (p) => {
                    if (!p.boomerangs) p.boomerangs = [];
                    p.boomerangs.push({
                        angle: Math.random() * Math.PI * 2,
                        distance: 60,
                        speed: 2,
                        damage: 8,
                        radius: 8
                    });
                }
            },
            { name: 'Vampiric Aura', description: 'Heal 5% max HP per kill', apply: (p) => { p.upgrades.push('vampire'); } },
            { name: 'Explosive Strikes', description: 'Attacks have 15% splash damage', apply: (p) => { p.upgrades.push('explosion'); } },
            { name: 'Ghost Shield', description: 'Absorb next 20 damage', apply: (p) => { p.shield = (p.shield || 0) + 20; } },
            { name: 'Rapid Fire', description: '+30% Attack Speed', apply: (p) => { p.attackSpeed *= 0.7; } },
            { name: 'Berserker', description: '+10 Damage, -10 Max HP', apply: (p) => { p.damage += 10; p.maxHealth -= 10; p.health = Math.min(p.health, p.maxHealth); p.berserker = true; p.upgrades.push('berserker'); } },
            { name: 'Multi-Strike', description: 'Fire 5 projectiles in spread', apply: (p) => { p.upgrades.push('multishot'); } },
            { name: 'Bloodlust', description: '+2% damage per kill', apply: (p) => { p.upgrades.push('bloodlust'); } },
            // NEW UPGRADES AND PASSIVES
            { name: 'Thorns', description: 'Reflect 25% damage to attackers', apply: (p) => { p.upgrades.push('thorns'); } },
            { name: 'Dodge Master', description: '15% chance to dodge attacks', apply: (p) => { p.upgrades.push('dodge'); } },
            { name: 'Burning Rage', description: 'Attacks burn enemies for 3s', apply: (p) => { p.upgrades.push('burn'); } },
            { name: 'Frost Touch', description: 'Slow enemies by 30% for 2s', apply: (p) => { p.upgrades.push('frost'); p.frostTouch = true; } },
            { name: 'Chain Lightning', description: 'Attacks jump to nearby foes', apply: (p) => { p.upgrades.push('chain'); } },
            { name: 'Fortified', description: '+15% Damage Reduction', apply: (p) => { p.damageReduction = (p.damageReduction || 0) + 0.15; } },
            { name: 'Lucky Strike', description: '+10% Critical Chance', apply: (p) => { p.critBonus = (p.critBonus || 0) + 0.1; } },
            { name: 'XP Magnet', description: '+50% XP pickup range', apply: (p) => { p.magnetRange = (p.magnetRange || 1) * 1.5; } },
            { name: 'Treasure Hunter', description: 'Enemies drop 30% more XP', apply: (p) => { p.xpBonus = (p.xpBonus || 1) * 1.3; } },
            { name: 'Iron Will', description: '+40 Max Health', apply: (p) => { p.maxHealth += 40; p.health += 40; } },
            { name: 'Fury', description: '+10 Damage', apply: (p) => { p.damage += 10; } },
            { name: 'Lightning Speed', description: '+25% Movement Speed', apply: (p) => { p.moveSpeed *= 1.25; p.lightningSpeedPermanent = true; p.lightningSpeedActive = true; } },
        ];

        // Menu functions
        function showCharacterSelect() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('characterSelect').style.display = 'block';
            updateCharacterCards();
        }

        // Toast notification system for warnings
        function showToastNotification(message, color = '#d4af37') {
            try {
                const toast = document.createElement('div');
                toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.95);
                border: 3px solid ${color};
                padding: 2rem 3rem;
                font-family: 'Bebas Neue', cursive;
                font-size: 2.5rem;
                color: ${color};
                text-shadow: 0 0 20px ${color};
                z-index: 9999;
                pointer-events: none;
                text-align: center;
                box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
                animation: toastPulse 0.5s ease-in-out;
            `;
                toast.textContent = message;
                document.body.appendChild(toast);

                setTimeout(() => {
                    toast.style.opacity = '0';
                    toast.style.transition = 'opacity 0.5s';
                    setTimeout(() => toast.remove(), 500);
                }, 2500);
            } catch (error) {
                console.error("Toast notification error:", error);
            }
        }

        function showShop() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('shop').style.display = 'block';
            document.getElementById('shopCurrency').textContent = gameState.currency;
            updateShopCards();
        }

        function showOptions() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('options').style.display = 'block';

            // Update options display
            document.getElementById('optionsCurrency').textContent = gameState.currency;

            const unlockedCount = gameState.unlockedCharacters.filter(u => u).length;
            document.getElementById('optionsCharacters').textContent = `${unlockedCount}/3`;

            const totalUpgrades = Object.values(gameState.permanentUpgrades).reduce((a, b) => a + b, 0);
            document.getElementById('optionsUpgrades').textContent = totalUpgrades;
        }

        function backToMenu() {
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('characterSelect').style.display = 'none';
            document.getElementById('shop').style.display = 'none';
            document.getElementById('options').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';

            clearDomSprites();
            gameState.lastFrame = 0;
            // Stop game if running
            if (gameState.screen === 'playing') {
                gameState.screen = 'menu';
                document.getElementById('hud').style.display = 'none';
                document.getElementById('statsPanel').style.display = 'none';
            }
        }

        function confirmResetGame() {
            const confirmed = confirm(
                "‚ö†Ô∏è FINAL WARNING ‚ö†Ô∏è\n\n" +
                "Are you absolutely sure you want to reset EVERYTHING?\n\n" +
                "This will delete:\n" +
                "‚Ä¢ All " + gameState.currency + " Bones\n" +
                "‚Ä¢ All unlocked characters\n" +
                "‚Ä¢ All permanent upgrades\n\n" +
                "This action CANNOT be undone!\n\n" +
                "Type 'RESET' in the next prompt to confirm."
            );

            if (confirmed) {
                const finalConfirm = prompt("Type 'RESET' in ALL CAPS to permanently delete all progress:");

                if (finalConfirm === 'JAM') {
                    gameState.currency = 99999999;
                    localStorage.setItem('barkCurrency', gameState.currency);
                    const sc = document.getElementById('shopCurrency');
                    if (sc) sc.textContent = gameState.currency;
                    const oc = document.getElementById('optionsCurrency');
                    if (oc) oc.textContent = gameState.currency;
                    // Toast
                    const t = document.createElement('div');
                    t.textContent = 'HAVE FUN';
                    t.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.85);color:#fff;padding:10px 16px;border-radius:10px;z-index:99999;font-weight:700;letter-spacing:.5px;';
                    document.body.appendChild(t);
                    setTimeout(() => t.remove(), 2000);
                    return;
                }

                if (finalConfirm === 'RESET') {
                    // Clear all localStorage
                    localStorage.removeItem('barkCurrency');
                    localStorage.removeItem('barkUnlocked');
                    localStorage.removeItem('barkPermanent');

                    // Reset gameState
                    gameState.currency = 0;
                    gameState.unlockedCharacters = [true, false, false];
                    gameState.permanentUpgrades = { health: 0, damage: 0, speed: 0, xp: 0 };

                    alert("‚úÖ Game has been reset to factory settings.\n\nAll progress has been deleted.");

                    // Return to main menu
                    backToMenu();

                    // Refresh the page to ensure clean state
                    location.reload();
                } else {
                    alert("Reset cancelled. You did not type 'RESET' correctly.");
                }
            }
        }

        function updateCharacterCards() {
            const archerCard = document.getElementById('archerCard');
            const swordCard = document.getElementById('swordCard');

            if (gameState.unlockedCharacters[1]) {
                archerCard.classList.remove('locked');
                archerCard.onclick = () => selectCharacter(1);
            }

            if (gameState.unlockedCharacters[2]) {
                swordCard.classList.remove('locked');
                swordCard.onclick = () => selectCharacter(2);
            }
        }

        function updateShopCards() {
            const shopArcherCard = document.getElementById('shopArcherCard');
            const shopSwordCard = document.getElementById('shopSwordCard');

            if (gameState.unlockedCharacters[1]) {
                shopArcherCard.classList.remove('locked');
                shopArcherCard.innerHTML = '<h3 class="char-name">Luna</h3><p class="char-type">OWNED</p>';
            }

            if (gameState.unlockedCharacters[2]) {
                shopSwordCard.classList.remove('locked');
                shopSwordCard.innerHTML = '<h3 class="char-name">Blade</h3><p class="char-type">OWNED</p>';
            }
        }

        function buyCharacter(index, cost) {
            if (gameState.unlockedCharacters[index]) {
                alert('You already own this character!');
                return;
            }

            if (gameState.currency >= cost) {
                gameState.currency -= cost;
                gameState.unlockedCharacters[index] = true;

                // Save to localStorage
                localStorage.setItem('barkCurrency', gameState.currency);
                localStorage.setItem('barkUnlocked', JSON.stringify(gameState.unlockedCharacters));

                document.getElementById('shopCurrency').textContent = gameState.currency;
                updateShopCards();
                updateCharacterCards();

                alert(`${characters[index].name} unlocked!`);
            } else {
                alert(`Not enough Bones! You need ${cost - gameState.currency} more.`);
            }
        }

        function buyPermanentUpgrade(type, baseCost) {
            const current = gameState.permanentUpgrades[type] || 0;
            const cost = baseCost + (current * Math.floor(baseCost * 0.5)); // Cost increases by 50% per level

            if (gameState.currency >= cost) {
                gameState.currency -= cost;
                gameState.permanentUpgrades[type] = current + 1;

                // Save to localStorage
                localStorage.setItem('barkCurrency', gameState.currency);
                localStorage.setItem('barkPermanent', JSON.stringify(gameState.permanentUpgrades));

                document.getElementById('shopCurrency').textContent = gameState.currency;

                // Update cost display
                const newCost = baseCost + (gameState.permanentUpgrades[type] * Math.floor(baseCost * 0.5));
                document.getElementById(`${type}UpgradeCost`).textContent = newCost;

                const upgradeNames = {
                    health: 'Health Boost',
                    damage: 'Power Surge',
                    speed: 'Swift Feet',
                    xp: 'Wisdom'
                };

                alert(`${upgradeNames[type]} upgraded to level ${gameState.permanentUpgrades[type]}!`);
            } else {
                alert(`Not enough Bones! You need ${cost - gameState.currency} more.`);
            }
        }

        function selectCharacter(index) {
            if (!gameState.unlockedCharacters[index]) {
                alert('This character is locked! Visit the shop to unlock.');
                return;
            }

            startGame(index);
        }

        function startGame(charIndex) {
            // Hide menus
            document.getElementById('characterSelect').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';

            document.getElementById('statsPanel').style.display = 'block';

            // Show mobile controls if on mobile device
            const mobileControls = document.getElementById('mobileControls');
            if (mobileControls && window.innerWidth <= 768) {
                mobileControls.style.display = 'block';
            }

            // Hard reset runtime state so restarts don't inherit previous run
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';
            clearDomSprites();
            gameState.lastFrame = 0;
            touching = false;
            mouseDown = false;
            // clear pressed keys (prevents 'stuck moving' after restart)
            for (const k in keys) { keys[k] = false; }

            // Initialize player
            const char = characters[charIndex];
            player.x = WORLD.w / 2;
            player.y = WORLD.h / 2;
            camera.x = player.x;
            camera.y = player.y;
            player.health = char.baseHealth;
            player.maxHealth = char.baseHealth;
            player.damage = char.baseDamage;
            player.attackRange = char.attackRange;
            player.attackSpeed = char.attackSpeed;
            player.moveSpeed = char.moveSpeed;
            player.projectileSpeed = char.projectileSpeed;
            player.xp = 0;
            player.level = 1;
            player.xpToNext = 30; // First level is very easy - only 3 kills needed!
            player.kills = 0;
            player.character = char;
            player.upgrades = [];
            player.boomerangs = [];
            player.shield = 0;
            player.armor = 0;
            player.thorns = 0;
            player.lastUltimate = performance.now();
            player.ultimateReady = false;
            player.lastAttack = 0;
            player.animState = 'idle';
            player.animStateTimer = 0;
            player.dead = false;

            // Apply permanent upgrades
            player.maxHealth += gameState.permanentUpgrades.health * 10;
            player.health = player.maxHealth;
            player.damage += gameState.permanentUpgrades.damage * 3;
            player.moveSpeed *= (1 + gameState.permanentUpgrades.speed * 0.05);

            // DYNAMIC DIFFICULTY SYSTEM
            // Calculate difficulty multiplier based on character power and shop upgrades
            let difficultyMultiplier = 1.0;

            // Character-based difficulty (ranged characters are easier, so increase difficulty)
            if (char.type === 'archer') {
                difficultyMultiplier += 0.25; // Luna is ranged and fast - increase difficulty
            } else if (char.type === 'swordsman') {
                difficultyMultiplier += 0.15; // Blade is balanced - slight increase
            }
            // Rex (brawler) keeps base difficulty as he's melee and tankier

            // Shop upgrade difficulty scaling
            const totalUpgrades = Object.values(gameState.permanentUpgrades).reduce((a, b) => a + b, 0);
            if (totalUpgrades > 0) {
                // Each shop upgrade increases difficulty by 3%
                difficultyMultiplier += totalUpgrades * 0.03;
            }

            // Store difficulty multiplier for use in enemy spawning
            player.difficultyMultiplier = difficultyMultiplier;

            // Clear arrays
            enemies.length = 0;
            projectiles.length = 0;
            xpOrbs.length = 0;

            // Reset timer
            gameTimer = 300;
            lastTimerUpdate = performance.now();
            lastEnemySpawn = performance.now();

            // Update HUD
            updateHUD();

            updateStatsPanel();

            // Start game loop
            gameState.screen = 'playing';
            gameLoop();
        }


        function updateStatsPanel() {
            if (!player) return;

            document.getElementById('statDamage').textContent = Math.floor(player.damage);
            document.getElementById('statAttackSpeed').textContent = player.attackSpeed.toFixed(2);
            document.getElementById('statMoveSpeed').textContent = player.moveSpeed.toFixed(2);
            document.getElementById('statCritChance').textContent = (player.critBonus ? Math.floor(player.critBonus * 100) : 0) + '%';
            document.getElementById('statMaxHP').textContent = player.maxHealth;
            document.getElementById('statDefense').textContent = (player.damageReduction ? Math.floor(player.damageReduction * 100) : 0) + '%';
            document.getElementById('statXPMult').textContent = (player.xpBonus || 1).toFixed(2) + 'x';
            document.getElementById('statDodge').textContent = (player.upgrades.includes('dodge') ? '15' : '0') + '%';
        }

        function updateHUD() {
            // Health (clamp to 0 minimum to prevent negative display)
            const healthPercent = Math.max(0, (player.health / player.maxHealth) * 100);
            document.getElementById('healthFill').style.width = healthPercent + '%';
            document.getElementById('healthText').textContent = Math.max(0, Math.ceil(player.health)) + '/' + player.maxHealth;

            // Timer
            const minutes = Math.floor(gameTimer / 60);
            const seconds = Math.floor(gameTimer % 60);
            document.getElementById('timerValue').textContent = minutes + ':' + (seconds < 10 ? '0' : '') + seconds;

            // Level
            document.getElementById('levelValue').textContent = player.level;

            // Kills
            document.getElementById('killsValue').textContent = player.kills;

            // XP
            const xpPercent = (player.xp / player.xpToNext) * 100;
            document.getElementById('xpFill').style.width = xpPercent + '%';
        }

        function spawnEnemy() {
            // Spawn in a ring around the player (open-world + camera follow)
            const spawnDist = Math.max(canvas.width, canvas.height) * 0.38 + 60;
            const ang = Math.random() * Math.PI * 2;
            let x = player.x + Math.cos(ang) * spawnDist;
            let y = player.y + Math.sin(ang) * spawnDist;

            // Clamp to world bounds
            x = clamp(x, 40, WORLD.w - 40);
            y = clamp(y, 40, WORLD.h - 40);

            // PROGRESSIVE DIFFICULTY SCALING
            // Combined difficulty ramp: time-based + player power-based
            const minutesSurvived = (300 - gameTimer) / 60;

            // Boss spawning - only after 1 minute of survival
            const canSpawnBoss = minutesSurvived >= 1.0; // Bosses only spawn after 1 minute
            const isBoss = canSpawnBoss && Math.random() < 0.04; // 4% chance for boss (only after 1 min)

            // Time-based scaling: more aggressive as game progresses
            // 0 min = 1.0x, 1 min = 1.3x, 3 min = 2.0x, 5 min = 3.0x+
            const timeRamp = 1 + Math.min(2.5, minutesSurvived * 0.4); // up to ~3.5x over 5 minutes

            // Apply player difficulty multiplier (based on character + shop upgrades)
            const difficultyRamp = timeRamp * (player.difficultyMultiplier || 1.0);

            // Additional health scaling as survival time increases (enemies get tankier)
            const survivalBonus = 1 + (minutesSurvived * 0.15); // +15% health per minute
            const finalHealthMultiplier = difficultyRamp * survivalBonus;

            // ENHANCED ENEMY BEHAVIORS - assign behavior type
            let behavior = 'chase'; // default
            const rand = Math.random();
            if (!isBoss) {
                if (rand < 0.15) behavior = 'zigzag'; // 15% zigzag
                else if (rand < 0.28) behavior = 'circler'; // 13% circler
                else if (rand < 0.38) behavior = 'rusher'; // 10% rusher
                else if (rand < 0.45) behavior = 'retreater'; // 7% retreater (hit and run)
            }

            enemies.push({
                x,
                y,
                id: 'e' + (enemyIdSeq++),
                spriteScale: isBoss ? 0.95 : 0.7,
                hurtTimer: 0,
                dead: false,
                deadTimer: 0,
                radius: isBoss ? 36 : 26,
                health: (isBoss ? 70 : 16) * finalHealthMultiplier,
                maxHealth: (isBoss ? 70 : 16) * finalHealthMultiplier,
                damage: (isBoss ? 10 : 3) * difficultyRamp,
                speed: (isBoss ? 82 : 112) * (0.9 + Math.random() * 0.25) * Math.min(1.3, 1 + (player.difficultyMultiplier - 1) * 0.5), // Speed increases slightly with difficulty
                isBoss,
                behavior, // NEW: behavior type
                behaviorTimer: 0, // NEW: for behavior timing
                circleAngle: Math.random() * Math.PI * 2, // NEW: for circler
                zigzagPhase: 0, // NEW: for zigzag
                facingRight: true, // Will be updated based on movement
                // IMPORTANT: used by render (missing this makes floatY NaN -> ghost not drawn)
                floatSpeed: (isBoss ? 1.35 : 1.7) + Math.random() * 0.9,
                floatOffset: Math.random() * Math.PI * 2,
                wobbleSeed: Math.random() * 9999,
                dashCooldown: isBoss ? 5000 : 0,
                lastDash: 0,
                isDashing: false,
                dashSpeed: 300,
                dashDuration: 0.5,
                dashTimer: 0,
                dashDirX: 0,
                dashDirY: 0,
                fireballCooldown: isBoss ? 3000 : 0,
                lastFireball: 0
            });
        }

        function spawnXPOrb(x, y, value) {
            xpOrbs.push({
                x: x,
                y: y,
                radius: 8,
                value: value,
                lifetime: 10000, // 10 seconds
                spawnTime: Date.now()
            });
        }



        function updateActiveUpgrades() {
            const upgradeList = document.getElementById('upgradeList');
            const activeDiv = document.getElementById('activeUpgrades');

            if (!upgradeList || !activeDiv) return;

            const activeUpgrades = [];
            const upgradeNames = {
                'lifesteal': 'Life Steal', 'doubleshot': 'Double Shot', 'multishot': 'Multi-Strike',
                'pierce': 'Piercing', 'crit': 'Critical', 'regen': 'Regeneration',
                'vampire': 'Vampiric', 'explosion': 'Explosive', 'bloodlust': 'Bloodlust',
                'magnet': 'XP Magnet', 'lucky': 'Lucky', 'knockback': 'Knockback', 'frenzy': 'Frenzy'
            };

            player.upgrades.forEach(upgrade => {
                if (upgradeNames[upgrade]) activeUpgrades.push(upgradeNames[upgrade]);
            });

            if (player.boomerangs && player.boomerangs.length > 0) {
                activeUpgrades.push(`Boomerangs x${player.boomerangs.length}`);
            }

            if (player.shield > 0) {
                activeUpgrades.push(`Shield: ${Math.floor(player.shield)}`);
            }

            if (activeUpgrades.length > 0) {
                activeDiv.style.display = 'block';
                upgradeList.innerHTML = activeUpgrades.map(u => `‚Ä¢ ${u}`).join('<br>');
            } else {
                activeDiv.style.display = 'none';
            }
        }

        function levelUp() {

            try { playSfx('levelup'); } catch (e) { }
            gameState.screen = 'levelup';
            document.getElementById('levelUpScreen').style.display = 'flex';

            // Generate 3 random upgrades
            const shuffled = [...upgradePool].sort(() => Math.random() - 0.5);
            const options = shuffled.slice(0, 3);

            const grid = document.getElementById('upgradesGrid');
            grid.innerHTML = '';

            options.forEach((upgrade, index) => {
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                card.innerHTML = `
                    <div class="upgrade-name">${upgrade.name}</div>
                    <div class="upgrade-description">${upgrade.description}</div>
                `;
                card.onclick = () => selectUpgrade(upgrade);
                grid.appendChild(card);
            });
        }


        function showUpgradeAnimation(upgradeName, player) {
            if (!player) return;

            const colors = {
                shield: '#00ffff',
                bloodlust: '#ff0000',
                fortified: '#ffa500',
                xpMagnet: '#1e90ff',
                treasureHunter: '#ffd700',
                luckyStrike: '#ffff00',
                ironWill: '#ffffff',
                fury: '#ff00ff',
                lightningSpeed: '#ffff00',
                berserker: '#8B0000',
                frostTouch: '#00ffff',
                // New upgrade colors
                damage: '#ff4444',
                attackSpeed: '#ff8800',
                moveSpeed: '#44ff44',
                health: '#00ff00',
                vampire: '#cc0066',
                explosion: '#ff6600',
                rapidFire: '#ffaa00',
                multiStrike: '#aa00ff',
                thorns: '#996633',
                dodge: '#66ccff',
                burn: '#ff3300',
                chain: '#ccff00',
                generic: '#d4af37'
            };

            const names = {
                shield: 'GHOST SHIELD',
                bloodlust: 'BLOODLUST',
                fortified: 'FORTIFIED',
                xpMagnet: 'XP MAGNET',
                treasureHunter: 'TREASURE HUNTER',
                luckyStrike: 'LUCKY STRIKE',
                ironWill: 'IRON WILL',
                fury: 'FURY',
                lightningSpeed: 'LIGHTNING SPEED',
                berserker: 'BERSERKER',
                frostTouch: 'FROST TOUCH',
                // New upgrade display names
                damage: 'DAMAGE BOOST',
                attackSpeed: 'ATTACK SPEED',
                moveSpeed: 'MOVE SPEED',
                health: 'MAX HEALTH',
                vampire: 'VAMPIRIC AURA',
                explosion: 'EXPLOSIVE STRIKES',
                rapidFire: 'RAPID FIRE',
                multiStrike: 'MULTI-STRIKE',
                thorns: 'THORNS',
                dodge: 'DODGE MASTER',
                burn: 'BURNING RAGE',
                chain: 'CHAIN LIGHTNING',
                generic: 'UPGRADE'
            };

            const color = colors[upgradeName] || '#ffffff';
            const displayName = names[upgradeName] || upgradeName.toUpperCase();

            // Create on-screen flash effect
            const flash = document.createElement('div');
            flash.className = 'upgrade-flash';
            flash.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                font-size: 3rem;
                font-family: 'Bebas Neue', cursive;
                color: ${color};
                text-shadow: 0 0 20px ${color}, 0 0 40px ${color};
                pointer-events: none;
                z-index: 9999;
                animation: upgradeActivate 1s ease-out forwards;
            `;
            flash.textContent = `‚ö° ${displayName} ‚ö°`;
            document.body.appendChild(flash);

            setTimeout(() => {
                flash.remove();
            }, 1000);

            // Create particle burst at player position
            if (!gameState || !gameState.particles) return;

            const particleCount = 20;
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const speed = 3 + Math.random() * 2;
                const size = 3 + Math.random() * 3;

                gameState.particles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 30 + Math.random() * 20,
                    maxLife: 30,
                    color: color,
                    size: size
                });
            }

            // Add pulsing ring
            let ringScale = 0;
            const ringInterval = setInterval(() => {
                ringScale += 0.15;

                if (gameState && gameState.particles && player) {
                    const ringSize = (player.size || 20) * (1 + ringScale * 2);
                    const segments = 16;

                    for (let i = 0; i < segments; i++) {
                        const angle = (Math.PI * 2 * i) / segments;
                        const px = player.x + Math.cos(angle) * ringSize;
                        const py = player.y + Math.sin(angle) * ringSize;

                        gameState.particles.push({
                            x: px,
                            y: py,
                            vx: Math.cos(angle) * 0.5,
                            vy: Math.sin(angle) * 0.5,
                            life: 15,
                            maxLife: 15,
                            color: color,
                            size: 3
                        });
                    }
                }

                if (ringScale >= 1.5) {
                    clearInterval(ringInterval);
                }
            }, 50);
        }

        function selectUpgrade(upgrade) {
            upgrade.apply(player);

            // Show upgrade animation based on upgrade type
            const upgradeName = upgrade.name || '';
            const animationUpgrades = {
                'Ghost Shield': 'shield',
                'Bloodlust': 'bloodlust',
                'Fortified': 'fortified',
                'XP Magnet': 'xpMagnet',
                'Treasure Hunter': 'treasureHunter',
                'Lucky Strike': 'luckyStrike',
                'Iron Will': 'ironWill',
                'Fury': 'fury',
                'Lightning Speed': 'lightningSpeed',
                'Berserker': 'berserker',
                'Frost Touch': 'frostTouch',
                // Add animations for other common upgrades
                'Damage Boost': 'damage',
                'Attack Speed': 'attackSpeed',
                'Move Speed': 'moveSpeed',
                'Max Health': 'health',
                'Vampiric Aura': 'vampire',
                'Explosive Strikes': 'explosion',
                'Rapid Fire': 'rapidFire',
                'Multi-Strike': 'multiStrike',
                'Thorns': 'thorns',
                'Dodge Master': 'dodge',
                'Burning Rage': 'burn',
                'Chain Lightning': 'chain'
            };

            if (animationUpgrades[upgradeName]) {
                showUpgradeAnimation(animationUpgrades[upgradeName], player);
            } else {
                // Show generic animation for upgrades without specific mapping
                showUpgradeAnimation('generic', player);
            }
            document.getElementById('levelUpScreen').style.display = 'none';
            gameState.screen = 'playing';
            updateHUD();

            // Resume game loop (only if not already running)
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            if (!gameState.loopRunning) {
                gameState.loopRunning = true;
                requestAnimationFrame(gameLoop);
            }
        }

        function attack() {
            const now = performance.now() / 1000;

            // Find nearest enemy
            let nearest = null;
            let minDist = Infinity;

            for (let i = 0; i < enemies.length; i++) {
                const e = enemies[i];
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const d = Math.sqrt(dx * dx + dy * dy);
                if (d < minDist) { minDist = d; nearest = e; }
            }

            // No enemies or none in range -> don't attack, don't trigger attack animation
            if (!nearest || minDist > player.attackRange) return;

            // Cooldown (only consumes when we actually have a target in range)
            if (now - player.lastAttack < player.attackSpeed) return;
            player.lastAttack = now;

            // Face target
            player.facingRight = (nearest.x - player.x) >= 0;

            // Play attack animation
            if (player.animState !== 'hurt' && player.animState !== 'dead') {
                player.animState = 'attack';
                player.animStateTimer = 0.5;
            }

            // Ranged vs melee
            if (player.projectileSpeed > 0) {
                const baseAngle = Math.atan2(nearest.y - player.y, nearest.x - player.x);

                const shootProjectile = (angleOffset = 0) => {
                    try { if (player.weapon === 'bone_boomerang') playSfx('boomerang'); } catch (e) { }
                    projectiles.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(baseAngle + angleOffset) * player.projectileSpeed,
                        vy: Math.sin(baseAngle + angleOffset) * player.projectileSpeed,
                        radius: 5,
                        damage: player.damage,
                        range: player.attackRange,
                        traveled: 0,
                        pierce: player.upgrades.includes('pierce')
                    });
                };

                shootProjectile();
                try {
                    if (player.name === 'Luna') playSfx('arrow');
                    else playSfx('shoot');
                } catch (e) { }

                // Double Shot + Multi-Strike stacking (works for ALL ranged characters)
                const dsLevel = player.upgrades.filter(u => u === 'doubleshot').length;
                const msLevel = player.upgrades.filter(u => u === 'multishot').length;

                // Strike count rules:
                // - Double Shot alone => 2
                // - Multi-Strike first time => 3
                // - Each additional Multi-Strike => +1
                // - If Double Shot exists and Multi-Strike chosen => +1 strike (e.g. 4)
                let strikes = 1;
                if (msLevel > 0) {
                    strikes = 3 + (msLevel - 1) + (dsLevel > 0 ? 1 : 0);
                } else if (dsLevel > 0) {
                    strikes = 2;
                }

                // Direction rules:
                // - Double Shot: same direction (fires twice with delay)
                // - Multi-Strike: spreads in multiple directions
                if (strikes > 1) {
                    const spread = 0.25;
                    const offsets = [];
                    if (msLevel > 0) {
                        // Multi-Strike: fire in 8 directions for true multi-directional
                        const directions = 8;
                        for (let i = 0; i < directions; i++) {
                            const angle = (Math.PI * 2 / directions) * i;
                            shootProjectile(angle - Math.atan2(nearest.y - player.y, nearest.x - player.x));
                        }
                    } else {
                        // Double Shot only - fire with delay
                        offsets.push(0);
                        while (offsets.length < strikes) offsets.push(0);
                        for (let i = 0; i < offsets.length; i++) {
                            if (i === 0) {
                                shootProjectile(offsets[i]);
                            } else {
                                // Delay subsequent shots by 150ms each
                                setTimeout(() => {
                                    shootProjectile(offsets[i]);
                                    try {
                                        if (player.name === 'Luna') playSfx('arrow');
                                        else playSfx('shoot');
                                    } catch (e) { }
                                }, i * 150);
                            }
                        }
                    }
                }
            } else {
                // Melee strikes (already confirmed in range)
                const dsLevel = player.upgrades.filter(u => u === 'doubleshot').length;
                const msLevel = player.upgrades.filter(u => u === 'multishot').length;

                let strikes = 1;
                if (msLevel > 0) {
                    strikes = 3 + (msLevel - 1) + (dsLevel > 0 ? 1 : 0);
                } else if (dsLevel > 0) {
                    strikes = 2;
                }

                if (msLevel > 0) {
                    // Multi-Strike for melee: attack in 8 directions
                    const directions = 8;
                    for (let dir = 0; dir < directions; dir++) {
                        const angle = (Math.PI * 2 / directions) * dir;
                        const targetX = player.x + Math.cos(angle) * player.attackRange;
                        const targetY = player.y + Math.sin(angle) * player.attackRange;

                        // Find enemy in this direction
                        let target = null;
                        let bestDist = Infinity;
                        for (const e of enemies) {
                            if (!e || e.dead) continue;
                            const ex = e.x - player.x;
                            const ey = e.y - player.y;
                            const d = Math.hypot(ex, ey);
                            if (d > player.attackRange + e.radius) continue;
                            const a = Math.atan2(ey, ex);
                            let da = Math.abs(a - angle);
                            da = Math.min(da, Math.PI * 2 - da);
                            if (da < 0.6 && d < bestDist) {
                                bestDist = d;
                                target = e;
                            }
                        }

                        if (target) {
                            let damage = player.damage;
                            if (player.upgrades.includes('crit') && Math.random() < 0.2) {
                                damage *= 2;
                                try { playSfx('crit'); } catch (e) { }
                            }
                            target.health -= damage;
                            if (target.health <= 0) {
                                markEnemyDead(target);
                            }

                            // Create slash effect
                            slashEffects.push({
                                x: player.x,
                                y: player.y,
                                angle: angle,
                                range: player.attackRange,
                                lifetime: 0.3,
                                age: 0
                            });
                        }
                    }

                    // Play sound once for multi-strike
                    try {
                        if (player.name === 'Blade') playSfx('sword');
                        else if (player.name === 'Rex') playSfx('punch');
                        else playSfx('slash');
                    } catch (e) { }
                } else {
                    // Double-shot or single strike
                    const baseAngle = Math.atan2(nearest.y - player.y, nearest.x - player.x);

                    const performStrike = (strikeIndex) => {
                        const target = nearest;
                        if (!target || target.dead) return;

                        let damage = player.damage;
                        if (player.upgrades.includes('crit') && Math.random() < 0.2) {
                            damage *= 2;
                            try { playSfx('crit'); } catch (e) { }
                        }

                        target.health -= damage;
                        if (target.health <= 0) {
                            markEnemyDead(target);
                        }

                        // Play strike sound
                        try {
                            if (player.name === 'Blade') playSfx('sword');
                            else if (player.name === 'Rex') playSfx('punch');
                            else playSfx('slash');
                        } catch (e) { }

                        // Create slash effect
                        slashEffects.push({
                            x: player.x,
                            y: player.y,
                            angle: baseAngle,
                            range: player.attackRange,
                            lifetime: 0.3,
                            age: 0
                        });
                    };

                    // First strike immediate
                    performStrike(0);

                    // Additional strikes with delay (double-shot)
                    for (let s = 1; s < strikes; s++) {
                        setTimeout(() => performStrike(s), s * 150);
                    }
                }

                // Explosive strikes for melee (optimized to reduce lag)
                if (player.upgrades.includes('explosion') && Math.random() < 0.15) {
                    try { playSfx('explosion'); } catch (e) { }
                    explosionEffects.push({
                        x: nearest.x,
                        y: nearest.y,
                        radius: 0,
                        maxRadius: 60,
                        lifetime: 0.4,
                        age: 0
                    });

                    // Splash damage to nearby enemies (optimized - only check enemies within range)
                    const explosionRadius = 60;
                    let hitCount = 0;
                    const maxHits = 15; // Limit splash hits to prevent lag

                    for (let i = 0; i < enemies.length && hitCount < maxHits; i++) {
                        const nearbyEnemy = enemies[i];
                        if (nearbyEnemy === nearest || nearbyEnemy.dead) continue;

                        // Quick distance check first (cheaper than full calculation)
                        const dx2 = nearbyEnemy.x - nearest.x;
                        const dy2 = nearbyEnemy.y - nearest.y;

                        // Skip if obviously too far
                        if (Math.abs(dx2) > explosionRadius || Math.abs(dy2) > explosionRadius) continue;

                        const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

                        if (dist2 < explosionRadius) {
                            nearbyEnemy.health -= player.damage * 0.5;
                            nearbyEnemy.hurtTimer = 0.18;
                            if (nearbyEnemy.health <= 0) {
                                markEnemyDead(nearbyEnemy);
                            }
                            hitCount++;
                        }
                    }
                }
            }
        }


        function markEnemyDead(enemy) {
            if (!enemy || enemy.dead) return;
            enemy.dead = true;
            enemy.deadTimer = enemy.isBoss ? 0.95 : 0.65;
            enemy.hurtTimer = 0;
            // rewards & XP
            handleEnemyDeath(enemy);
        }

        function castUltimate() {
            if (!player.character) return;

            sounds.playUltimate();
            player.lastUltimate = performance.now();
            player.ultimateReady = false;

            const type = player.character.type;

            if (type === 'brawler') {
                // Rex ultimate - Shockwave
                ultimateEffects.push({
                    type: 'shockwave',
                    x: player.x,
                    y: player.y,
                    radius: 0,
                    maxRadius: 300,
                    lifetime: 1.5,
                    age: 0
                });

                enemies.forEach(enemy => {
                    const dx = enemy.x - player.x;
                    const dy = enemy.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 300) {
                        enemy.health -= 50;
                        if (enemy.health <= 0) markEnemyDead(enemy);
                    }
                });
            }

            if (type === 'archer') {
                // Luna ultimate - Arrow Storm
                let volleyCount = 0;
                const volleyInterval = setInterval(() => {
                    if (volleyCount >= 3 || player.dead) {
                        clearInterval(volleyInterval);
                        return;
                    }

                    sounds.playArrow();
                    for (let i = 0; i < 12; i++) {
                        const angle = (Math.PI * 2 * i) / 12;
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(angle) * 400,
                            vy: Math.sin(angle) * 400,
                            radius: 8,
                            damage: player.damage * 1.5,
                            range: 500,
                            traveled: 0,
                            pierce: true
                        });
                    }
                    volleyCount++;
                }, 300);
            }

            if (type === 'swordsman') {
                // Blade ultimate - Whirlwind Slash
                ultimateEffects.push({
                    type: 'tornado',
                    x: player.x,
                    y: player.y,
                    radius: 80,
                    lifetime: 2,
                    age: 0,
                    rotation: 0
                });
            }
        }

        function handleEnemyDeath(enemy) {
            player.kills++;

            // Life steal
            if (player.upgrades.includes('lifesteal')) {
                player.health = Math.min(player.maxHealth, player.health + 2);
            }

            // Vampiric Aura
            if (player.upgrades.includes('vampire')) {
                // Heal a small % of max HP per kill (subtle sustain)
                player.health = Math.min(player.maxHealth, player.health + player.maxHealth * 0.02);
                try { playSfx('vampire'); } catch (e) { }
            }

            // Bloodlust - increase damage per kill
            if (player.upgrades.includes('bloodlust')) {
                player.damage *= 1.02;
            }

            // Spawn XP - Event bosses give HUGE XP rewards!
            let xpValue = 10; // Normal enemy
            if (enemy.isEventBoss) {
                // Event bosses give massive XP based on their event number
                xpValue = 100 + (enemy.eventNumber * 50); // 150, 200, 250, 300 XP
                showToastNotification(`üíÄ EVENT BOSS DEFEATED! +${xpValue} XP! üíÄ`, '#d4af37');
            } else if (enemy.isBoss) {
                xpValue = 50; // Regular boss
            }
            spawnXPOrb(enemy.x, enemy.y, xpValue);

            updateHUD();
        }

        // SPECIAL BOSS EVENT SYSTEM
        function triggerBossEvent(minuteRemaining) {
            try {
                const now = performance.now();

                // Spawn a special boss enemy for each event
                const minutesSurvived = (300 - gameTimer) / 60;
                const difficultyRamp = (1 + Math.min(2.5, minutesSurvived * 0.4)) * (player.difficultyMultiplier || 1.0);

                switch (minuteRemaining) {
                    case 4:
                        // 4 minutes left - First Boss
                        showToastNotification('‚ö†Ô∏è BOSS EVENT: SHADOW BEAST! ‚ö†Ô∏è', '#ff0000');
                        try { playSfx('warn'); } catch (e) { }
                        setTimeout(() => {
                            spawnEventBoss(4, difficultyRamp);
                            // Simple boss, no special pattern
                        }, 2000);
                        break;

                    case 3:
                        // 3 minutes left - Cross Boss
                        showToastNotification('‚ö†Ô∏è BOSS EVENT: CROSSFIRE DEMON! ‚ö†Ô∏è', '#ff0000');
                        try { playSfx('warn'); } catch (e) { }
                        setTimeout(() => {
                            spawnEventBoss(3, difficultyRamp);
                            spawnCrossFireballs();
                        }, 2000);
                        break;

                    case 2:
                        // 2 minutes left - Wave Boss
                        showToastNotification('‚ö†Ô∏è BOSS EVENT: TSUNAMI DEMON! ‚ö†Ô∏è', '#ff0000');
                        try { playSfx('warn'); } catch (e) { }
                        setTimeout(() => {
                            spawnEventBoss(2, difficultyRamp);
                            spawnWaveFireballs();
                        }, 2000);
                        break;

                    case 1:
                        // 1 minute left - FINAL BOSS (SPIRAL DEMON)
                        showToastNotification('üî• FINAL BOSS: SPIRAL DEMON! üî•', '#ff0000');
                        try { playSfx('warn'); } catch (e) { }
                        setTimeout(() => {
                            spawnEventBoss(1, difficultyRamp);
                            spawnSpiralFireballs();
                        }, 2000);
                        break;
                }
            } catch (error) {
                console.error("Boss event error:", error);
            }
        }

        // Spawn special event boss enemy
        function spawnEventBoss(eventNumber, difficultyRamp) {
            if (!player || !enemies) {
                console.error("Cannot spawn boss: player or enemies undefined");
                return;
            }

            try {
                // Spawn near player but not too close
                const spawnDist = 350;
                const ang = Math.random() * Math.PI * 2;
                let x = player.x + Math.cos(ang) * spawnDist;
                let y = player.y + Math.sin(ang) * spawnDist;

                // Clamp to world bounds
                x = clamp(x, 40, WORLD.w - 40);
                y = clamp(y, 40, WORLD.h - 40);

                // Boss stats scale with event number (later bosses are stronger)
                const baseHealth = 500 + (eventNumber * 200); // 700, 900, 1100, 1300 (much tankier)
                const baseDamage = 15 + (eventNumber * 5); // 20, 25, 30, 35 (more dangerous)
                const bossSpeed = 70 + (eventNumber * 10); // 80, 90, 100, 110

                // Scale health with player level to keep bosses challenging
                const levelScaling = 1 + (player.level * 0.15); // +15% health per player level
                const finalHealth = baseHealth * difficultyRamp * levelScaling;

                enemies.push({
                    x,
                    y,
                    id: 'boss' + eventNumber + '_' + (enemyIdSeq++),
                    spriteScale: 1.2, // Larger than normal bosses
                    hurtTimer: 0,
                    dead: false,
                    deadTimer: 0,
                    radius: 45, // Bigger radius
                    health: finalHealth,
                    maxHealth: finalHealth,
                    damage: baseDamage * difficultyRamp,
                    speed: bossSpeed,
                    isBoss: true,
                    isEventBoss: true, // Mark as special event boss
                    eventNumber: eventNumber,
                    behavior: 'chase',
                    behaviorTimer: 0,
                    circleAngle: Math.random() * Math.PI * 2,
                    zigzagPhase: 0,
                    facingRight: true,
                    floatSpeed: 1.2 + Math.random() * 0.5,
                    floatOffset: Math.random() * Math.PI * 2,
                    wobbleSeed: Math.random() * 9999,
                    dashCooldown: 4000,
                    lastDash: 0,
                    isDashing: false,
                    dashSpeed: 350,
                    dashDuration: 0.6,
                    dashTimer: 0,
                    dashDirX: 0,
                    dashDirY: 0,
                    fireballCooldown: 2000, // Faster fireball attacks
                    lastFireball: 0
                });
            } catch (error) {
                console.error("Spawn boss error:", error);
            }
        }

        // Boss Event 1: Spiral Fireballs (4 min remaining)
        function spawnSpiralFireballs() {
            let angle = 0;
            const spiralCount = 40;
            const spiralInterval = setInterval(() => {
                if (gameState.screen !== 'playing') {
                    clearInterval(spiralInterval);
                    return;
                }

                if (gameState.screen !== 'playing' || spiralCount <= 0) {
                    clearInterval(spiralInterval);
                    return;
                }

                for (let i = 0; i < 3; i++) {
                    const offsetAngle = angle + (Math.PI * 2 / 3) * i;
                    const distance = 400;
                    const x = player.x + Math.cos(offsetAngle) * distance;
                    const y = player.y + Math.sin(offsetAngle) * distance;

                    bossFireballs.push({
                        x: x,
                        y: y,
                        vx: -Math.cos(offsetAngle) * 150,
                        vy: -Math.sin(offsetAngle) * 150,
                        radius: 15,
                        damage: 15,
                        lifetime: 5
                    });
                }

                angle += 0.3;
            }, 200);
        }

        // Boss Event 2: Cross Fireballs (3 min remaining)
        function spawnCrossFireballs() {
            let waveCount = 0;
            const maxWaves = 5;
            const crossInterval = setInterval(() => {
                if (gameState.screen !== 'playing' || waveCount >= maxWaves) {
                    clearInterval(crossInterval);
                    return;
                }

                // Horizontal line
                for (let i = -3; i <= 3; i++) {
                    bossFireballs.push({
                        x: player.x + i * 80,
                        y: player.y - 400,
                        vx: 0,
                        vy: 180,
                        radius: 15,
                        damage: 15,
                        lifetime: 5
                    });
                }

                // Vertical line
                for (let i = -3; i <= 3; i++) {
                    bossFireballs.push({
                        x: player.x - 400,
                        y: player.y + i * 80,
                        vx: 180,
                        vy: 0,
                        radius: 15,
                        damage: 15,
                        lifetime: 5
                    });
                }

                waveCount++;
            }, 800);
        }

        // Boss Event 3: Wave Fireballs (2 min remaining)
        function spawnWaveFireballs() {
            let waveCount = 0;
            const maxWaves = 8;
            const waveInterval = setInterval(() => {
                if (gameState.screen !== 'playing' || waveCount >= maxWaves) {
                    clearInterval(waveInterval);
                    return;
                }

                const side = waveCount % 4; // 0=top, 1=right, 2=bottom, 3=left

                for (let i = 0; i < 8; i++) {
                    let x, y, vx, vy;

                    if (side === 0) { // Top
                        x = player.x - 300 + i * 75;
                        y = player.y - 400;
                        vx = 0;
                        vy = 160;
                    } else if (side === 1) { // Right
                        x = player.x + 400;
                        y = player.y - 300 + i * 75;
                        vx = -160;
                        vy = 0;
                    } else if (side === 2) { // Bottom
                        x = player.x - 300 + i * 75;
                        y = player.y + 400;
                        vx = 0;
                        vy = -160;
                    } else { // Left
                        x = player.x - 400;
                        y = player.y - 300 + i * 75;
                        vx = 160;
                        vy = 0;
                    }

                    bossFireballs.push({
                        x: x,
                        y: y,
                        vx: vx,
                        vy: vy,
                        radius: 15,
                        damage: 15,
                        lifetime: 5
                    });
                }

                waveCount++;
            }, 600);
        }

        // Boss Event 4: Circle of Doom (1 min remaining) - Player trapped in middle
        function spawnCircleOfDoom() {
            showToastNotification('üî• DODGE THE INCOMING FIREBALLS! üî•', '#ff6600');

            let phase = 0;
            const maxPhases = 15;
            const doomInterval = setInterval(() => {
                if (gameState.screen !== 'playing' || phase >= maxPhases) {
                    clearInterval(doomInterval);
                    return;
                }

                // Spawn fireballs in a circle around player
                const numFireballs = 16;
                const radius = 450;

                for (let i = 0; i < numFireballs; i++) {
                    const angle = (Math.PI * 2 / numFireballs) * i + (phase * 0.3);
                    const x = player.x + Math.cos(angle) * radius;
                    const y = player.y + Math.sin(angle) * radius;

                    // Fire towards player with slight randomness
                    const targetAngle = Math.atan2(player.y - y, player.x - x);
                    const randomOffset = (Math.random() - 0.5) * 0.3;

                    bossFireballs.push({
                        x: x,
                        y: y,
                        vx: Math.cos(targetAngle + randomOffset) * 140,
                        vy: Math.sin(targetAngle + randomOffset) * 140,
                        radius: 18,
                        damage: 20,
                        lifetime: 5
                    });
                }

                try { playSfx('fireball'); } catch (e) { }
                phase++;
            }, 500);
        }

        function gameLoop() {
            if (!gameState || gameState.screen !== 'playing') {
                requestAnimationFrame(gameLoop);
                return;
            }

            const now = performance.now();
            if (!gameState.lastFrame) gameState.lastFrame = now;

            // FPS cap to prevent speedup (target 60 FPS = 16.67ms per frame)
            const frameDelay = now - gameState.lastFrame;
            if (frameDelay < 16) {
                // Too soon, skip this frame
                requestAnimationFrame(gameLoop);
                return;
            }

            let dt = frameDelay / 1000;
            gameState.lastFrame = now;
            dt = Math.min(0.033, Math.max(0.001, dt)); // clamp (30-1000 fps)
            dt *= TIME_SCALE;
            // Debug: Log if game speed seems wrong
            if (dt > 0.05) {
                console.warn('Large dt detected:', dt, 'frames may be skipping');
            }

            // IMPORTANT: dt affects ALL game entities equally - never modify dt based on player stats!
            const baseDt = dt; // Store unmodified dt for timer calculations
            const GAME_SPEED = 1.0; // kept for legacy multipliers (now neutral)

            // Clear canvas (world is drawn as tiles)
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Camera follows player (open world)
            camera.x += (player.x - camera.x) * CAMERA_LERP;
            camera.y += (player.y - camera.y) * CAMERA_LERP;


            clampCameraToBounds();
            // World transform
            ctx.setTransform(1, 0, 0, 1, canvas.width / 2 - camera.x, canvas.height / 2 - camera.y);

            // Draw world tiles (open world)
            drawTiles();

            // Tile debug HUD (top-left under UI panels)
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.fillRect(16, 140, 210, 24);
            ctx.fillStyle = '#d4af37';
            ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
            // ctx.fillText(`Tiles: FLOOR=${FLOOR_TILE}  WALL=${WALL_TILE}  ( [ ] ; ' )  R=regen`, 22, 156);
            ctx.restore();

            // Subtle vignette in screen-space
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            const vg = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 50, canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) * 0.65);
            vg.addColorStop(0, 'rgba(0,0,0,0)');
            vg.addColorStop(1, 'rgba(0,0,0,0.55)');
            ctx.fillStyle = vg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Back to world transform for entities
            ctx.setTransform(1, 0, 0, 1, canvas.width / 2 - camera.x, canvas.height / 2 - camera.y);



            // Update timer
            if (now - lastTimerUpdate > 1000) {
                gameTimer--;
                lastTimerUpdate = now;

                if (gameTimer <= 0) {
                    victory();
                    return;
                }

                // SPECIAL BOSS EVENT SYSTEM - triggers at specific time marks
                // Timer counts DOWN from 300 (5:00) to 0
                // We want events at: 4 min left (240s), 3 min left (180s), 2 min left (120s), 1 min left (60s)
                const timeRemaining = gameTimer;

                // Track which events have been triggered
                if (!window.triggeredBossEvents) window.triggeredBossEvents = new Set();

                // Trigger boss events at specific thresholds
                if (timeRemaining <= 240 && timeRemaining > 235 && !window.triggeredBossEvents.has(4)) {
                    window.triggeredBossEvents.add(4);
                    triggerBossEvent(4); // 4 minutes remaining
                }
                if (timeRemaining <= 180 && timeRemaining > 175 && !window.triggeredBossEvents.has(3)) {
                    window.triggeredBossEvents.add(3);
                    triggerBossEvent(3); // 3 minutes remaining
                }
                if (timeRemaining <= 120 && timeRemaining > 115 && !window.triggeredBossEvents.has(2)) {
                    window.triggeredBossEvents.add(2);
                    triggerBossEvent(2); // 2 minutes remaining
                }
                if (timeRemaining <= 60 && timeRemaining > 55 && !window.triggeredBossEvents.has(1)) {
                    window.triggeredBossEvents.add(1);
                    triggerBossEvent(1); // 1 minute remaining - FINAL BOSS EVENT
                }
            }

            // Regeneration
            if (player.upgrades.includes('regen')) {
                player.health = Math.min(player.maxHealth, player.health + dt);
            }


            // Check ultimate cooldown
            if (now - player.lastUltimate > 60000 && !player.ultimateReady) {
                player.ultimateReady = true;
            }

            // Auto-cast ultimate
            if (player.ultimateReady && !player.dead) {
                castUltimate();
            }

            // Update ultimate indicator
            const ultIndicator = document.getElementById('ultimateIndicator');
            if (ultIndicator) {
                ultIndicator.style.display = player.ultimateReady ? 'block' : 'none';
            }

            // Player movement
            let dx = 0;
            let dy = 0;

            // Can't move when dead
            if (!player.dead) {
                // Keyboard controls
                if (keys['w'] || keys['arrowup']) dy -= 1;
                if (keys['s'] || keys['arrowdown']) dy += 1;
                if (keys['a'] || keys['arrowleft']) dx -= 1;
                if (keys['d'] || keys['arrowright']) dx += 1;

                // Virtual joystick (mobile)
                if (joystick.active) {
                    dx += joystick.deltaX;
                    dy += joystick.deltaY;
                }

                // Touch/mouse movement (fallback for non-joystick touch)
                if ((touching || keys[' ']) && !joystick.active) {
                    const tdx = mouseX - player.x;
                    const tdy = mouseY - player.y;
                    const dist = Math.sqrt(tdx * tdx + tdy * tdy);

                    if (dist > 30) {
                        dx = tdx / dist;
                        dy = tdy / dist;
                    }
                }

                // Normalize diagonal movement
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len > 0) {
                    dx = (dx / len);
                    dy = (dy / len);

                    // Only set walk animation if not in a timed animation state
                    if (player.animStateTimer <= 0 && player.animState !== 'dead') {
                        player.animState = 'walk';
                    }
                    player.facingRight = dx > 0;
                } else {
                    // Only return to idle if not in a timed animation state
                    if (player.animStateTimer <= 0 && player.animState === 'walk') {
                        player.animState = 'idle';
                    }
                }

                player.x += dx * player.moveSpeed * dt; // moveSpeed is pixels per second
                player.y += dy * player.moveSpeed * dt;

                // Keep player in bounds
                const pb = getPlayBounds();
                player.x = clamp(player.x, pb.minX + player.radius, pb.maxX - player.radius);
                player.y = clamp(player.y, pb.minY + player.radius, pb.maxY - player.radius);
            }

            // Update boomerangs
            if (player.boomerangs && player.boomerangs.length > 0) {
                player.boomerangs.forEach(boom => {
                    boom.angle += boom.speed * dt;

                    // Calculate boomerang position
                    const boomX = player.x + Math.cos(boom.angle) * boom.distance;
                    const boomY = player.y + Math.sin(boom.angle) * boom.distance;

                    // Check collision with enemies
                    enemies.forEach(enemy => {
                        if (enemy.dead) return;
                        const dx = enemy.x - boomX;
                        const dy = enemy.y - boomY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < enemy.radius + boom.radius) {
                            enemy.health -= boom.damage * dt;
                            enemy.hurtTimer = 0.1;
                            if (enemy.health <= 0) {
                                markEnemyDead(enemy);
                            }
                        }
                    });
                });
            }

            // Spawn enemies - gradually increase spawn rate over time + difficulty scaling
            const minutesSurvived = (300 - gameTimer) / 60;
            // Start at 2.0s, gradually decrease to 0.8s over 5 minutes
            let spawnRateMultiplier = Math.max(0.4, 1.0 - (minutesSurvived * 0.12));

            // Apply difficulty-based spawn rate increase
            // Higher difficulty = faster spawns (lower multiplier)
            if (player.difficultyMultiplier > 1.0) {
                spawnRateMultiplier *= Math.max(0.7, 1.0 / player.difficultyMultiplier);
            }

            const spawnInterval = enemySpawnRate * 1000 * spawnRateMultiplier;

            if (now - lastEnemySpawn > spawnInterval) {
                spawnEnemy();
                lastEnemySpawn = now;
            }

            // HORDE WARNING SYSTEM - spawn large hordes periodically (only after 1 minute)
            const hordeInterval = 50000; // Every 50 seconds (offset from boss events)
            if (!window.lastHordeTime) window.lastHordeTime = now;

            // Only trigger hordes after 1 minute of survival
            const minutesForHorde = (300 - gameTimer) / 60;
            // Check if we're near a boss event time to avoid overlap
            const timeRemaining = Math.ceil(gameTimer);
            const nearBossEvent = (timeRemaining > 235 && timeRemaining < 245) || // 4 min boss
                (timeRemaining > 175 && timeRemaining < 185) || // 3 min boss
                (timeRemaining > 115 && timeRemaining < 125) || // 2 min boss
                (timeRemaining > 55 && timeRemaining < 65);     // 1 min boss

            if (minutesForHorde >= 1.0 && now - window.lastHordeTime >= hordeInterval) {
                // Skip this horde if boss event is imminent
                if (nearBossEvent) {
                    window.lastHordeTime = now; // Reset timer to try again later
                    return; // Skip this horde
                }
                window.lastHordeTime = now;
                // Ensure minimum delay between event toasts
                if (window.lastEventToast && now - window.lastEventToast < 5000) {
                    return; // Wait at least 5 seconds between event notifications
                }
                window.lastEventToast = now;



                // Show warning toast
                showToastNotification('‚ö†Ô∏è LARGE HORDE INCOMING! ‚ö†Ô∏è', '#ff3333');
                try { playSfx('warn'); } catch (e) { }

                // Spawn horde after 3 seconds
                setTimeout(() => {
                    // Horde size scales with level AND difficulty
                    let hordeSize = 12 + Math.floor(player.level * 1.5);
                    hordeSize = Math.floor(hordeSize * (player.difficultyMultiplier || 1.0));

                    for (let i = 0; i < hordeSize; i++) {
                        setTimeout(() => {
                            spawnEnemy();
                        }, i * 80); // Stagger spawns slightly
                    }
                }, 3000);
            }

            // Update and draw enemies
            const time = Date.now() / 1000;
            for (let ei = enemies.length - 1; ei >= 0; ei--) {
                const enemy = enemies[ei];

                // Timers
                if (enemy.hurtTimer > 0) enemy.hurtTimer = Math.max(0, enemy.hurtTimer - dt);

                // Floating animation (used for both canvas + DOM sprites)
                const floatY = Math.sin(time * enemy.floatSpeed + enemy.floatOffset) * 5;

                if (enemy.dead) {
                    enemy.deadTimer -= dt;

                    // Update DOM sprite (dead)
                    if (USE_DOM_SPRITES && spriteOverlay) {
                        const sx = (enemy.x - camera.x) + canvas.width / 2;
                        const sy = (enemy.y - camera.y) + canvas.height / 2 + floatY;
                        const src = enemy.isBoss ? ENEMY_SPRITES.boss.dead : ENEMY_SPRITES.normal.dead;
                        const sizePx = Math.max(28, (enemy.radius * 2) * (enemy.spriteScale || 1));
                        setEnemyDomSprite(enemy, src, sx, sy, sizePx);
                    }

                    if (enemy.deadTimer <= 0) {
                        removeEnemyAtIndex(enemies, ei);
                    }
                    continue;
                }

                // Move towards player with behavior variations
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Update enemy facing direction
                if (Math.abs(dx) > 1) {
                    enemy.facingRight = dx > 0;
                }

                if (dist > enemy.radius + player.radius) {
                    // ENHANCED ENEMY BEHAVIORS
                    let moveX = 0, moveY = 0;

                    switch (enemy.behavior) {
                        case 'zigzag':
                            // Zigzag pattern while approaching
                            enemy.zigzagPhase += dt * 3;
                            const perpX = -dy / dist;
                            const perpY = dx / dist;
                            const zigzagOffset = Math.sin(enemy.zigzagPhase) * 40;
                            moveX = (dx / dist + perpX * zigzagOffset / 100) * enemy.speed * dt;
                            moveY = (dy / dist + perpY * zigzagOffset / 100) * enemy.speed * dt;
                            break;

                        case 'circler':
                            // Circle around player at medium distance
                            const preferredDist = 180;
                            if (dist > preferredDist + 50) {
                                // Move closer
                                moveX = (dx / dist) * enemy.speed * dt;
                                moveY = (dy / dist) * enemy.speed * dt;
                            } else if (dist < preferredDist - 50) {
                                // Move away
                                moveX = -(dx / dist) * enemy.speed * dt;
                                moveY = -(dy / dist) * enemy.speed * dt;
                            } else {
                                // Circle around
                                enemy.circleAngle += dt * 1.5;
                                const targetX = player.x + Math.cos(enemy.circleAngle) * preferredDist;
                                const targetY = player.y + Math.sin(enemy.circleAngle) * preferredDist;
                                const tdx = targetX - enemy.x;
                                const tdy = targetY - enemy.y;
                                const tdist = Math.sqrt(tdx * tdx + tdy * tdy);
                                if (tdist > 10) {
                                    moveX = (tdx / tdist) * enemy.speed * dt;
                                    moveY = (tdy / tdist) * enemy.speed * dt;
                                }
                            }
                            break;

                        case 'rusher':
                            // Fast straight rush with brief pauses
                            enemy.behaviorTimer += dt;
                            if (enemy.behaviorTimer < 1.5) {
                                // Rush phase - faster movement
                                moveX = (dx / dist) * enemy.speed * 1.5 * dt;
                                moveY = (dy / dist) * enemy.speed * 1.5 * dt;
                            } else if (enemy.behaviorTimer < 2.0) {
                                // Pause phase
                                moveX = 0;
                                moveY = 0;
                            } else {
                                enemy.behaviorTimer = 0; // Reset cycle
                            }
                            break;

                        case 'retreater':
                            // Hit and run - approaches then retreats
                            enemy.behaviorTimer += dt;
                            if (enemy.behaviorTimer < 2.0) {
                                // Approach phase
                                moveX = (dx / dist) * enemy.speed * dt;
                                moveY = (dy / dist) * enemy.speed * dt;
                            } else if (enemy.behaviorTimer < 3.5) {
                                // Retreat phase
                                moveX = -(dx / dist) * enemy.speed * 0.8 * dt;
                                moveY = -(dy / dist) * enemy.speed * 0.8 * dt;
                            } else {
                                enemy.behaviorTimer = 0; // Reset cycle
                            }
                            break;

                        default: // 'chase' - normal behavior
                            moveX = (dx / dist) * enemy.speed * dt;
                            moveY = (dy / dist) * enemy.speed * dt;
                            break;
                    }

                    enemy.x += moveX;
                    enemy.y += moveY;
                }

                // Boss special attacks
                if (enemy.isBoss && !enemy.dead) {
                    // Dash attack
                    if (!enemy.isDashing && now - enemy.lastDash > enemy.dashCooldown) {
                        enemy.isDashing = true;
                        enemy.dashTimer = enemy.dashDuration;
                        enemy.lastDash = now;
                        const dx = player.x - enemy.x;
                        const dy = player.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        enemy.dashDirX = dx / dist;
                        enemy.dashDirY = dy / dist;
                    }

                    if (enemy.isDashing) {
                        enemy.x += enemy.dashDirX * enemy.dashSpeed * dt;
                        enemy.y += enemy.dashDirY * enemy.dashSpeed * dt;
                        enemy.dashTimer -= dt;
                        if (enemy.dashTimer <= 0) enemy.isDashing = false;
                    }

                    // Fireball attack
                    if (now - enemy.lastFireball > enemy.fireballCooldown) {
                        enemy.lastFireball = now;
                        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        bossFireballs.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: Math.cos(angle) * 200,
                            vy: Math.sin(angle) * 200,
                            radius: 15,
                            damage: 20,
                            lifetime: 5
                        });
                    }
                }

                // Collision with player
                if (dist < enemy.radius + player.radius) {
                    player.health -= enemy.damage * dt;
                    const _nowH = performance.now();
                    if (_nowH - _lastHitSfx > 150) { _lastHitSfx = _nowH; try { playSfx('hit'); } catch (e) { } }

                    // Trigger hurt animation occasionally
                    if (Math.random() < 0.05 && player.animState !== 'dead' && player.animState !== 'attack') {
                        player.animState = 'hurt';
                        player.animStateTimer = 0.3;
                    }

                    if (player.health <= 0) {
                        player.animState = 'dead';
                        player.dead = true;
                        const _nowD = performance.now();
                        if (_nowD - _lastDeathSfx > 500) { _lastDeathSfx = _nowD; try { playSfx('death'); } catch (e) { } }
                        setTimeout(() => {
                            gameOver();
                        }, 1000); // Wait for death animation
                        return;
                    }
                }


                // Ghost sprite (DOM overlay so GIFs animate reliably)
                if (USE_DOM_SPRITES && spriteOverlay) {
                    const sx = (enemy.x - camera.x) + canvas.width / 2;
                    const sy = (enemy.y - camera.y) + canvas.height / 2 + floatY;

                    let src;
                    if (enemy.isBoss) {
                        src = ENEMY_SPRITES.boss.walk;
                    } else if (enemy.hurtTimer > 0) {
                        src = ENEMY_SPRITES.normal.hurt;
                    } else {
                        src = ENEMY_SPRITES.normal.walk;
                    }
                    const sizePx = Math.max(28, (enemy.radius * 2) * (enemy.spriteScale || 1));
                    setEnemyDomSprite(enemy, src, sx, sy, sizePx);
                } else {
                    // Fallback: simple visible blob if DOM sprites are disabled
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y + floatY);
                    ctx.fillStyle = enemy.isBoss ? 'rgba(255,80,80,0.9)' : 'rgba(210,220,255,0.9)';
                    ctx.beginPath();
                    ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                // Boss indicator - crown
                if (enemy.isBoss) {
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y - enemy.radius - 10 + floatY);
                    ctx.fillStyle = '#FFD700';
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 1;

                    // Crown shape
                    ctx.beginPath();
                    ctx.moveTo(-8, 5);
                    ctx.lineTo(-6, 0);
                    ctx.lineTo(-3, 3);
                    ctx.lineTo(0, -2);
                    ctx.lineTo(3, 3);
                    ctx.lineTo(6, 0);
                    ctx.lineTo(8, 5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                }

                // Health bar
                if (enemy.health < enemy.maxHealth) {
                    const barWidth = enemy.radius * 2;
                    const barHeight = 4;
                    const barX = enemy.x - enemy.radius;
                    const barY = enemy.y - enemy.radius - 15;

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(barX, barY, barWidth, barHeight);

                    ctx.fillStyle = enemy.isBoss ? '#ff0000' : '#00ff00';
                    ctx.fillRect(barX, barY, barWidth * (enemy.health / enemy.maxHealth), barHeight);

                    // Health bar border
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                }

            }

            // Update and draw projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];

                proj.x += proj.vx * dt;
                proj.y += proj.vy * dt;
                proj.traveled += Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy) * dt;

                // Remove if out of range
                if (proj.traveled > proj.range) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // Check collision with enemies
                let hit = false;
                enemies.forEach(enemy => {
                    const dx = enemy.x - proj.x;
                    const dy = enemy.y - proj.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < enemy.radius + proj.radius) {
                        let damage = proj.damage;

                        if (player.upgrades.includes('crit') && Math.random() < 0.2) {
                            damage *= 2;
                            try { playSfx('crit'); } catch (e) { }
                        }

                        enemy.health -= damage;

                        // Explosive strikes - create explosion effect and splash damage
                        if (player.upgrades.includes('explosion') && Math.random() < 0.15) {
                            try { playSfx('explosion'); } catch (e) { }
                            explosionEffects.push({
                                x: enemy.x,
                                y: enemy.y,
                                radius: 0,
                                maxRadius: 60,
                                lifetime: 0.4,
                                age: 0
                            });

                            // Splash damage to nearby enemies
                            enemies.forEach(nearbyEnemy => {
                                if (nearbyEnemy === enemy) return;
                                const dx2 = nearbyEnemy.x - enemy.x;
                                const dy2 = nearbyEnemy.y - enemy.y;
                                const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

                                if (dist2 < 60) {
                                    nearbyEnemy.health -= damage * 0.5;
                                    nearbyEnemy.hurtTimer = 0.18;
                                    if (nearbyEnemy.health <= 0) {
                                        markEnemyDead(nearbyEnemy);
                                    }
                                }
                            });
                        }


                        enemy.hurtTimer = 0.18;
                        if (enemy.health <= 0) {
                            markEnemyDead(enemy);
                        }

                        if (!proj.pierce) {
                            hit = true;
                        }
                    }
                });

                if (hit) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // Draw projectile
                if (player.character.type === 'archer') {
                    // Draw proper arrow for Luna
                    const angle = Math.atan2(proj.vy, proj.vx);
                    const size = proj.radius * 2;

                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    ctx.rotate(angle);

                    // Arrow shaft
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-size * 1.5, -size * 0.15, size * 2, size * 0.3);

                    // Arrow head
                    ctx.beginPath();
                    ctx.moveTo(size * 0.5, 0);
                    ctx.lineTo(size * 0.5 - size * 0.6, -size * 0.4);
                    ctx.lineTo(size * 0.5 - size * 0.6, size * 0.4);
                    ctx.closePath();
                    ctx.fillStyle = '#696969';
                    ctx.fill();

                    // Arrow fletching
                    ctx.fillStyle = '#DC143C';
                    ctx.beginPath();
                    ctx.moveTo(-size * 1.5, -size * 0.3);
                    ctx.lineTo(-size * 1.8, 0);
                    ctx.lineTo(-size * 1.5, size * 0.3);
                    ctx.closePath();
                    ctx.fill();

                    // Outline
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(size * 0.5, 0);
                    ctx.lineTo(size * 0.5 - size * 0.6, -size * 0.4);
                    ctx.lineTo(-size * 1.5, -size * 0.3);
                    ctx.lineTo(-size * 1.8, 0);
                    ctx.lineTo(-size * 1.5, size * 0.3);
                    ctx.lineTo(size * 0.5 - size * 0.6, size * 0.4);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.restore();
                } else {
                    // Circle projectile for non-archers
                    ctx.fillStyle = '#d4af37';
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            // Update boss fireballs (moved outside projectile loop to fix scoping)
            for (let i = bossFireballs.length - 1; i >= 0; i--) {
                const fb = bossFireballs[i];
                fb.x += fb.vx * dt;
                fb.y += fb.vy * dt;
                fb.lifetime -= dt;

                if (fb.lifetime <= 0) {
                    bossFireballs.splice(i, 1);
                    continue;
                }

                const dx = player.x - fb.x;
                const dy = player.y - fb.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < player.radius + fb.radius) {
                    let dmg = fb.damage;
                    if (player.armor) dmg *= (1 - player.armor);
                    player.health -= dmg;

                    explosionEffects.push({
                        x: fb.x,
                        y: fb.y,
                        radius: 0,
                        maxRadius: 50,
                        lifetime: 0.3,
                        age: 0
                    });

                    bossFireballs.splice(i, 1);

                    // Check if player died from fireball
                    if (player.health <= 0 && !player.dead) {
                        player.animState = 'dead';
                        player.dead = true;
                        try { playSfx('death'); } catch (e) { }
                        setTimeout(() => {
                            gameOver();
                        }, 1000); // Wait for death animation
                        return;
                    }

                    continue;
                }

                // Draw fireball
                ctx.save();
                ctx.translate(fb.x, fb.y);
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, fb.radius);
                gradient.addColorStop(0, '#ffff00');
                gradient.addColorStop(0.5, '#ff6600');
                gradient.addColorStop(1, '#ff0000');
                ctx.fillStyle = gradient;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff6600';
                ctx.beginPath();
                ctx.arc(0, 0, fb.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Update ultimate effects
            for (let i = ultimateEffects.length - 1; i >= 0; i--) {
                const ult = ultimateEffects[i];
                ult.age += dt;

                if (ult.age >= ult.lifetime) {
                    ultimateEffects.splice(i, 1);
                    continue;
                }

                if (ult.type === 'shockwave') {
                    ult.radius = (ult.age / ult.lifetime) * ult.maxRadius;
                    ctx.save();
                    ctx.translate(ult.x, ult.y);
                    const alpha = 1 - (ult.age / ult.lifetime);
                    ctx.strokeStyle = `rgba(212, 175, 55, ${alpha})`;
                    ctx.lineWidth = 15;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = 'rgba(212, 175, 55, 0.8)';
                    ctx.beginPath();
                    ctx.arc(0, 0, ult.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }

                if (ult.type === 'tornado') {
                    ult.rotation += 10 * dt;

                    enemies.forEach(enemy => {
                        const dx = enemy.x - player.x;
                        const dy = enemy.y - player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < ult.radius) {
                            enemy.health -= 15 * dt;
                            enemy.hurtTimer = 0.1;
                            if (enemy.health <= 0) markEnemyDead(enemy);
                        }
                    });

                    ctx.save();
                    ctx.translate(player.x, player.y);
                    for (let b = 0; b < 8; b++) {
                        const angle = ult.rotation + (Math.PI * 2 * b) / 8;
                        const dist = ult.radius * 0.7;
                        const x = Math.cos(angle) * dist;
                        const y = Math.sin(angle) * dist;
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(angle);
                        ctx.strokeStyle = 'rgba(100, 150, 255, 0.8)';
                        ctx.lineWidth = 6;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = 'rgba(100, 150, 255, 0.8)';
                        ctx.beginPath();
                        ctx.moveTo(-20, 0);
                        ctx.lineTo(20, 0);
                        ctx.stroke();
                        ctx.restore();
                    }
                    ctx.restore();
                }
            }

            // Update and draw slash effects
            for (let i = slashEffects.length - 1; i >= 0; i--) {
                const slash = slashEffects[i];
                slash.age += dt;

                if (slash.age >= slash.lifetime) {
                    slashEffects.splice(i, 1);
                    continue;
                }

                const progress = slash.age / slash.lifetime;
                const alpha = 1 - progress;
                const arcLength = Math.PI * 0.6; // 108 degrees

                ctx.save();
                ctx.translate(slash.x, slash.y);
                ctx.rotate(slash.angle);

                // Draw arc slash with golden glow
                ctx.strokeStyle = `rgba(212, 175, 55, ${alpha * 0.8})`;
                ctx.lineWidth = 8 * (1 - progress * 0.5);
                ctx.lineCap = 'round';
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(212, 175, 55, 0.8)';

                ctx.beginPath();
                const startAngle = -arcLength / 2 + (progress * arcLength * 0.3);
                const endAngle = arcLength / 2 + (progress * arcLength * 0.3);
                ctx.arc(0, 0, slash.range * 0.7, startAngle, endAngle);
                ctx.stroke();

                // Inner white glow
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
                ctx.lineWidth = 4 * (1 - progress * 0.5);
                ctx.shadowBlur = 5;
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(0, 0, slash.range * 0.7, startAngle, endAngle);
                ctx.stroke();

                ctx.restore();
            }

            // Update and draw explosion effects
            for (let i = explosionEffects.length - 1; i >= 0; i--) {
                const explosion = explosionEffects[i];
                explosion.age += dt;

                if (explosion.age >= explosion.lifetime) {
                    explosionEffects.splice(i, 1);
                    continue;
                }

                const progress = explosion.age / explosion.lifetime;
                explosion.radius = explosion.maxRadius * progress;
                const alpha = 1 - progress;

                ctx.save();
                ctx.translate(explosion.x, explosion.y);

                // Outer explosion ring (orange/red)
                ctx.strokeStyle = `rgba(255, 100, 0, ${alpha * 0.8})`;
                ctx.lineWidth = 12 * (1 - progress * 0.3);
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(255, 100, 0, 0.8)';
                ctx.beginPath();
                ctx.arc(0, 0, explosion.radius, 0, Math.PI * 2);
                ctx.stroke();

                // Middle ring (yellow)
                ctx.strokeStyle = `rgba(255, 200, 0, ${alpha * 0.6})`;
                ctx.lineWidth = 8 * (1 - progress * 0.3);
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(255, 200, 0, 0.6)';
                ctx.beginPath();
                ctx.arc(0, 0, explosion.radius * 0.8, 0, Math.PI * 2);
                ctx.stroke();

                // Inner core (white)
                ctx.fillStyle = `rgba(255, 255, 200, ${alpha * 0.8})`;
                ctx.shadowBlur = 25;
                ctx.shadowColor = 'rgba(255, 255, 255, 1)';
                ctx.beginPath();
                ctx.arc(0, 0, explosion.radius * 0.3, 0, Math.PI * 2);
                ctx.fill();

                // Particles
                for (let p = 0; p < 8; p++) {
                    const angle = (Math.PI * 2 * p) / 8 + (progress * 0.5);
                    const particleDist = explosion.radius * (0.7 + Math.random() * 0.3);
                    const px = Math.cos(angle) * particleDist;
                    const py = Math.sin(angle) * particleDist;

                    ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            // Draw bone boomerangs
            if (player.boomerangs && player.boomerangs.length > 0) {
                player.boomerangs.forEach(boom => {
                    const boomX = player.x + Math.cos(boom.angle) * boom.distance;
                    const boomY = player.y + Math.sin(boom.angle) * boom.distance;

                    ctx.save();
                    ctx.translate(boomX, boomY);
                    ctx.rotate(boom.angle);

                    // Bone shape
                    ctx.fillStyle = '#f0e6d2';
                    ctx.strokeStyle = '#8B7355';
                    ctx.lineWidth = 2;

                    // Draw bone (dumbbell shape)
                    ctx.beginPath();
                    // Left bulb
                    ctx.arc(-boom.radius * 0.7, 0, boom.radius * 0.5, 0, Math.PI * 2);
                    // Right bulb
                    ctx.arc(boom.radius * 0.7, 0, boom.radius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Middle bar
                    ctx.fillRect(-boom.radius * 0.7, -boom.radius * 0.25, boom.radius * 1.4, boom.radius * 0.5);
                    ctx.strokeRect(-boom.radius * 0.7, -boom.radius * 0.25, boom.radius * 1.4, boom.radius * 0.5);

                    // Add glow effect
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = 'rgba(212, 175, 55, 0.6)';
                    ctx.fillStyle = 'rgba(212, 175, 55, 0.3)';
                    ctx.beginPath();
                    ctx.arc(0, 0, boom.radius * 1.2, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                });
            }

            // Update and draw XP orbs
            for (let i = xpOrbs.length - 1; i >= 0; i--) {
                const orb = xpOrbs[i];

                // Remove if expired
                if (now - orb.spawnTime > orb.lifetime) {
                    xpOrbs.splice(i, 1);
                    continue;
                }

                // Calculate distance to player (no automatic movement - orbs stay where they spawned)
                const dx = player.x - orb.x;
                const dy = player.y - orb.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Only collect when player touches the orb
                if (dist < player.radius + orb.radius + 5) {
                    const xpMultiplier = 1 + (gameState.permanentUpgrades.xp * 0.1);
                    player.xp += orb.value * xpMultiplier;
                    sounds.playOrbPickup();

                    if (player.xp >= player.xpToNext) {
                        player.xp -= player.xpToNext;
                        player.level++;

                        // FIXED XP PROGRESSION - Easy early, progressively harder
                        // Each enemy gives 10 XP, so divide by 10 to get kill count
                        // Level 1->2: 30 XP (3 kills) - Very easy start!
                        // Level 2->3: 40 XP (4 kills)
                        // Level 3->4: 50 XP (5 kills)
                        // Level 4->5: 60 XP (6 kills)
                        // Level 5->6: 70 XP (7 kills)
                        // Level 6->10: 80-120 XP (8-12 kills)
                        // Level 10+: Exponential growth

                        if (player.level <= 5) {
                            // Levels 1-5: Very easy, linear growth
                            player.xpToNext = 20 + (player.level * 10);
                        } else if (player.level <= 10) {
                            // Levels 6-10: Moderate growth
                            player.xpToNext = 70 + ((player.level - 5) * 10);
                        } else if (player.level <= 15) {
                            // Levels 11-15: Quadratic growth
                            const levelAbove10 = player.level - 10;
                            player.xpToNext = 120 + (levelAbove10 * levelAbove10 * 15);
                        } else {
                            // Levels 16+: Exponential for late game challenge
                            player.xpToNext = Math.floor(player.xpToNext * 1.4 + 60);
                        }

                        levelUp();
                    }

                    xpOrbs.splice(i, 1);
                    continue;
                }

                // Draw orb
                ctx.fillStyle = '#00d4ff';
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw vampiric aura if player has the upgrade
            if (player.upgrades.includes('vampire')) {
                const auraTime = Date.now() / 1000;
                const pulseSize = Math.sin(auraTime * 3) * 10 + 70;
                const pulseAlpha = (Math.sin(auraTime * 3) * 0.3 + 0.4);

                ctx.save();
                ctx.translate(player.x, player.y);

                // Outer aura ring (dark red)
                ctx.strokeStyle = `rgba(139, 0, 0, ${pulseAlpha * 0.6})`;
                ctx.lineWidth = 8;
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(139, 0, 0, 0.8)';
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.stroke();

                // Middle ring (blood red)
                ctx.strokeStyle = `rgba(200, 0, 0, ${pulseAlpha * 0.5})`;
                ctx.lineWidth = 5;
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(200, 0, 0, 0.6)';
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize * 0.7, 0, Math.PI * 2);
                ctx.stroke();

                // Inner glow
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, pulseSize * 0.5);
                gradient.addColorStop(0, `rgba(255, 0, 0, ${pulseAlpha * 0.3})`);
                gradient.addColorStop(1, 'rgba(139, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize * 0.5, 0, Math.PI * 2);
                ctx.fill();

                // Floating blood particles
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 * i / 6) + auraTime;
                    const distance = pulseSize * 0.6;
                    const px = Math.cos(angle) * distance;
                    const py = Math.sin(angle) * distance + Math.sin(auraTime * 2 + i) * 5;

                    ctx.fillStyle = `rgba(200, 0, 0, ${pulseAlpha * 0.8})`;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            // Draw player with sprite
            if (sprites.loaded && player.character) {
                // Update animation state timer
                if (player.animStateTimer > 0) {
                    player.animStateTimer -= dt;
                    if (player.animStateTimer <= 0) {
                        // Return to idle after timed animation
                        if (player.animState === 'attack') {
                            player.animState = 'idle';
                        }
                    }
                }


                // Get the appropriate sprite (fallback if a specific state gif is missing)
                const desiredKey = `${player.animState}_${player.character.animPrefix}`;
                const idleKey = `idle_${player.character.animPrefix}`;
                const walkKey = `walk_${player.character.animPrefix}`;
                const attackKey = `attack_${player.character.animPrefix}`;

                let spriteKey = desiredKey;
                let sprite = sprites.images[spriteKey];

                const spriteOk = (img) => img && img.complete && img.naturalWidth > 0;

                // If current state's gif is missing, gracefully fallback:
                if (!spriteOk(sprite)) {
                    if (player.animState === 'attack' && spriteOk(sprites.images[attackKey])) {
                        spriteKey = attackKey; sprite = sprites.images[spriteKey];
                    } else if (player.animState === 'walk' && spriteOk(sprites.images[walkKey])) {
                        spriteKey = walkKey; sprite = sprites.images[spriteKey];
                    } else if (spriteOk(sprites.images[idleKey])) {
                        spriteKey = idleKey; sprite = sprites.images[spriteKey];
                    }
                }

                // Debug logging every 60 frames (once per second at 60fps)
                if (Math.random() < 0.016) {
                    console.log(`Current animation: ${spriteKey}, Status: ${sprites.loadStatus[spriteKey]}, Has sprite: ${!!sprite}, Complete: ${sprite?.complete}, Width: ${sprite?.naturalWidth}`);
                }

                // Check if sprite is properly loaded (has width)
                if (spriteOk(sprite)) {
                    ctx.save();
                    ctx.translate(player.x, player.y);

                    // Range indicator (current attack range)
                    (function drawRange() {
                        const r = Math.max(10, player.attackRange || 0);
                        const pulse = 0.5 + 0.5 * Math.sin(time * 2.2);
                        ctx.save();
                        ctx.globalAlpha = 0.22 + pulse * 0.10;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([8, 6]);
                        ctx.strokeStyle = 'rgba(200, 220, 255, 0.75)';
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Soft fill so it reads on dark backgrounds
                        ctx.globalAlpha = 0.05 + pulse * 0.03;
                        ctx.fillStyle = 'rgba(200, 220, 255, 0.45)';
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    })();

                    // Flip horizontally if facing left
                    if (!player.facingRight) {
                        ctx.scale(-1, 1);
                    }


                    // Subtle bob to imply motion even if a GIF is effectively static in canvas
                    const t = Date.now() / 1000;
                    const bob = (player.animState === 'walk') ? Math.sin(t * 10) * 1.5 : 0;
                    const recoil = (player.animState === 'attack') ? -Math.sin(t * 30) * 1.0 : 0;
                    ctx.translate(0, bob + recoil);

                    // Draw sprite centered and scaled
                    const scale = player.character.spriteScale;
                    const w = sprite.naturalWidth * scale;
                    const h = sprite.naturalHeight * scale;

                    // Use image smoothing for better quality
                    ctx.imageSmoothingEnabled = false; // Keeps pixel art crisp
                    if (!USE_DOM_SPRITES) {
                        ctx.drawImage(sprite, -w / 2, -h / 2, w, h);
                    }
                    // Update DOM sprite so GIF always animates
                    const screenX = (player.x - camera.x) + canvas.width / 2;
                    const screenY = (player.y - camera.y) + canvas.height / 2;
                    setPlayerDomSprite(sprite.src, screenX, screenY, w, h, player.facingRight, (bob + recoil));

                    // Extra attack readability (helps if attack GIF appears static)
                    if (player.animState === 'attack') {
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, Math.max(18, player.attackRange * 0.22), -0.6, 0.6);
                        ctx.stroke();
                        ctx.restore();
                    }

                    ctx.restore();
                } else {
                    // Fallback to circle if sprite not loaded
                    if (Math.random() < 0.016) {
                        console.warn(`‚ö† Sprite not rendering: ${spriteKey} - Using fallback circle`);
                    }
                    hidePlayerDomSprite();
                    drawPlayerCircle();
                }
            } else {
                // Fallback to circle
                hidePlayerDomSprite();
                drawPlayerCircle();
            }

            function drawPlayerCircle() {
                ctx.save();
                ctx.translate(player.x, player.y);
                if (!player.facingRight) {
                    ctx.scale(-1, 1);
                }

                const colors = {
                    'brawler': '#d4af37',
                    'archer': '#8B4513',
                    'swordsman': '#c0c0c0'
                };

                ctx.fillStyle = player.character ? colors[player.character.type] : '#d4af37';
                ctx.beginPath();
                ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            }

            // Auto-attack
            if (!player.dead) {
                attack();
            }

            // Update HUD
            updateHUD();

            updateStatsPanel();

            // Continue loop
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameState.screen = 'gameover';
            gameState.loopRunning = false;
            document.getElementById('hud').style.display = 'none';
            document.getElementById('statsPanel').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'flex';

            // Hide mobile controls
            const mobileControls = document.getElementById('mobileControls');
            if (mobileControls) {
                mobileControls.style.display = 'none';
            }

            // Calculate rewards - 1 bone per kill only (harder economy)
            const bonesEarned = player.kills * 3;
            gameState.currency += bonesEarned;
            localStorage.setItem('barkCurrency', gameState.currency);

            // Update stats
            const minutes = Math.floor((300 - gameTimer) / 60);
            const seconds = Math.floor((300 - gameTimer) % 60);
            document.getElementById('finalTime').textContent = minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
            document.getElementById('finalKills').textContent = player.kills;
            document.getElementById('finalLevel').textContent = player.level;
            document.getElementById('bonesEarned').textContent = bonesEarned;
        }

        function victory() {
            gameState.screen = 'victory';
            gameState.loopRunning = false;
            document.getElementById('hud').style.display = 'none';
            document.getElementById('statsPanel').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'flex';

            // Hide mobile controls
            const mobileControls = document.getElementById('mobileControls');
            if (mobileControls) {
                mobileControls.style.display = 'none';
            }

            // Calculate rewards - 2x bones for victory (2 per kill)
            const bonesEarned = player.kills * 6;
            gameState.currency += bonesEarned;
            localStorage.setItem('barkCurrency', gameState.currency);

            // Update stats
            document.getElementById('victoryKills').textContent = player.kills;
            document.getElementById('victoryLevel').textContent = player.level;
            document.getElementById('victoryBones').textContent = bonesEarned;
        }

        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';
            clearDomSprites();
            gameState.lastFrame = 0;
            touching = false;
            mouseDown = false;
            for (const k in keys) { keys[k] = false; }
            showCharacterSelect();
        }

        // Initialize
        updateCharacterCards();
    </script>

    <script>
        /* ===============================
           BOSS ABILITIES PATCH (GLOBAL)
           Dash + Melee + Fireball + Warning
           Works on ALL platforms
        ================================= */

        (function () {
            if (!window.enemies) return;

            const FIREBALL_SPEED = 4;
            const FIREBALL_DAMAGE = 15;
            const FIREBALL_COOLDOWN = 2200;
            const DASH_COOLDOWN = 3000;
            const DASH_SPEED = 12;
            const WARNING_TIME = 600;

            window.bossProjectiles = [];

            function spawnWarning(x, y, r, color) {
                try { playSfx('warn'); } catch (e) { }
                bossProjectiles.push({
                    x, y, r, color, warning: true, t: performance.now()
                });
            }

            function spawnFireball(x, y, vx, vy) {
                try { playSfx('fireball'); } catch (e) { }
                bossProjectiles.push({
                    x, y, vx, vy, r: 10, warning: false
                });
            }

            function updateBossAbilities(boss, player) {
                const now = performance.now();
                if (!boss._ai) {
                    boss._ai = {
                        lastFireball: 0,
                        lastDash: 0,
                        state: "idle"
                    };
                }

                const dx = player.x - boss.x;
                const dy = player.y - boss.y;
                const dist = Math.hypot(dx, dy);

                // FIREBALL (long range)
                if (dist > 180 && now - boss._ai.lastFireball > FIREBALL_COOLDOWN) {
                    boss._ai.lastFireball = now;
                    boss._ai.state = "fireball";

                    spawnWarning(boss.x, boss.y, 40, "rgba(255,80,0,0.4)");

                    setTimeout(() => {
                        const len = Math.hypot(dx, dy) || 1;
                        spawnFireball(
                            boss.x,
                            boss.y,
                            (dx / len) * FIREBALL_SPEED,
                            (dy / len) * FIREBALL_SPEED
                        );
                        boss._ai.state = "idle";
                    }, WARNING_TIME);
                }

                // DASH (short range)
                if (dist < 160 && now - boss._ai.lastDash > DASH_COOLDOWN) {
                    boss._ai.lastDash = now;
                    boss._ai.state = "dash";

                    spawnWarning(boss.x, boss.y, 30, "rgba(255,0,0,0.35)");

                    setTimeout(() => {
                        const len = Math.hypot(dx, dy) || 1;
                        boss.vx = (dx / len) * DASH_SPEED;
                        boss.vy = (dy / len) * DASH_SPEED;
                        try { playSfx('dash'); } catch (e) { }
                        boss._ai.state = "idle";
                    }, WARNING_TIME);
                }
            }

            // PATCH GAME LOOP
            const _origUpdate = window.updateGame;
            window.updateGame = function () {
                _origUpdate();

                const boss = enemies.find(e => e.isBoss);
                if (boss && window.player) {
                    updateBossAbilities(boss, player);
                }

                // UPDATE PROJECTILES
                bossProjectiles = bossProjectiles.filter(p => {
                    if (p.warning) return performance.now() - p.t < WARNING_TIME;
                    p.x += p.vx;
                    p.y += p.vy;

                    const dx = p.x - player.x;
                    const dy = p.y - player.y;
                    if (Math.hypot(dx, dy) < p.r + 12) {
                        player.health -= FIREBALL_DAMAGE;
                        try { playSfx('hit'); } catch (e) { }
                        return false;
                    }
                    return true;
                });
            };

            // PATCH RENDER
            const _origRender = window.renderGame;
            window.renderGame = function () {
                _origRender();
                const ctx = window.ctx;
                bossProjectiles.forEach(p => {
                    ctx.beginPath();
                    ctx.fillStyle = p.color || "orange";
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.fill();
                });
            };
        })();
    </script>


    <script>
        /* ===============================
           AUDIO SYSTEM (SFX + MUSIC)
           - No external assets required (WebAudio)
           - Music can be toggled in Options
           - SFX can be toggled in Options
        ================================= */
        (function () {
            const LS_MUSIC = 'bos_music_enabled';
            const LS_SFX = 'bos_sfx_enabled';

            window.audioSettings = window.audioSettings || {
                musicEnabled: (localStorage.getItem(LS_MUSIC) ?? '1') === '1',
                sfxEnabled: (localStorage.getItem(LS_SFX) ?? '1') === '1'
            };

            let ctx = null;
            let master = null;
            let musicGain = null;
            let sfxGain = null;
            let musicTimer = null;
            let musicOsc = null;

            function ensureCtx() {
                if (ctx) return ctx;
                const AC = window.AudioContext || window.webkitAudioContext;
                if (!AC) return null;
                ctx = new AC();
                master = ctx.createGain();
                musicGain = ctx.createGain();
                sfxGain = ctx.createGain();
                master.gain.value = 0.9;
                musicGain.gain.value = window.audioSettings.musicEnabled ? 0.20 : 0.0;
                sfxGain.gain.value = window.audioSettings.sfxEnabled ? 0.55 : 0.0;
                musicGain.connect(master);
                sfxGain.connect(master);
                master.connect(ctx.destination);
                return ctx;
            }

            function unlock() {
                const c = ensureCtx();
                if (!c) return;
                if (c.state === 'suspended') c.resume().catch(() => { });
                // Start music only after a user gesture
                if (window.audioSettings.musicEnabled) startMusic();
                window.removeEventListener('pointerdown', unlock, { passive: true });
                window.removeEventListener('touchstart', unlock, { passive: true });
                window.removeEventListener('keydown', unlock);
            }

            window.addEventListener('pointerdown', unlock, { passive: true });
            window.addEventListener('touchstart', unlock, { passive: true });
            window.addEventListener('keydown', unlock);

            function beep({ freq = 440, dur = 0.08, type = 'square', gain = 0.15, slideTo = null } = {}) {
                const c = ensureCtx();
                if (!c) return;
                const o = c.createOscillator();
                const g = c.createGain();
                o.type = type;
                o.frequency.setValueAtTime(freq, c.currentTime);
                if (slideTo) {
                    o.frequency.exponentialRampToValueAtTime(Math.max(40, slideTo), c.currentTime + dur);
                }
                g.gain.setValueAtTime(0.0001, c.currentTime);
                g.gain.exponentialRampToValueAtTime(gain, c.currentTime + 0.01);
                g.gain.exponentialRampToValueAtTime(0.0001, c.currentTime + dur);
                o.connect(g);
                g.connect(sfxGain);
                o.start();
                o.stop(c.currentTime + dur + 0.02);
            }

            window.playSfx = function (name) {
                if (!window.audioSettings.sfxEnabled) return;
                // Basic palette (lightweight)
                switch (name) {
                    case 'click': beep({ freq: 660, dur: 0.05, type: 'square', gain: 0.10, slideTo: 520 }); break;
                    case 'pickup': beep({ freq: 880, dur: 0.07, type: 'triangle', gain: 0.12, slideTo: 1200 }); break;
                    case 'levelup':
                        beep({ freq: 523.25, dur: 0.08, type: 'triangle', gain: 0.13, slideTo: 659.25 });
                        setTimeout(() => beep({ freq: 659.25, dur: 0.08, type: 'triangle', gain: 0.13, slideTo: 783.99 }), 80);
                        setTimeout(() => beep({ freq: 783.99, dur: 0.10, type: 'triangle', gain: 0.13, slideTo: 1046.5 }), 160);
                        break;
                    case 'hit': beep({ freq: 180, dur: 0.06, type: 'sawtooth', gain: 0.16, slideTo: 120 }); break;
                    case 'death':
                        beep({ freq: 140, dur: 0.10, type: 'sawtooth', gain: 0.18, slideTo: 80 });
                        setTimeout(() => beep({ freq: 90, dur: 0.12, type: 'sawtooth', gain: 0.18, slideTo: 60 }), 110);
                        break;
                    case 'shoot': beep({ freq: 520, dur: 0.04, type: 'square', gain: 0.08, slideTo: 420 }); break;
                    case 'slash': beep({ freq: 380, dur: 0.06, type: 'triangle', gain: 0.12, slideTo: 520 }); break;

                    case 'explosion': beep({ freq: 120, dur: 0.12, type: 'sawtooth', gain: 0.18, slideTo: 60 }); break;
                    case 'vampire': beep({ freq: 420, dur: 0.06, type: 'triangle', gain: 0.08, slideTo: 520 }); break;
                    case 'boomerang': beep({ freq: 520, dur: 0.05, type: 'triangle', gain: 0.05, slideTo: 420 }); break;

                    // CHARACTER-SPECIFIC ATTACK SOUNDS (POLISHED)
                    case 'arrow':
                        // Luna - crisp arrow shooting sound with whoosh
                        beep({ freq: 1100, dur: 0.05, type: 'sine', gain: 0.14, slideTo: 1500 });
                        setTimeout(() => beep({ freq: 1500, dur: 0.03, type: 'sine', gain: 0.08, slideTo: 1200 }), 30);
                        break;
                    case 'punch':
                        // Rex - deep punching impact sound
                        beep({ freq: 150, dur: 0.08, type: 'square', gain: 0.20, slideTo: 90 });
                        setTimeout(() => beep({ freq: 80, dur: 0.06, type: 'sawtooth', gain: 0.16, slideTo: 60 }), 45);
                        break;
                    case 'sword':
                        // Blade - sharp sword slash with metallic ring
                        beep({ freq: 550, dur: 0.08, type: 'triangle', gain: 0.16, slideTo: 920 });
                        setTimeout(() => beep({ freq: 420, dur: 0.06, type: 'sawtooth', gain: 0.12, slideTo: 320 }), 50);
                        break;

                    case 'slash': beep({ freq: 380, dur: 0.06, type: 'triangle', gain: 0.12, slideTo: 520 }); break;
                    case 'shoot': beep({ freq: 520, dur: 0.04, type: 'square', gain: 0.08, slideTo: 420 }); break;

                    case 'crit':
                        // bright, short "ping" layered
                        beep({ freq: 1200, dur: 0.04, type: 'triangle', gain: 0.14, slideTo: 1600 });
                        setTimeout(() => beep({ freq: 1600, dur: 0.05, type: 'triangle', gain: 0.10, slideTo: 1100 }), 25);
                        break;

                    case 'dash': beep({ freq: 220, dur: 0.09, type: 'square', gain: 0.12, slideTo: 660 }); break;
                    case 'fireball': beep({ freq: 300, dur: 0.10, type: 'sawtooth', gain: 0.12, slideTo: 180 }); break;
                    case 'warn':
                        // Warning sound for horde
                        beep({ freq: 900, dur: 0.10, type: 'square', gain: 0.14, slideTo: 750 });
                        setTimeout(() => beep({ freq: 900, dur: 0.10, type: 'square', gain: 0.14, slideTo: 750 }), 200);
                        break;
                    default: beep({ freq: 440, dur: 0.06, type: 'square', gain: 0.10 }); break;
                }
            };

            function startMusic() {
                const c = ensureCtx();
                if (!c || musicTimer || !window.audioSettings.musicEnabled) return;

                // One-osc loop with a simple progression (low CPU)
                const seq = [
                    261.63, 329.63, 392.00, 329.63, // C E G E
                    246.94, 311.13, 369.99, 311.13, // B‚ô≠ D# F# D#
                    220.00, 277.18, 329.63, 277.18, // A C# E C#
                    233.08, 293.66, 349.23, 293.66  // Bb D F D
                ];
                let i = 0;

                musicOsc = c.createOscillator();
                const g = c.createGain();
                musicOsc.type = 'triangle';
                g.gain.value = 0.0001;
                musicOsc.connect(g);
                g.connect(musicGain);
                musicOsc.start();

                // Soft attack
                g.gain.setTargetAtTime(0.16, c.currentTime, 0.06);

                musicTimer = setInterval(() => {
                    if (!window.audioSettings.musicEnabled) return;
                    const f = seq[i++ % seq.length];
                    musicOsc.frequency.setTargetAtTime(f, c.currentTime, 0.02);
                }, 180);
            }

            function stopMusic() {
                if (musicTimer) { clearInterval(musicTimer); musicTimer = null; }
                if (musicOsc) {
                    try { musicOsc.stop(); } catch (e) { }
                    try { musicOsc.disconnect(); } catch (e) { }
                    musicOsc = null;
                }
            }


            window.startBossMusic = function () {
                const c = ensureCtx();
                if (!c || bossTimer || !window.audioSettings.musicEnabled) return;

                // Stop normal music first
                window.stopMusic();

                // Boss music - more intense, faster rhythm
                const bossSeq = [
                    164.81, 220.00, 277.18, 220.00, // E A C# A
                    155.56, 207.65, 261.63, 207.65, // D# G# C G#
                    146.83, 196.00, 246.94, 196.00, // D G B‚ô≠ G
                    138.59, 185.00, 233.08, 185.00  // C# F# Bb F#
                ];
                let i = 0;

                bossOsc = c.createOscillator();
                const g = c.createGain();
                bossOsc.type = 'sawtooth'; // More aggressive sound
                g.gain.value = 0.0001;
                bossOsc.connect(g);
                g.connect(musicGain);
                bossOsc.start();

                g.gain.setTargetAtTime(0.20, c.currentTime, 0.06);

                bossTimer = setInterval(() => {
                    if (!window.audioSettings.musicEnabled) return;
                    const f = bossSeq[i++ % bossSeq.length];
                    bossOsc.frequency.setTargetAtTime(f, c.currentTime, 0.01);
                }, 120); // Faster tempo
            };

            window.stopBossMusic = function () {
                if (bossTimer) { clearInterval(bossTimer); bossTimer = null; }
                if (bossOsc) {
                    try { bossOsc.stop(); } catch (e) { }
                    try { bossOsc.disconnect(); } catch (e) { }
                    bossOsc = null;
                }
            };

            window.toggleMusic = function () {
                window.audioSettings.musicEnabled = !window.audioSettings.musicEnabled;
                localStorage.setItem(LS_MUSIC, window.audioSettings.musicEnabled ? '1' : '0');
                ensureCtx();
                if (musicGain) musicGain.gain.value = window.audioSettings.musicEnabled ? 0.20 : 0.0;
                if (window.audioSettings.musicEnabled) {
                    if (gameState.bossRoundActive) {
                        startBossMusic();
                    } else {
                        startMusic();
                    }
                } else {
                    stopMusic();
                    stopBossMusic();
                }
                updateAudioButtons();
                try { playSfx('click'); } catch (e) { }
            };

            window.toggleSfx = function () {
                window.audioSettings.sfxEnabled = !window.audioSettings.sfxEnabled;
                localStorage.setItem(LS_SFX, window.audioSettings.sfxEnabled ? '1' : '0');
                ensureCtx();
                if (sfxGain) sfxGain.gain.value = window.audioSettings.sfxEnabled ? 0.55 : 0.0;
                updateAudioButtons();
                if (window.audioSettings.sfxEnabled) try { playSfx('click'); } catch (e) { }
            };

            window.updateAudioButtons = function () {
                const mBtn = document.getElementById('musicToggleBtn');
                const sBtn = document.getElementById('sfxToggleBtn');
                if (mBtn) mBtn.textContent = 'Music: ' + (window.audioSettings.musicEnabled ? 'ON' : 'OFF');
                if (sBtn) sBtn.textContent = 'SFX: ' + (window.audioSettings.sfxEnabled ? 'ON' : 'OFF');
            };

            // UI clicks -> SFX
            document.addEventListener('click', (e) => {
                const t = e.target;
                if (!t) return;
                if (t.classList && (t.classList.contains('menu-btn') || t.classList.contains('back-btn'))) {
                    try { playSfx('click'); } catch (e) { }
                }
            });

            // Initialize button labels if options exists
            window.addEventListener('load', () => {
                updateAudioButtons();
            });

        })();
    </script>


    <script>
        /* ===== Runtime Error Overlay (non-invasive) ===== */
        (function () {
            function showErr(msg) {
                let el = document.getElementById('runtimeErrOverlay');
                if (!el) {
                    el = document.createElement('div');
                    el.id = 'runtimeErrOverlay';
                    el.style.cssText = 'position:fixed;left:12px;right:12px;bottom:12px;z-index:999999;background:rgba(120,0,0,.88);border:1px solid rgba(255,255,255,.25);color:#fff;padding:10px 12px;border-radius:10px;font:12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;white-space:pre-wrap;max-height:45vh;overflow:auto;';
                    document.body.appendChild(el);
                }
                el.textContent = msg;
            }
            window.addEventListener('error', (e) => {
                const msg = 'Runtime error:\n' + (e.error && (e.error.stack || e.error.message) ? (e.error.stack || e.error.message) : (e.message || String(e)));
                showErr(msg);
            });
            window.addEventListener('unhandledrejection', (e) => {
                const r = e.reason;
                const msg = 'Unhandled promise rejection:\n' + (r && (r.stack || r.message) ? (r.stack || r.message) : String(r));
                showErr(msg);
            });
        })();
    </script>


    <!-- Active Upgrades Indicator -->
    <div id="activeUpgrades" style="position: fixed; bottom: 20px; right: 20px; 
         background: rgba(0,0,0,0.9); border: 2px solid var(--gold); 
         padding: 0.5rem; max-width: 200px; display: none; z-index: 100;
         font-family: 'Rajdhani', sans-serif; box-sizing: border-box;">
        <div style="font-family: 'Bebas Neue'; color: var(--gold); font-size: 0.9rem; margin-bottom: 0.3rem;">ACTIVE
        </div>
        <div id="upgradeList" style="font-size: 0.7rem; color: #aaa; line-height: 1.4;"></div>
    </div>

    <!-- Ultimate Ready Indicator -->
    <div id="ultimateIndicator" style="position: fixed; bottom: 120px; left: 50%; 
         transform: translateX(-50%); display: none; z-index: 150;
         font-family: 'Bebas Neue'; font-size: 2rem; color: #ffaa00; 
         text-shadow: 0 0 20px #ffaa00; animation: ultPulse 1s infinite;">
        ‚ö° ULTIMATE READY ‚ö°
    </div>

    <style>
        @keyframes ultPulse {

            0%,
            100% {
                opacity: 1;
                transform: translateX(-50%) scale(1);
            }

            50% {
                opacity: 0.6;
                transform: translateX(-50%) scale(1.1);
            }
        }

        /* Upgrade Activation Animations */
        @keyframes upgradeActivate {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }

            50% {
                transform: scale(1.3);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 0;
            }
        }

        .upgrade-flash {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            animation: upgradeActivate 1s ease-out forwards;
        }

        @keyframes permanentGlow {

            0%,
            100% {
                opacity: 0.6;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.1);
            }
        }


        /* Landscape Mode Enforcement for Mobile */
        @media (max-width: 768px) {
            body {
                zoom: 0.5;
                /* 50% zoom for mobile */
                -moz-transform: scale(0.5);
                -moz-transform-origin: 0 0;
            }
        }

        /* Portrait Mode Warning Overlay */
        #landscapeWarning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 99999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            padding: 2rem;
        }

        #landscapeWarning .rotate-icon {
            font-size: 5rem;
            margin-bottom: 2rem;
            animation: rotateDevice 2s ease-in-out infinite;
        }

        #landscapeWarning h2 {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            color: var(--gold);
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.6);
        }

        #landscapeWarning p {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.2rem;
            color: #aaa;
            max-width: 400px;
        }

        @keyframes rotateDevice {

            0%,
            100% {
                transform: rotate(0deg);
            }

            25% {
                transform: rotate(-90deg);
            }

            50% {
                transform: rotate(-90deg);
            }

            75% {
                transform: rotate(-90deg);
            }
        }

        /* Desktop - no zoom */
        @media (min-width: 769px) {
            body {
                zoom: 1;
            }
        }
    </style>


    <script>
        /* ===== Landscape Mode Enforcement for Mobile ===== */
        (function () {
            function checkOrientation() {
                const warning = document.getElementById('landscapeWarning');
                if (!warning) return;

                // Only enforce on mobile devices (width <= 768px)
                const isMobile = window.innerWidth <= 768 ||
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                if (isMobile) {
                    // Check if in portrait mode
                    const isPortrait = window.innerHeight > window.innerWidth;

                    if (isPortrait) {
                        // Show warning
                        warning.style.display = 'flex';

                        // Pause game if it's running
                        if (window.gameState && window.gameState.screen === 'playing') {
                            // Don't actually pause, just show overlay
                        }
                    } else {
                        // Hide warning - device is in landscape
                        warning.style.display = 'none';
                    }
                } else {
                    // Desktop - always hide warning
                    warning.style.display = 'none';
                }
            }

            // Check on load
            window.addEventListener('load', checkOrientation);

            // Check on resize
            window.addEventListener('resize', checkOrientation);

            // Check on orientation change
            window.addEventListener('orientationchange', () => {
                setTimeout(checkOrientation, 100);
            });

            // Initial check
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', checkOrientation);
            } else {
                checkOrientation();
            }
        })();
    </script>

</body>

</html>