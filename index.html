<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=0.5, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, orientation=landscape">
    <title>Bark of Survival</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Cinzel:wght@400;700&family=Rajdhani:wght@400;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --blood-red: #8B0000;
            --dark-bg: #0a0a0a;
            --wood-brown: #3d2817;
            --gold: #d4af37;
            --stone-gray: #2c2c2c;
            --danger-red: #ff3333;
            --health-green: #00ff00;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1410 100%);
            color: #fff;
            overflow: hidden;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="4" fill="rgba(212,175,55,0.6)"/></svg>') 10 10, auto;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overscroll-behavior: none;
        }

        /* Mobile stability / safe-area */
        body {
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
            overscroll-behavior: none;
        }

        #canvasWrap {
            width: 100vw;
            height: calc(var(--vh, 1vh) * 100);
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #hud {
            padding-top: calc(1rem + env(safe-area-inset-top));
            padding-left: calc(1rem + env(safe-area-inset-left));
            padding-right: calc(1rem + env(safe-area-inset-right));
        }

        #mainMenu,
        #characterSelect,
        #shop,
        #options,
        #levelUpScreen,
        #gameOverScreen,
        #victoryScreen {
            padding-top: calc(2rem + env(safe-area-inset-top));
            padding-left: calc(2rem + env(safe-area-inset-left));
            padding-right: calc(2rem + env(safe-area-inset-right));
            padding-bottom: calc(2rem + env(safe-area-inset-bottom));
        }

        /* Prevent huge UI on narrow phones */
        @media (max-width: 520px) {
            .health-bar-container {
                min-width: 220px;
            }

            .stat-box {
                min-width: 90px;
                padding: 0.4rem 0.6rem;
            }

            .stat-value {
                font-size: 1.4rem;
            }

            .xp-bar-container {
                max-width: 92vw;
            }

            .back-btn {
                top: calc(1rem + env(safe-area-inset-top));
                left: calc(1rem + env(safe-area-inset-left));
            }
        }



        #gameCanvas {
            display: block;
            background: radial-gradient(circle at 50% 50%, #1a1a1a 0%, #0a0a0a 100%);
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.8);
            image-rendering: pixelated;
        }

        /* Main Menu */
        #mainMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background:
                linear-gradient(180deg, rgba(139, 0, 0, 0.1) 0%, transparent 50%, rgba(139, 0, 0, 0.1) 100%),
                radial-gradient(circle at 30% 30%, rgba(61, 40, 23, 0.3) 0%, transparent 50%),
                #0a0a0a;
            z-index: 1000;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .game-title {
            font-family: 'Cinzel', serif;
            font-size: 4.5rem;
            font-weight: 600;
            color: #d4af37;
            text-shadow: 0 0 25px rgba(212, 175, 55, 0.4);
            letter-spacing: 0.45rem;
            margin: 0;
            text-align: center;
            line-height: 1.05;
            white-space: nowrap;
            /* desktop: keep single line */
            width: auto;
            max-width: 92vw;
            /* prevent overflow on narrow desktops */
        }

        @keyframes titleGlow {
            from {
                text-shadow: 0 0 20px rgba(212, 175, 55, 0.3), 0 5px 10px rgba(139, 0, 0, 0.6), 0 10px 30px rgba(0, 0, 0, 0.9);
            }

            to {
                text-shadow: 0 0 30px rgba(212, 175, 55, 0.6), 0 5px 10px rgba(139, 0, 0, 0.9), 0 10px 40px rgba(0, 0, 0, 1);
            }
        }

        .game-subtitle {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.5rem;
            color: #888;
            margin-bottom: 3rem;
            letter-spacing: 0.5rem;
            text-transform: uppercase;

            text-align: center;
            width: min(92vw, 520px);
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .menu-btn {
            font-family: 'Bebas Neue', cursive;
            font-size: 2rem;
            padding: 1rem 3rem;
            background: linear-gradient(135deg, var(--wood-brown) 0%, #2d1e0f 100%);
            border: 3px solid var(--gold);
            color: var(--gold);
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.2rem;
            text-transform: uppercase;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        .menu-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(212, 175, 55, 0.3), transparent);
            transition: left 0.5s;
        }

        .menu-btn:hover::before {
            left: 100%;
        }

        .menu-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(212, 175, 55, 0.4);
            border-color: #fff;
            color: #fff;
        }

        /* Character Selection */
        #characterSelect {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.95);
            z-index: 999;
            padding: 2rem;
            overflow-y: auto;
        }

        .char-select-title {
            font-family: 'Cinzel', serif;
            font-size: 3rem;
            color: var(--gold);
            text-align: center;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }

        .characters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .character-card {
            background: linear-gradient(135deg, var(--stone-gray) 0%, #1a1a1a 100%);
            border: 3px solid var(--wood-brown);
            padding: 2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .character-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 3px solid var(--gold);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .character-card:hover::after,
        .character-card.locked:hover::after {
            opacity: 0;
        }

        .character-card:not(.locked):hover::after {
            opacity: 1;
        }

        .character-card:not(.locked):hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 40px rgba(212, 175, 55, 0.4);
        }

        .character-card.locked {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .character-card.locked::before {
            content: 'üîí';
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 2rem;
            z-index: 1;
        }

        .char-name {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            color: var(--gold);
            margin-bottom: 1rem;
            text-align: center;
        }

        .char-type {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.2rem;
            color: #888;
            margin-bottom: 1rem;
            text-align: center;
            letter-spacing: 0.2rem;
        }

        .char-stats {
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid var(--gold);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        .char-description {
            font-size: 1rem;
            line-height: 1.6;
            color: #ccc;
            margin: 1rem 0;
        }

        .char-price {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.5rem;
            color: var(--gold);
            text-align: center;
            margin-top: 1rem;
        }

        .back-btn {
            position: fixed;
            top: calc(1rem + env(safe-area-inset-top));
            left: calc(1rem + env(safe-area-inset-left));
            z-index: 3000;
            font-family: 'Bebas Neue', cursive;
            font-size: 1.5rem;
            padding: 0.55rem 1.4rem;
            background: rgba(44, 44, 44, 0.95);
            border: 2px solid var(--gold);
            color: var(--gold);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .back-btn:hover {
            background: var(--wood-brown);
            transform: translateX(-5px);
        }

        /* Shop */
        #shop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.95);
            z-index: 999;
            padding: 2rem;
            overflow-y: auto;
        }

        .shop-title {
            font-family: 'Cinzel', serif;
            font-size: 3rem;
            color: var(--gold);
            text-align: center;
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }

        .currency-display {
            font-family: 'Bebas Neue', cursive;
            font-size: 2rem;
            color: var(--gold);
            text-align: center;
            margin-bottom: 2rem;
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 1rem;
            display: none;
            z-index: 100;
            pointer-events: none;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
            width: 100%;
            box-sizing: border-box;
        }

        .health-bar-container {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--gold);
            padding: 0.5rem 1rem;
            min-width: 300px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            box-sizing: border-box;
        }

        .health-label {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.2rem;
            color: var(--gold);
            margin-bottom: 0.3rem;
            letter-spacing: 0.1rem;
        }

        .health-bar {
            height: 30px;
            background: #1a1a1a;
            border: 2px solid #000;
            position: relative;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--danger-red) 0%, var(--health-green) 100%);
            transition: width 0.3s ease;
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Bebas Neue', cursive;
            font-size: 1.2rem;
            color: #fff;
            text-shadow: 0 0 5px #000;
        }

        .stats-container {
            display: flex;
            gap: 1rem;
            box-sizing: border-box;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--gold);
            padding: 0.5rem 1rem;
            text-align: center;
            min-width: 120px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            box-sizing: border-box;
        }

        .stat-label {
            font-family: 'Bebas Neue', cursive;
            font-size: 0.9rem;
            color: #888;
            letter-spacing: 0.1rem;
        }

        .stat-value {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.8rem;
            color: var(--gold);
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .xp-bar-container {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--gold);
            padding: 0.5rem 1rem;
            margin-top: 1rem;
            max-width: 500px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            box-sizing: border-box;
        }

        .xp-label {
            font-family: 'Bebas Neue', cursive;
            font-size: 1rem;
            color: var(--gold);
            margin-bottom: 0.3rem;
            letter-spacing: 0.1rem;
        }

        .xp-bar {
            height: 20px;
            background: #1a1a1a;
            border: 2px solid #000;
            position: relative;
            overflow: hidden;
        }

        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a90e2 0%, #00d4ff 100%);
            transition: width 0.3s ease;
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3);
        }

        /* Level Up */
        #levelUpScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 500;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease-in;
        }

        .levelup-container {
            background: linear-gradient(135deg, var(--stone-gray) 0%, #1a1a1a 100%);
            border: 4px solid var(--gold);
            padding: 2rem;
            max-width: 900px;
            box-shadow: 0 0 50px rgba(212, 175, 55, 0.5);
        }

        .levelup-title {
            font-family: 'Cinzel', serif;
            font-size: 3rem;
            color: var(--gold);
            text-align: center;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .upgrades-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }

        .upgrade-card {
            background: rgba(0, 0, 0, 0.5);
            border: 3px solid var(--wood-brown);
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upgrade-card.selected {
            border-color: #fff;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.8);
            transform: translateY(-5px) scale(1.02);
        }

        .upgrade-card:hover {
            border-color: var(--gold);
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(212, 175, 55, 0.3);
        }

        .upgrade-name {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            color: var(--gold);
            margin-bottom: 0.5rem;
        }

        .upgrade-description {
            font-size: 1rem;
            color: #ccc;
            line-height: 1.4;
        }

        /* Game Over */
        #gameOverScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(139, 0, 0, 0.9);
            z-index: 600;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.5s ease-in;
        }

        .gameover-container {
            text-align: center;
            background: linear-gradient(135deg, var(--stone-gray) 0%, #1a1a1a 100%);
            border: 4px solid var(--danger-red);
            padding: 3rem;
            box-shadow: 0 0 50px rgba(139, 0, 0, 0.8);
        }

        .gameover-title {
            font-family: 'Cinzel', serif;
            font-size: 4rem;
            color: var(--danger-red);
            margin-bottom: 1rem;
            text-shadow: 0 0 30px rgba(255, 51, 51, 0.8);
        }

        .gameover-stats {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.5rem;
            color: #fff;
            margin: 2rem 0;
            line-height: 2;
        }

        .gameover-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        /* Victory */
        #victoryScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 100, 0, 0.9);
            z-index: 600;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.5s ease-in;
        }

        .victory-container {
            text-align: center;
            background: linear-gradient(135deg, var(--stone-gray) 0%, #1a1a1a 100%);
            border: 4px solid var(--gold);
            padding: 3rem;
            box-shadow: 0 0 50px rgba(212, 175, 55, 0.8);
        }

        .victory-title {
            font-family: 'Cinzel', serif;
            font-size: 4rem;
            color: var(--gold);
            margin-bottom: 1rem;
            text-shadow: 0 0 30px rgba(212, 175, 55, 1);
            animation: victoryGlow 1.5s ease-in-out infinite alternate;
        }

        @keyframes victoryGlow {
            from {
                text-shadow: 0 0 30px rgba(212, 175, 55, 0.8);
            }

            to {
                text-shadow: 0 0 50px rgba(212, 175, 55, 1), 0 0 80px rgba(255, 215, 0, 0.6);
            }
        }

        @keyframes toastPulse {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.05);
            }
        }

        /* Final Boss Health Bar */
        #bossBossBar {
            display: none;
            position: fixed;
            top: 18px;
            left: 50%;
            transform: translateX(-50%);
            width: 520px;
            max-width: 90vw;
            z-index: 9998;
            pointer-events: none;
        }

        #bossBossBar .boss-bar-title {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.1rem;
            color: #ff4444;
            text-align: center;
            letter-spacing: 0.2rem;
            margin-bottom: 4px;
            text-shadow: 0 0 8px rgba(255, 60, 60, 0.7);
        }

        #bossBossBar .boss-bar-outer {
            width: 100%;
            height: 28px;
            background: #111;
            border: 2px solid #8B0000;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 0 12px rgba(180, 0, 0, 0.5), inset 0 2px 4px rgba(0, 0, 0, 0.6);
            position: relative;
        }

        #bossBossBar .boss-bar-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #6b0000 0%, #cc2200 40%, #ff4400 70%, #ff6622 100%);
            transition: width 0.25s linear;
            box-shadow: inset 0 0 14px rgba(255, 100, 50, 0.4);
        }

        #bossBossBar .boss-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Bebas Neue', cursive;
            font-size: 1rem;
            color: #fff;
            text-shadow: 0 0 6px #000, 0 0 3px #000;
            letter-spacing: 0.15rem;
            white-space: nowrap;
        }

        /* Individual warlord pips */
        #bossBossBar .boss-pips {
            display: flex;
            justify-content: center;
            gap: 6px;
            margin-top: 5px;
        }

        #bossBossBar .boss-pip {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid #8B0000;
            background: #cc2200;
            box-shadow: 0 0 6px rgba(200, 30, 0, 0.6);
            transition: background 0.3s, box-shadow 0.3s;
        }

        #bossBossBar .boss-pip.dead {
            background: #333;
            border-color: #444;
            box-shadow: none;
        }

        @keyframes bossBarPulse {

            0%,
            100% {
                box-shadow: 0 0 12px rgba(180, 0, 0, 0.5), inset 0 2px 4px rgba(0, 0, 0, 0.6);
            }

            50% {
                box-shadow: 0 0 22px rgba(220, 40, 0, 0.7), inset 0 2px 4px rgba(0, 0, 0, 0.6);
            }
        }

        /* Responsive */

        /* Stats Panel */
        #statsPanel {
            position: fixed;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--gold);
            padding: 1rem;
            max-width: 250px;
            display: none;
            z-index: 90;
            font-family: 'Rajdhani', sans-serif;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        }

        .stats-panel-title {
            font-family: 'Bebas Neue';
            color: var(--gold);
            font-size: 1.2rem;
            margin-bottom: 0.8rem;
            text-align: center;
            border-bottom: 1px solid var(--gold);
            padding-bottom: 0.5rem;
        }

        .stats-panel-item {
            display: flex;
            justify-content: space-between;
            padding: 0.3rem 0;
            font-size: 0.9rem;
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
        }

        .stats-panel-label {
            color: #aaa;
        }

        .stats-panel-value {
            color: #fff;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .game-title {
                font-size: 3.2rem;
                white-space: normal;
                width: min(92vw, 520px);
                letter-spacing: 0.25rem;
            }

            .characters-grid {
                grid-template-columns: 1fr;
            }

            .upgrades-grid {
                grid-template-columns: 1fr;
            }

            .stats-container {
                flex-direction: column;
            }

            #statsPanel {
                left: 10px;
                max-width: 200px;
                padding: 0.8rem;
            }

            .stats-panel-title {
                font-size: 1rem;
            }

            .stats-panel-item {
                font-size: 0.8rem;
            }

        }

        /* Keep animated GIF <img> elements in the DOM so browsers advance frames */
        #gifPreload {
            position: fixed;
            left: -9999px;
            top: -9999px;
            width: 1px;
            height: 1px;
            overflow: hidden;
            opacity: 0;
            pointer-events: none;
        }

        #gifPreload img {
            width: 1px;
            height: 1px;
        }


        /* DOM sprite overlay (ensures GIF animations always play) */
        #spriteOverlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 2;
        }

        .dom-sprite {
            position: absolute;
            left: 0;
            top: 0;
            transform: translate(-50%, -50%);
            image-rendering: pixelated;
            will-change: transform;
        }


        .enemy-sprite {
            filter: drop-shadow(0 0 10px rgba(180, 210, 255, 0.55));
            image-rendering: pixelated;
        }

        .enemy-sprite.boss {
            filter: drop-shadow(0 0 14px rgba(255, 80, 80, 0.55));
        }

        .dom-sprite.flip {
            transform: translate(-50%, -50%) scaleX(-1);
        }

        /* Mobile Virtual Joystick */
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            pointer-events: none;
            z-index: 200;
        }

        #joystickContainer {
            position: fixed;
            left: 0;
            top: 0;
            width: 140px;
            height: 140px;
            display: none;
            z-index: 2500;
            pointer-events: none;
        }

        #joystickBase {
            position: absolute;
            width: 140px;
            height: 140px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(212, 175, 55, 0.3) 0%, rgba(212, 175, 55, 0.1) 70%, transparent 100%);
            border: 3px solid rgba(212, 175, 55, 0.5);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 20px rgba(212, 175, 55, 0.2);
        }

        #joystickStick {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(212, 175, 55, 0.9) 0%, rgba(139, 0, 0, 0.7) 100%);
            border: 3px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7), 0 0 10px rgba(212, 175, 55, 0.8);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: none;
        }

        #joystickStick.active {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.9), 0 0 20px rgba(212, 175, 55, 1);
        }

        /* Mobile responsive adjustments */
        /* Mobile - Small phones (‚â§480px) */
        @media (max-width: 480px) {
            #mobileControls {
                display: block;
            }

            body {
                overscroll-behavior: none;
                -webkit-user-select: none;
                user-select: none;
            }

            #gameCanvas {
                touch-action: none;
            }

            /* Menu */
            .game-title {
                font-size: 1.8rem;
                letter-spacing: 0.1rem;
                margin-bottom: 0.5rem;
            }

            .game-subtitle {
                font-size: 0.8rem;
                margin-bottom: 1.5rem;
                letter-spacing: 0.3rem;
            }

            .menu-btn {
                font-size: 1rem;
                padding: 0.5rem 1.5rem;
            }

            /* Character/Shop screens */
            .char-select-title,
            .shop-title {
                font-size: 1.3rem;
                margin-bottom: 1rem;
            }

            .characters-grid {
                grid-template-columns: 1fr;
                padding: 0.5rem;
                gap: 1rem;
            }

            .character-card {
                padding: 1rem;
            }

            .char-name {
                font-size: 1.2rem;
            }

            .char-type {
                font-size: 0.9rem;
            }

            .stat-row {
                font-size: 0.85rem;
            }

            .char-description {
                font-size: 0.8rem;
                line-height: 1.4;
            }

            .char-price {
                font-size: 1rem;
            }

            /* Level up */
            .levelup-title {
                font-size: 1.5rem;
                margin-bottom: 1rem;
            }

            .upgrades-grid {
                grid-template-columns: 1fr;
                gap: 0.8rem;
            }

            .upgrade-card {
                padding: 0.8rem;
            }

            .upgrade-name {
                font-size: 1rem;
                margin-bottom: 0.3rem;
            }

            .upgrade-description {
                font-size: 0.75rem;
            }

            /* HUD */
            #hud {
                padding: 0.3rem;
            }

            .hud-top {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.3rem;
                margin-bottom: 0.3rem;
            }

            .health-bar-container {
                min-width: 100%;
                max-width: 100%;
                padding: 0.3rem 0.5rem;
            }

            .health-label {
                font-size: 0.8rem;
                margin-bottom: 0.2rem;
            }

            .health-bar {
                height: 20px;
            }

            .health-text {
                font-size: 0.9rem;
            }

            .stats-container {
                flex-direction: row;
                width: 100%;
                justify-content: space-between;
                gap: 0.3rem;
                box-sizing: border-box;
                max-width: 100%;
            }

            .stat-box {
                min-width: 0;
                flex: 1;
                padding: 0.3rem 0.4rem;
                box-sizing: border-box;
                overflow: hidden;
            }

            .stat-label {
                font-size: 0.65rem;
            }

            .stat-value {
                font-size: 1.1rem;
            }

            .xp-bar-container {
                max-width: 100%;
                width: 100%;
                padding: 0.3rem 0.5rem;
                margin-top: 0.3rem;
                box-sizing: border-box;
            }

            .xp-label {
                font-size: 0.7rem;
            }

            .xp-bar {
                height: 15px;
            }

            /* Game Over/Victory */
            .gameover-title,
            .victory-title {
                font-size: 2rem;
            }

            .gameover-stats {
                font-size: 1rem;
                line-height: 1.8;
                margin: 1rem 0;
            }

            .gameover-container,
            .victory-container {
                padding: 1.5rem;
            }

            /* Joystick */
            #joystickContainer {
                width: 100px;
                height: 100px;
                bottom: 10px;
                left: 10px;
            }

            #joystickBase {
                width: 100px;
                height: 100px;
            }

            #joystickStick {
                width: 45px;
                height: 45px;
            }

            /* Back button */
            .back-btn {
                font-size: 1rem;
                padding: 0.3rem 1rem;
            }
        }

        /* Tablet - Medium screens (481px - 768px) */
        @media (min-width: 481px) and (max-width: 768px) {
            #mobileControls {
                display: block;
            }

            body {
                overscroll-behavior: none;
                -webkit-user-select: none;
                user-select: none;
            }

            #gameCanvas {
                touch-action: none;
            }

            /* Menu */
            .game-title {
                font-size: 2.5rem;
                letter-spacing: 0.15rem;
            }

            .game-subtitle {
                font-size: 1rem;
                margin-bottom: 2rem;
            }

            .menu-btn {
                font-size: 1.3rem;
                padding: 0.6rem 2rem;
            }

            /* Character/Shop */
            .char-select-title,
            .shop-title {
                font-size: 1.8rem;
            }

            .characters-grid {
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: 1.5rem;
            }

            .character-card {
                padding: 1.3rem;
            }

            .char-name {
                font-size: 1.4rem;
            }

            /* Level up */
            .levelup-title {
                font-size: 1.8rem;
            }

            .upgrades-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .upgrade-card {
                padding: 1rem;
            }

            /* HUD */
            #hud {
                padding: 0.4rem;
            }

            .hud-top {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.4rem;
            }

            .health-bar-container {
                min-width: 100%;
                max-width: 100%;
                width: 100%;
                box-sizing: border-box;
            }

            .stats-container {
                flex-direction: row;
                width: 100%;
                max-width: 100%;
                justify-content: space-between;
                gap: 0.5rem;
                box-sizing: border-box;
            }

            .stat-box {
                min-width: 0;
                flex: 1;
                box-sizing: border-box;
            }

            /* Joystick */
            #joystickContainer {
                width: 120px;
                height: 120px;
                bottom: 15px;
                left: 15px;
            }

            #joystickBase {
                width: 120px;
                height: 120px;
            }

            #joystickStick {
                width: 50px;
                height: 50px;
            }
        }

        /* Laptop - Medium-large screens (769px - 1366px) */
        @media (min-width: 769px) and (max-width: 1366px) {

            /* Slightly smaller than desktop but maintain readability */
            .game-title {
                font-size: 4rem;
            }

            .game-subtitle {
                font-size: 1.3rem;
            }

            .menu-btn {
                font-size: 1.7rem;
                padding: 0.9rem 2.5rem;
            }

            .char-select-title,
            .shop-title {
                font-size: 2.5rem;
            }

            .character-card {
                padding: 1.8rem;
            }

            .char-name {
                font-size: 1.8rem;
            }

            .levelup-title {
                font-size: 2.5rem;
            }

            .upgrade-name {
                font-size: 1.3rem;
            }

            /* HUD adjustments for laptop */
            .health-bar-container {
                min-width: 280px;
            }

            .stat-box {
                min-width: 110px;
            }

            .stat-value {
                font-size: 1.6rem;
            }

            .xp-bar-container {
                max-width: 450px;
            }
        }

        /* Desktop - Large screens (>1366px) */
        /* Default styles are for desktop, no media query needed */
        /* All original sizes remain unchanged */

        /* Prevent text selection on mobile */
        * {
            -webkit-tap-highlight-color: transparent;
        }

        /* --- Mobile/Tablet UI fixes (does NOT affect desktop) --- */
        @media (max-width: 900px) {

            /* Keep panels clear of the back button */
            #shop,
            #characterSelect,
            #options {
                padding-top: calc(6.25rem + env(safe-area-inset-top));
            }

            /* In-game HUD order: Health -> XP -> Timer/Level/Kills */
            #hud {
                left: 50%;
                top: calc(1rem + env(safe-area-inset-top));
                transform: translateX(-50%);
                width: min(520px, calc(100vw - 2rem - env(safe-area-inset-left) - env(safe-area-inset-right)));
            }

            .hud-top {
                display: contents;
            }

            .health-bar-container {
                grid-area: health;
            }

            .xp-bar-container {
                grid-area: xp;
            }

            .stats-container {
                grid-area: stats;
            }

            #hud {
                display: grid !important;
                grid-template-areas:
                    "health"
                    "xp"
                    "stats";
                gap: 0.75rem;
            }

            .stats-container {
                width: 100%;
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 0.6rem;
            }

            /* Defeated UI polish */
            #gameOverScreen .game-over-content,
            #victoryScreen .game-over-content {
                width: min(420px, calc(100vw - 2rem));
                margin: 0 auto;
                padding: 0 0.75rem;
            }

            #gameOverScreen .game-over-title {
                font-size: 3rem;
                letter-spacing: 0.08em;
            }
        }

        /* Tablet tuning */
        @media (min-width: 901px) and (max-width: 1200px) {
            #hud {
                left: 1.25rem;
                top: 1.25rem;
                width: 520px;
            }
        }

        /* Upgrade Activation Animations */
        @keyframes upgradeActivate {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }

            50% {
                transform: scale(1.3);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 0;
            }
        }

        .upgrade-flash {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            animation: upgradeActivate 1s ease-out forwards;
        }

        @keyframes permanentGlow {

            0%,
            100% {
                opacity: 0.6;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.1);
            }
        }


        /* Landscape Mode Enforcement for Mobile */
        @media (max-width: 768px) {
            body {
                zoom: 0.5;
                /* 50% zoom for mobile */
                -moz-transform: scale(0.5);
                -moz-transform-origin: 0 0;
            }
        }

        /* Portrait Mode Warning Overlay */
        #landscapeWarning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 99999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            padding: 2rem;
        }

        #landscapeWarning .rotate-icon {
            font-size: 5rem;
            margin-bottom: 2rem;
            animation: rotateDevice 2s ease-in-out infinite;
        }

        #landscapeWarning h2 {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            color: var(--gold);
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.6);
        }

        #landscapeWarning p {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.2rem;
            color: #aaa;
            max-width: 400px;
        }

        @keyframes rotateDevice {

            0%,
            100% {
                transform: rotate(0deg);
            }

            25% {
                transform: rotate(-90deg);
            }

            50% {
                transform: rotate(-90deg);
            }

            75% {
                transform: rotate(-90deg);
            }
        }

        /* Desktop - no zoom */
        @media (min-width: 769px) {
            body {
                zoom: 1;
            }
        }
    </style>
</head>

<body>

    <!-- Landscape Mode Warning (Mobile Only) -->
    <div id="landscapeWarning">
        <div class="rotate-icon">üì± ‚Üª</div>
        <h2>ROTATE YOUR DEVICE</h2>
        <p>Please rotate your device to landscape mode for the best gaming experience.</p>
    </div>

    <div id="gifPreload" aria-hidden="true"></div>

    <!-- Stats Panel -->
    <div id="statsPanel">
        <div class="stats-panel-title">CURRENT STATS</div>
        <div class="stats-panel-item">
            <span class="stats-panel-label">Damage:</span>
            <span class="stats-panel-value" id="statDamage">0</span>
        </div>
        <div class="stats-panel-item">
            <span class="stats-panel-label">Attack Speed:</span>
            <span class="stats-panel-value" id="statAttackSpeed">0</span>
        </div>
        <div class="stats-panel-item">
            <span class="stats-panel-label">Move Speed:</span>
            <span class="stats-panel-value" id="statMoveSpeed">0</span>
        </div>
        <div class="stats-panel-item">
            <span class="stats-panel-label">Crit Chance:</span>
            <span class="stats-panel-value" id="statCritChance">0%</span>
        </div>
        <div class="stats-panel-item">
            <span class="stats-panel-label">Max HP:</span>
            <span class="stats-panel-value" id="statMaxHP">0</span>
        </div>
        <div class="stats-panel-item">
            <span class="stats-panel-label">Defense:</span>
            <span class="stats-panel-value" id="statDefense">0</span>
        </div>
        <div class="stats-panel-item">
            <span class="stats-panel-label">XP Mult:</span>
            <span class="stats-panel-value" id="statXPMult">1x</span>
        </div>
        <div class="stats-panel-item">
            <span class="stats-panel-label">Dodge:</span>
            <span class="stats-panel-value" id="statDodge">0%</span>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="mainMenu">
        <h1 class="game-title">BARK OF SURVIVAL</h1>
        <p class="game-subtitle">Fight ‚Ä¢ Survive ‚Ä¢ Evolve</p>
        <div class="menu-buttons">
            <button class="menu-btn" onclick="showCharacterSelect()">Start Game</button>
            <button class="menu-btn" onclick="showShop()">Shop</button>
            <button class="menu-btn" onclick="showAchievementsScreen()">Achievements</button>
            <button class="menu-btn" onclick="showOptions()">Options</button>
        </div>
    </div>

    <!-- Character Selection -->
    <div id="characterSelect">
        <button class="back-btn" onclick="backToMenu()">‚Üê Back</button>
        <h2 class="char-select-title">Choose Your Survivor</h2>
        <div class="characters-grid">
            <div class="character-card" onclick="selectCharacter(0)">
                <h3 class="char-name">Rex</h3>
                <p class="char-type">The Brawler</p>
                <div class="char-stats">
                    <div class="stat-row">
                        <span>Range:</span>
                        <span>‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Speed:</span>
                        <span>‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Damage:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Attack Rate:</span>
                        <span>‚≠ê‚≠ê‚≠ê</span>
                    </div>
                </div>
                <p class="char-description">
                    A close-combat specialist who delivers devastating punches. High damage at short range, perfect for
                    aggressive players who like to get up close and personal.
                </p>
                <p class="char-price">Available</p>
            </div>

            <div class="character-card locked" id="archerCard">
                <h3 class="char-name">Luna</h3>
                <p class="char-type">The Ranger</p>
                <div class="char-stats">
                    <div class="stat-row">
                        <span>Range:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Speed:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Damage:</span>
                        <span>‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Attack Rate:</span>
                        <span>‚≠ê‚≠ê‚≠ê</span>
                    </div>
                </div>
                <p class="char-description">
                    A skilled archer with exceptional range. Fires arrows that pierce through enemies. Ideal for players
                    who prefer keeping their distance.
                </p>
                <p class="char-price">Cost: 500 Bones</p>
            </div>

            <div class="character-card locked" id="swordCard">
                <h3 class="char-name">Blade</h3>
                <p class="char-type">The Swordsman</p>
                <div class="char-stats">
                    <div class="stat-row">
                        <span>Range:</span>
                        <span>‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Speed:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Damage:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Attack Rate:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                </div>
                <p class="char-description">
                    A lightning-fast swordsman with balanced range and high attack speed. Slices through enemies with
                    rapid strikes. For skilled players who value precision.
                </p>
                <p class="char-price">Cost: 1000 Bones</p>
            </div>
        </div>
    </div>

    <!-- Shop -->
    <div id="shop">
        <button class="back-btn" onclick="backToMenu()">‚Üê Back</button>
        <h2 class="shop-title">Survivor's Shop</h2>
        <div class="currency-display">Bones: <span id="shopCurrency">0</span></div>
        <div class="characters-grid">
            <div class="character-card locked" id="shopArcherCard">
                <h3 class="char-name">Luna</h3>
                <p class="char-type">The Ranger</p>
                <div class="char-stats">
                    <div class="stat-row">
                        <span>Range:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Speed:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Damage:</span>
                        <span>‚≠ê‚≠ê‚≠ê</span>
                    </div>
                </div>
                <p class="char-description">
                    A skilled archer with exceptional range. Fires arrows that pierce through enemies.
                </p>
                <p class="char-price">Cost: 500 Bones</p>
                <button class="menu-btn" style="width: 100%; margin-top: 1rem; font-size: 1.5rem; padding: 0.5rem;"
                    onclick="buyCharacter(1, 500)">Purchase</button>
            </div>

            <div class="character-card locked" id="shopSwordCard">
                <h3 class="char-name">Blade</h3>
                <p class="char-type">The Swordsman</p>
                <div class="char-stats">
                    <div class="stat-row">
                        <span>Range:</span>
                        <span>‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Speed:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                    <div class="stat-row">
                        <span>Damage:</span>
                        <span>‚≠ê‚≠ê‚≠ê‚≠ê</span>
                    </div>
                </div>
                <p class="char-description">
                    A lightning-fast swordsman with balanced range and high attack speed.
                </p>
                <p class="char-price">Cost: 1000 Bones</p>
                <button class="menu-btn" style="width: 100%; margin-top: 1rem; font-size: 1.5rem; padding: 0.5rem;"
                    onclick="buyCharacter(2, 1000)">Purchase</button>
            </div>

            <!-- Permanent Upgrades Section -->
            <div class="character-card" id="shopHealthUpgrade"
                style="background: linear-gradient(135deg, #1a4d1a 0%, #0d260d 100%);">
                <h3 class="char-name">Health Boost</h3>
                <p class="char-type">Permanent Upgrade</p>
                <p class="char-description">
                    Start each run with +10 Max Health. Stacks with each purchase.
                </p>
                <p class="char-price">Cost: <span id="healthUpgradeCost">200</span> Bones</p>
                <button class="menu-btn" style="width: 100%; margin-top: 1rem; font-size: 1.5rem; padding: 0.5rem;"
                    onclick="buyPermanentUpgrade('health', 200)">Purchase</button>
            </div>

            <div class="character-card" id="shopDamageUpgrade"
                style="background: linear-gradient(135deg, #4d1a1a 0%, #260d0d 100%);">
                <h3 class="char-name">Power Surge</h3>
                <p class="char-type">Permanent Upgrade</p>
                <p class="char-description">
                    Start each run with +3 Base Damage. Stacks with each purchase.
                </p>
                <p class="char-price">Cost: <span id="damageUpgradeCost">300</span> Bones</p>
                <button class="menu-btn" style="width: 100%; margin-top: 1rem; font-size: 1.5rem; padding: 0.5rem;"
                    onclick="buyPermanentUpgrade('damage', 300)">Purchase</button>
            </div>

            <div class="character-card" id="shopSpeedUpgrade"
                style="background: linear-gradient(135deg, #1a1a4d 0%, #0d0d26 100%);">
                <h3 class="char-name">Swift Feet</h3>
                <p class="char-type">Permanent Upgrade</p>
                <p class="char-description">
                    Start each run with +5% Movement Speed. Stacks with each purchase.
                </p>
                <p class="char-price">Cost: <span id="speedUpgradeCost">250</span> Bones</p>
                <button class="menu-btn" style="width: 100%; margin-top: 1rem; font-size: 1.5rem; padding: 0.5rem;"
                    onclick="buyPermanentUpgrade('speed', 250)">Purchase</button>
            </div>

            <div class="character-card" id="shopXPUpgrade"
                style="background: linear-gradient(135deg, #4d4d1a 0%, #26260d 100%);">
                <h3 class="char-name">Wisdom</h3>
                <p class="char-type">Permanent Upgrade</p>
                <p class="char-description">
                    Gain +10% more XP from all sources. Stacks with each purchase.
                </p>
                <p class="char-price">Cost: <span id="xpUpgradeCost">400</span> Bones</p>
                <button class="menu-btn" style="width: 100%; margin-top: 1rem; font-size: 1.5rem; padding: 0.5rem;"
                    onclick="buyPermanentUpgrade('xp', 400)">Purchase</button>
            </div>
        </div>
    </div>

    <!-- Achievements Screen -->
    <div id="achievementsScreen"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10,10,10,0.97); z-index: 1001; padding: 2rem; overflow-y: auto;">
        <button class="back-btn" onclick="hideAchievementsScreen()">‚Üê Back</button>
        <h2 class="shop-title" style="color: var(--gold); text-align: center; margin-bottom: 2rem;">ACHIEVEMENTS</h2>
        <div class="achievements-grid" id="achievementsGrid"></div>
    </div>

    <!-- Options Screen -->
    <div id="options"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10,10,10,0.95); z-index: 999; padding: 2rem; overflow-y: auto;">
        <button class="back-btn" onclick="backToMenu()">‚Üê Back</button>
        <h2 class="shop-title">Options</h2>

        <div style="max-width: 800px; margin: 2rem auto; display: flex; flex-direction: column; gap: 2rem;">


            <!-- Audio -->
            <div class="character-card" style="background: linear-gradient(135deg, #1a2a2a 0%, #0e1414 100%);">
                <h3 class="char-name">Audio</h3>
                <p class="char-description">Toggle background music and sound effects.</p>
                <div style="display:flex; gap:12px; flex-wrap:wrap; margin-top:12px;">
                    <button id="musicToggleBtn" class="menu-btn" style="min-width:160px;" onclick="toggleMusic()">Music:
                        ON</button>
                    <button id="sfxToggleBtn" class="menu-btn" style="min-width:160px;" onclick="toggleSfx()">SFX:
                        ON</button>
                </div>
            </div>

            <!-- Game Info -->
            <div class="character-card" style="background: linear-gradient(135deg, #2c2c2c 0%, #1a1a1a 100%);">
                <h3 class="char-name">Game Information</h3>
                <div class="char-stats">
                    <div class="stat-row">
                        <span>Total Bones:</span>
                        <span id="optionsCurrency" style="color: var(--gold);">0</span>
                    </div>
                    <div class="stat-row">
                        <span>Characters Unlocked:</span>
                        <span id="optionsCharacters" style="color: var(--gold);">1/3</span>
                    </div>
                    <div class="stat-row">
                        <span>Permanent Upgrades:</span>
                        <span id="optionsUpgrades" style="color: var(--gold);">0</span>
                    </div>
                </div>
            </div>

            <!-- Danger Zone -->
            <div class="character-card"
                style="background: linear-gradient(135deg, #4d1a1a 0%, #260d0d 100%); border-color: var(--danger-red);">
                <h3 class="char-name" style="color: var(--danger-red);">‚ö† Danger Zone</h3>
                <p class="char-description" style="margin: 1rem 0;">
                    <strong>Warning:</strong> This will permanently delete ALL progress including:
                </p>
                <ul style="list-style: none; padding: 0; margin: 1rem 0; color: #ccc;">
                    <li>‚Ä¢ All Bones (currency)</li>
                    <li>‚Ä¢ Unlocked Characters (Luna & Blade)</li>
                    <li>‚Ä¢ All Permanent Upgrades</li>
                    <li>‚Ä¢ All game progress</li>
                </ul>
                <p class="char-description" style="margin: 1rem 0; color: var(--danger-red);">
                    This action <strong>CANNOT</strong> be undone!
                </p>
                <button class="menu-btn"
                    style="width: 100%; margin-top: 1rem; font-size: 1.5rem; padding: 0.5rem; background: linear-gradient(135deg, var(--danger-red) 0%, #8B0000 100%); border-color: var(--danger-red);"
                    onclick="confirmResetGame()">
                    Reset Entire Game
                </button>
            </div>

            <!-- Credits -->
            <div class="character-card" style="background: linear-gradient(135deg, #1a1a4d 0%, #0d0d26 100%);">
                <h3 class="char-name">About</h3>
                <p class="char-description">
                    <strong>Bark of Survival</strong><br>
                    A roguelike survival game where you fight endless waves of ghosts.<br><br>
                    Survive, upgrade, and evolve to become the ultimate survivor!
                </p>
            </div>

        </div>
    </div>

    <!-- Game Canvas -->
    <div id="canvasWrap" style="position:relative; width:100%; height:100%;">
        <canvas id="gameCanvas"></canvas>
        <div id="spriteOverlay"></div>
    </div>

    <!-- Mobile Controls -->
    <div id="mobileControls">
        <div id="joystickContainer">
            <div id="joystickBase"></div>
            <div id="joystickStick"></div>
        </div>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-top">
            <div class="health-bar-container">
                <div class="health-label">HEALTH</div>
                <div class="health-bar">
                    <div class="health-fill" id="healthFill"></div>
                    <div class="health-text" id="healthText">100/100</div>
                </div>
            </div>
            <div class="stats-container">
                <div class="stat-box">
                    <div class="stat-label">TIMER</div>
                    <div class="stat-value" id="timerValue">5:00</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">LEVEL</div>
                    <div class="stat-value" id="levelValue">1</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">KILLS</div>
                    <div class="stat-value" id="killsValue">0</div>
                </div>
            </div>
        </div>
        <div class="xp-bar-container">
            <div class="xp-label">EXPERIENCE</div>
            <div class="xp-bar">
                <div class="xp-fill" id="xpFill"></div>
            </div>
        </div>
    </div>

    <!-- Final Boss Health Bar (visible only during final boss phase) -->
    <div id="bossBossBar">
        <div class="boss-bar-title">üî• DEMON WARLORDS üî•</div>
        <div class="boss-bar-outer">
            <div class="boss-bar-fill" id="bossFill"></div>
            <div class="boss-bar-text" id="bossBarText">100,000 / 100,000</div>
        </div>
        <div class="boss-pips">
            <div class="boss-pip" id="bossPip0"></div>
            <div class="boss-pip" id="bossPip1"></div>
            <div class="boss-pip" id="bossPip2"></div>
            <div class="boss-pip" id="bossPip3"></div>
            <div class="boss-pip" id="bossPip4"></div>
        </div>
    </div>

    <!-- Level Up Screen -->
    <div id="levelUpScreen">
        <div class="levelup-container">
            <h2 class="levelup-title">LEVEL UP!</h2>
            <div class="upgrades-grid" id="upgradesGrid"></div>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen">
        <div class="gameover-container">
            <h2 class="gameover-title">DEFEATED</h2>
            <div class="gameover-stats">
                <div>Time Survived: <span id="finalTime">0:00</span></div>
                <div>Enemies Slain: <span id="finalKills">0</span></div>
                <div>Level Reached: <span id="finalLevel">1</span></div>
                <div>Bones Earned: <span id="bonesEarned">0</span></div>
            </div>
            <div class="gameover-buttons">
                <button class="menu-btn" onclick="restartGame()">Try Again</button>
                <button class="menu-btn" onclick="backToMenu()">Main Menu</button>
            </div>
        </div>
    </div>

    <!-- Victory Screen -->
    <div id="victoryScreen">
        <div class="victory-container">
            <h2 class="victory-title">VICTORY!</h2>
            <div class="gameover-stats">
                <div>You Survived!</div>
                <div>Enemies Slain: <span id="victoryKills">0</span></div>
                <div>Level Reached: <span id="victoryLevel">1</span></div>
                <div>Bones Earned: <span id="victoryBones">0</span></div>
            </div>
            <div class="gameover-buttons">
                <button class="menu-btn" onclick="restartGame()">Play Again</button>
                <button class="menu-btn" onclick="backToMenu()">Main Menu</button>
            </div>
        </div>
    </div>

    <script>
        // All Effect Arrays (must be at top for global scope)
        const bossFireballs = [];
        const ultimateEffects = [];
        const slashEffects = [];
        const explosionEffects = [];
        const burnEffects = [];
        const frostHitEffects = [];

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        // Tileset world (open-world feel)
        const TILESET_PATH = 'Tiles/tile_set.png'; // from your tileset tester
        const TILE_SIZE = 32;   // source tile size (px in atlas)
        const TILE_SCALE = 2;   // draw scale (pixel-art upscale)
        const TILE_PX = TILE_SIZE * TILE_SCALE;

        const MAP_W = 140;
        const MAP_H = 140;

        // Tile indices (linear index into atlas). Tweak these to make the map look good.
        let FLOOR_TILE = 6;         // main ground tile index
        let FLOOR_VARIANTS = [6, 6, 6, 7, 7, 5, 5];// weighted variants (edit as you like)
        let WALL_TILE = 1;                   // border/wall tile index
        let DECOR_TILES = [9, 10];   // occasional decor tiles

        // Procedural map generator (visual only; no collision yet)
        function regenMap(seed = Math.random() * 999999) {
            // --- Patch noise helpers (fast, deterministic; creates clustered ‚Äúblobs‚Äù)
            // (this replaces per-cell randomness that caused a checker/speckle look)
            function hash2(ix, iy) {
                // deterministic pseudo-random 0..1 from int coords (+seed)
                let n = (ix * 374761393 + iy * 668265263) ^ (ix * iy);
                n = (n ^ (n >> 13)) * 1274126177;
                n = (n ^ (n >> 16)) >>> 0;
                // mix seed
                n = (n + (seed | 0)) >>> 0;
                return n / 4294967295;
            }
            const smoothstep = (t) => t * t * (3 - 2 * t);
            const lerp = (a, b, t) => a + (b - a) * t;

            // Value noise sampled on a coarse grid; larger cell => bigger patches.
            function valueNoise(x, y, cellSize = 14) {
                const gx = Math.floor(x / cellSize), gy = Math.floor(y / cellSize);
                const fx = (x / cellSize) - gx, fy = (y / cellSize) - gy;

                const v00 = hash2(gx, gy);
                const v10 = hash2(gx + 1, gy);
                const v01 = hash2(gx, gy + 1);
                const v11 = hash2(gx + 1, gy + 1);

                const sx = smoothstep(fx), sy = smoothstep(fy);
                const ix0 = lerp(v00, v10, sx);
                const ix1 = lerp(v01, v11, sx);
                return lerp(ix0, ix1, sy);
            }

            // Dedupe variants so thresholds map to distinct tiles
            const uniqVariants = Array.from(new Set([FLOOR_TILE, ...(FLOOR_VARIANTS || [])]))
                .filter(v => Number.isFinite(v) && v >= 0);
            const alt1 = uniqVariants[1] ?? FLOOR_TILE;
            const alt2 = uniqVariants[2] ?? alt1;
            const alt3 = uniqVariants[3] ?? alt2;

            // Style knobs
            const PATCH_SIZE = 32;      // 10‚Äì18 feels good
            const DECOR_RATE = 0.008;   // 1.2% decor density
            for (let y = 0; y < MAP_H; y++) {
                for (let x = 0; x < MAP_W; x++) {
                    // solid border
                    if (x === 0 || y === 0 || x === MAP_W - 1 || y === MAP_H - 1) { map[y][x] = WALL_TILE; continue; }

                    // Clustered floor variants (patches instead of per-cell randomness)
                    const n = valueNoise(x, y, PATCH_SIZE);

                    // Big patches of alt1, smaller patches of alt2, rare accents alt3
                    let t = FLOOR_TILE;
                    if (n > 0.78) t = alt1;
                    if (n > 0.88) t = alt2;
                    if (n > 0.95) t = alt3;

                    // Sprinkle decor: only on mid-tone areas so it doesn't overwhelm
                    if (DECOR_TILES.length) {
                        const d = hash2(x * 19, y * 19);
                        if (d < DECOR_RATE && n > 0.35 && n < 0.75) {
                            t = DECOR_TILES[Math.floor(hash2(x + 111, y + 111) * DECOR_TILES.length)];
                        }
                    }

                    map[y][x] = t;
                }
            }
        }

        // Initialize empty map first, then generate
        const map = Array.from({ length: MAP_H }, () => Array.from({ length: MAP_W }, () => FLOOR_TILE));
        regenMap();

        const WORLD = { w: MAP_W * TILE_PX, h: MAP_H * TILE_PX };
        const camera = { x: WORLD.w / 2, y: WORLD.h / 2 };

        const tileset = new Image();
        tileset.decoding = 'async';
        let tilesetReady = false;
        let tilesPerRow = 1;

        tileset.onload = () => {
            tilesetReady = true;
            tilesPerRow = Math.max(1, Math.floor(tileset.naturalWidth / TILE_SIZE));
        };
        tileset.onerror = () => {
            tilesetReady = false;
            console.warn('Tileset failed to load:', TILESET_PATH);
        };
        tileset.src = TILESET_PATH;

        const CAMERA_LERP = 0.12; // lower = smoother (more floaty)
        const TIME_SCALE = 0.80;  // global pacing (lower = slower) - CONSTANT, never modify!
        Object.freeze({ TIME_SCALE }); // Ensure it cannot be changed

        function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

        // Mobile-only play boundary to prevent viewport/DOM jitter when traveling too far
        const MOBILE_PLAY_BOUNDS = { w: 1000, h: 1000 }; // in world pixels
        let IS_MOBILE = window.matchMedia('(max-width: 600px)').matches;

        function updateDeviceFlags() {
            IS_MOBILE = window.matchMedia('(max-width: 600px)').matches;
        }
        window.addEventListener('resize', updateDeviceFlags, { passive: true });

        function getPlayBounds() {
            // Default: whole world
            let minX = 0, minY = 0, maxX = WORLD.w, maxY = WORLD.h;

            // Mobile: constrain to a centered box
            if (IS_MOBILE) {
                const bw = Math.min(MOBILE_PLAY_BOUNDS.w, WORLD.w);
                const bh = Math.min(MOBILE_PLAY_BOUNDS.h, WORLD.h);
                minX = (WORLD.w - bw) / 2;
                minY = (WORLD.h - bh) / 2;
                maxX = minX + bw;
                maxY = minY + bh;
            }
            return { minX, minY, maxX, maxY };
        }

        function clampCameraToBounds() {
            const b = getPlayBounds();

            // Clamp camera so the viewport stays within bounds.
            // If bounds are smaller than the viewport, lock camera to bounds center.
            const halfW = canvas.width / 2;
            const halfH = canvas.height / 2;

            const minCamX = b.minX + halfW;
            const maxCamX = b.maxX - halfW;
            const minCamY = b.minY + halfH;
            const maxCamY = b.maxY - halfH;

            if (minCamX > maxCamX) camera.x = (b.minX + b.maxX) / 2;
            else camera.x = clamp(camera.x, minCamX, maxCamX);

            if (minCamY > maxCamY) camera.y = (b.minY + b.maxY) / 2;
            else camera.y = clamp(camera.y, minCamY, maxCamY);
        }

        // Tileset helper
        function tileToSrc(tileIndex) {
            const sx = (tileIndex % tilesPerRow) * TILE_SIZE;
            const sy = Math.floor(tileIndex / tilesPerRow) * TILE_SIZE;
            return { sx, sy };
        }

        // Draw visible world tiles (called every frame)
        function drawTiles() {
            // View bounds in world coords
            const left = camera.x - canvas.width / 2;
            const top = camera.y - canvas.height / 2;

            const startTx = Math.max(0, Math.floor(left / TILE_PX) - 1);
            const startTy = Math.max(0, Math.floor(top / TILE_PX) - 1);
            const endTx = Math.min(MAP_W - 1, Math.floor((left + canvas.width) / TILE_PX) + 1);
            const endTy = Math.min(MAP_H - 1, Math.floor((top + canvas.height) / TILE_PX) + 1);

            for (let ty = startTy; ty <= endTy; ty++) {
                for (let tx = startTx; tx <= endTx; tx++) {
                    const tileIndex = map[ty][tx] ?? 0;
                    const wx = tx * TILE_PX;
                    const wy = ty * TILE_PX;

                    if (tilesetReady) {
                        const { sx, sy } = tileToSrc(tileIndex);
                        ctx.drawImage(
                            tileset,
                            sx, sy, TILE_SIZE, TILE_SIZE,
                            wx, wy, TILE_PX, TILE_PX
                        );
                    } else {
                        // fallback: dark checker
                        const isDark = ((tx + ty) % 2) === 0;
                        ctx.fillStyle = isDark ? '#0a0a0a' : '#0c0c0c';
                        ctx.fillRect(wx, wy, TILE_PX, TILE_PX);
                    }
                }
            }

            // soft vignette (screen-space) - draw after resetting transform elsewhere
        }


        // --- DOM sprite overlay (fixes GIFs freezing in canvas for some characters) ---

        const ENEMY_SPRITES = {
            normal: {
                walk: 'assets/walk_4.gif',
                hurt: 'assets/hurt_4.gif',
                dead: 'assets/dead_4.gif'
            },
            boss: {
                walk: 'assets/walk_5.gif',
                // boss only has one sprite provided; reuse walk for all states
                hurt: 'assets/walk_5.gif',
                dead: 'assets/walk_5.gif'
            }
        };

        const USE_DOM_SPRITES = true;
        const spriteOverlay = document.getElementById('spriteOverlay');
        let playerDomImg = null;

        function ensurePlayerDomImg() {
            if (playerDomImg) return playerDomImg;
            playerDomImg = document.createElement('img');
            playerDomImg.className = 'dom-sprite';
            playerDomImg.alt = 'player';
            // keep it ‚Äúvisible‚Äù for GIF frame advancement
            playerDomImg.decoding = 'async';
            playerDomImg.loading = 'eager';
            spriteOverlay && spriteOverlay.appendChild(playerDomImg);
            return playerDomImg;
        }

        function setPlayerDomSprite(src, x, y, w, h, facingRight, bobY) {
            if (!USE_DOM_SPRITES || !spriteOverlay) return;
            const el = ensurePlayerDomImg();
            if (!el) return;
            if (src && el.src !== src) el.src = src;
            el.style.width = Math.max(1, w) + 'px';
            el.style.height = Math.max(1, h) + 'px';
            const flip = facingRight ? 1 : -1;
            // position in SCREEN coords (camera already applied)
            el.style.left = x + 'px';
            el.style.top = (y + (bobY || 0)) + 'px';
            el.style.transform = `translate(-50%, -50%) scaleX(${flip})`;
        }

        function hidePlayerDomSprite() {
            if (playerDomImg) playerDomImg.style.width = '0px';
        }

        // Enemy DOM sprites (ghosts)
        const enemyDomImgs = new Map(); // id -> <img>
        function ensureEnemyDomImg(enemy) {
            if (!USE_DOM_SPRITES || !spriteOverlay) return null;
            if (!enemy.id) enemy.id = 'e' + Math.random().toString(16).slice(2);
            if (enemyDomImgs.has(enemy.id)) return enemyDomImgs.get(enemy.id);
            const img = document.createElement('img');
            img.className = 'dom-sprite enemy-sprite';
            img.style.left = '0px';
            img.style.top = '0px';
            img.style.width = '0px';
            img.style.height = '0px';
            img.style.transform = 'translate(-50%, -50%)';
            spriteOverlay.appendChild(img);
            enemyDomImgs.set(enemy.id, img);
            return img;
        }
        function removeEnemyDomImg(enemy) {
            if (!enemy || !enemy.id) return;
            const el = enemyDomImgs.get(enemy.id);
            if (el) el.remove();
            enemyDomImgs.delete(enemy.id);
        }
        function setEnemyDomSprite(enemy, src, screenX, screenY, sizePx = 64, opacity = 1) {
            if (!USE_DOM_SPRITES || !spriteOverlay) return;
            const el = ensureEnemyDomImg(enemy);
            if (!el) return;
            if (el.dataset.src !== src) {
                el.dataset.src = src;
                el.src = src + (src.includes('?') ? '&' : '?') + 'v=' + Date.now(); // bust cache for gif frame resets
            }
            el.style.width = sizePx + 'px';
            el.style.height = sizePx + 'px';
            el.style.left = screenX + 'px';
            el.style.top = screenY + 'px';
            el.style.opacity = opacity;

            // Flip sprite to face the player
            const scaleX = enemy.facingRight ? 1 : -1;
            el.style.transform = `translate(-50%, -50%) scaleX(${scaleX})`;
        }
        function removeEnemyAtIndex(arr, idx) {
            const e = arr[idx];
            removeEnemyDomImg(e);
            arr.splice(idx, 1);
        }

        function clearDomSprites() {
            // Clear any lingering DOM sprite overlays between runs (prevents "stuck" ghosts / player sprites)
            try {
                if (playerDomImg) {
                    playerDomImg.remove();
                    playerDomImg = null;
                }
                enemyDomImgs.forEach((img) => { try { img.remove(); } catch (e) { } });
                enemyDomImgs.clear();
                if (spriteOverlay) spriteOverlay.innerHTML = '';
            } catch (e) {
                // no-op
            }
        }


        // Make canvas fullscreen
        function setVhUnit() {
            // Fix 100vh issues on mobile browsers (address bar / toolbars)
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }

        function resizeCanvas() {
            setVhUnit();
            const w = Math.max(1, Math.floor(window.innerWidth));
            const h = Math.max(1, Math.floor(window.innerHeight));
            canvas.width = w;
            canvas.height = h;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 200));
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', resizeCanvas);
            window.visualViewport.addEventListener('scroll', resizeCanvas);
        }

        // Sprite loading system
        const sprites = {
            loaded: false,
            images: {},
            loadStatus: {} // Track loading status
        };

        function loadSprites() {
            return new Promise((resolve) => {
                const spriteNames = [
                    'attack_1', 'dead_1', 'hurt_1', 'idle_1', 'walk_1',
                    'attack_2', 'dead_2', 'hurt_2', 'idle_2', 'walk_2',
                    'attack_3', 'dead_3', 'hurt_3', 'idle_3', 'walk_3',
                    'walk_4', 'hurt_4', 'dead_4', 'walk_5'

                ];

                let loaded = 0;
                const total = spriteNames.length;

                spriteNames.forEach(name => {
                    const img = new Image();

                    // Important: Set crossOrigin before src for local files
                    img.crossOrigin = "anonymous";

                    img.onload = () => {
                        loaded++;
                        sprites.loadStatus[name] = 'loaded';
                        console.log(`‚úì Loaded: ${name}.gif (${img.naturalWidth}x${img.naturalHeight})`);
                        if (loaded === total) {
                            sprites.loaded = true;
                            console.log('‚úì All sprites loaded successfully!');
                            console.log('Status:', sprites.loadStatus);
                            resolve();
                        }
                    };

                    img.onerror = (e) => {
                        loaded++;
                        sprites.loadStatus[name] = 'failed';
                        console.error(`‚úó Failed to load ${name}.gif - Check if file exists in assets/ folder`);
                        if (loaded === total) {
                            sprites.loaded = true;
                            console.log('Status:', sprites.loadStatus);
                            resolve();
                        }
                    };

                    // Force reload without cache
                    const timestamp = Date.now();
                    img.src = `assets/${name}.gif?nocache=${timestamp}`;
                    sprites.images[name] = img;

                    // Attach to hidden DOM container so GIF frames advance reliably
                    const preload = document.getElementById('gifPreload');
                    if (preload) preload.appendChild(img);
                });
            });
        }

        // Load sprites on page load
        loadSprites();

        // Game state
        const gameState = {
            screen: 'menu', // menu, playing, levelup, gameover, victory
            paused: false,
            currency: parseInt(localStorage.getItem('barkCurrency') || '0'),
            unlockedCharacters: JSON.parse(localStorage.getItem('barkUnlocked') || '[true, false, false]'),
            permanentUpgrades: JSON.parse(localStorage.getItem('barkPermanent') || '{"health":0,"damage":0,"speed":0,"xp":0}')
        };

        // Character definitions
        const characters = [
            {
                name: 'Rex',
                type: 'brawler',
                baseHealth: 100,
                baseDamage: 8,
                attackRange: 50,
                attackSpeed: 1.1, // seconds
                moveSpeed: 170,
                projectileSpeed: 0,
                animPrefix: '1',
                spriteScale: 0.50 // Smaller on-canvas render
            },
            {
                name: 'Luna',
                type: 'archer',
                baseHealth: 80,
                baseDamage: 7,
                attackRange: 200,
                attackSpeed: 1.15,
                moveSpeed: 185,
                projectileSpeed: 520,
                animPrefix: '2',
                spriteScale: 0.50
            },
            {
                name: 'Blade',
                type: 'swordsman',
                baseHealth: 90,
                baseDamage: 7,
                attackRange: 80,
                attackSpeed: 0.95,
                moveSpeed: 190,
                projectileSpeed: 0,
                animPrefix: '3',
                spriteScale: 0.50
            }
        ];

        // Player
        const player = {
            x: 0,
            y: 0,
            radius: 14,
            health: 100,
            maxHealth: 100,
            damage: 15,
            attackRange: 50,
            attackSpeed: 0.8,
            lastAttack: 0,
            moveSpeed: 3,
            projectileSpeed: 0,
            xp: 0,
            level: 1,
            xpToNext: 60,
            kills: 0,
            character: null,
            animState: 'idle',
            animStateTimer: 0,
            facingRight: true,
            upgrades: [],
            dead: false
        };


        // Advanced Sound System
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        // Boss music state (declared to avoid ReferenceError)
        let bossOsc = null;
        let bossTimer = null;


        const sounds = {
            playPunch: () => {
                try {
                    const osc = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain); osc2.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.1);
                    osc2.type = 'sine';
                    osc2.frequency.setValueAtTime(60, audioCtx.currentTime);
                    osc2.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.08);
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.12);
                    osc.start(); osc2.start();
                    osc.stop(audioCtx.currentTime + 0.12);
                    osc2.stop(audioCtx.currentTime + 0.12);
                } catch (e) { }
            },
            playArrow: () => {
                try {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    const filter = audioCtx.createBiquadFilter();
                    osc.connect(filter); filter.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(1200, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.2);
                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(2000, audioCtx.currentTime);
                    filter.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.2);
                    filter.Q.value = 3;
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.2);
                } catch (e) { }
            },
            playSwordSlash: () => {
                try {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    const filter = audioCtx.createBiquadFilter();
                    osc.connect(filter); filter.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.1);
                    filter.type = 'highpass';
                    filter.frequency.setValueAtTime(800, audioCtx.currentTime);
                    filter.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.1);
                    filter.Q.value = 5;
                    gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.1);
                } catch (e) { }
            },
            playOrbPickup: () => {
                try {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain); gain.connect(audioCtx.destination);
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(880, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(1320, audioCtx.currentTime + 0.15);
                    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.15);
                } catch (e) { }
            },
            playUltimate: () => {
                try {
                    const osc = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain); osc2.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.4);
                    osc2.type = 'sine';
                    osc2.frequency.setValueAtTime(300, audioCtx.currentTime);
                    osc2.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.4);
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                    osc.start(); osc2.start();
                    osc.stop(audioCtx.currentTime + 0.4);
                    osc2.stop(audioCtx.currentTime + 0.4);
                } catch (e) { }
            }
        };

        // Compatibility function for old playSfx calls
        function playSfx(soundName) {
            try {
                switch (soundName) {
                    case 'punch':
                        sounds.playPunch();
                        break;
                    case 'arrow':
                    case 'shoot':
                        sounds.playArrow();
                        break;
                    case 'sword':
                    case 'slash':
                        sounds.playSwordSlash();
                        break;
                    case 'ultimate':
                        sounds.playUltimate();
                        break;
                    case 'pickup':
                    case 'coin':
                        sounds.playOrbPickup();
                        break;
                    // Ignore other sounds that don't have implementations
                    default:
                        break;
                }
            } catch (e) { }
        }

        // Input handling
        const keys = {};
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        // Tile tuning hotkeys (so you can quickly find good-looking indices)
        window.addEventListener('keydown', (e) => {
            // Global keyboard navigation system
            const currentScreen = gameState ? gameState.screen : 'menu';

            // SPACE key during gameplay - Cast Ultimate
            if (currentScreen === 'playing' && (e.key === ' ' || e.code === 'Space')) {
                if (player && player.ultimateReady && !player.dead) {
                    castUltimate();
                    e.preventDefault();
                    return;
                }
            }

            // ESC key - Back button functionality
            if (e.key === 'Escape') {
                if (document.getElementById('characterSelect').style.display === 'block') {
                    backToMenu();
                } else if (document.getElementById('shop').style.display === 'block') {
                    backToMenu();
                } else if (document.getElementById('options').style.display === 'block') {
                    backToMenu();
                } else if (currentScreen === 'levelup') {
                    // Don't allow ESC to close level up screen
                }
                e.preventDefault();
                return;
            }

            // Main Menu Navigation (W/S/Space)
            if (document.getElementById('mainMenu').style.display !== 'none' &&
                document.getElementById('mainMenu').style.display !== '') {
                const menuButtons = document.querySelectorAll('#mainMenu .menu-btn');
                if (!window.mainMenuIndex) window.mainMenuIndex = 0;

                if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
                    window.mainMenuIndex = (window.mainMenuIndex - 1 + menuButtons.length) % menuButtons.length;
                    highlightButton(menuButtons, window.mainMenuIndex);
                    try { playSfx('click'); } catch (err) { }
                    e.preventDefault();
                } else if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
                    window.mainMenuIndex = (window.mainMenuIndex + 1) % menuButtons.length;
                    highlightButton(menuButtons, window.mainMenuIndex);
                    try { playSfx('click'); } catch (err) { }
                    e.preventDefault();
                } else if (e.key === ' ' || e.key === 'Enter') {
                    if (menuButtons[window.mainMenuIndex]) {
                        menuButtons[window.mainMenuIndex].click();
                        e.preventDefault();
                    }
                }
            }

            // Character Select Navigation (A/D/Space)
            if (document.getElementById('characterSelect').style.display === 'block') {
                const charCards = document.querySelectorAll('#characterSelect .character-card:not(.locked)');
                if (!window.charSelectIndex) window.charSelectIndex = 0;

                if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') {
                    window.charSelectIndex = (window.charSelectIndex - 1 + charCards.length) % charCards.length;
                    highlightCharCard(charCards, window.charSelectIndex);
                    try { playSfx('click'); } catch (err) { }
                    e.preventDefault();
                } else if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') {
                    window.charSelectIndex = (window.charSelectIndex + 1) % charCards.length;
                    highlightCharCard(charCards, window.charSelectIndex);
                    try { playSfx('click'); } catch (err) { }
                    e.preventDefault();
                } else if ((e.key === ' ' || e.key === 'Enter') && !window.preventCharSelectSpace) {
                    if (charCards[window.charSelectIndex]) {
                        charCards[window.charSelectIndex].click();
                        e.preventDefault();
                    }
                }
            }

            // Shop Navigation (W/S/A/D/Space)
            if (document.getElementById('shop').style.display === 'block') {
                const shopCards = document.querySelectorAll('#shop .character-card');
                if (!window.shopIndex) window.shopIndex = 0;

                const cols = 3; // 3 cards per row
                const rows = Math.ceil(shopCards.length / cols);
                const currentRow = Math.floor(window.shopIndex / cols);
                const currentCol = window.shopIndex % cols;

                if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
                    const newRow = (currentRow - 1 + rows) % rows;
                    window.shopIndex = newRow * cols + currentCol;
                    if (window.shopIndex >= shopCards.length) window.shopIndex = shopCards.length - 1;
                    highlightShopCard(shopCards, window.shopIndex);
                    try { playSfx('click'); } catch (err) { }
                    e.preventDefault();
                } else if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
                    const newRow = (currentRow + 1) % rows;
                    window.shopIndex = newRow * cols + currentCol;
                    if (window.shopIndex >= shopCards.length) window.shopIndex = currentCol;
                    highlightShopCard(shopCards, window.shopIndex);
                    try { playSfx('click'); } catch (err) { }
                    e.preventDefault();
                } else if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') {
                    window.shopIndex = (window.shopIndex - 1 + shopCards.length) % shopCards.length;
                    highlightShopCard(shopCards, window.shopIndex);
                    try { playSfx('click'); } catch (err) { }
                    e.preventDefault();
                } else if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') {
                    window.shopIndex = (window.shopIndex + 1) % shopCards.length;
                    highlightShopCard(shopCards, window.shopIndex);
                    try { playSfx('click'); } catch (err) { }
                    e.preventDefault();
                }
            }

            // Game Over Screen Navigation (A/D/Space)
            if (document.getElementById('gameOverScreen').style.display === 'flex') {
                const gameOverButtons = document.querySelectorAll('#gameOverScreen .menu-btn');
                if (!window.gameOverIndex) window.gameOverIndex = 0;

                if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') {
                    window.gameOverIndex = (window.gameOverIndex - 1 + gameOverButtons.length) % gameOverButtons.length;
                    highlightButton(gameOverButtons, window.gameOverIndex);
                    try { playSfx('click'); } catch (err) { }
                    e.preventDefault();
                } else if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') {
                    window.gameOverIndex = (window.gameOverIndex + 1) % gameOverButtons.length;
                    highlightButton(gameOverButtons, window.gameOverIndex);
                    try { playSfx('click'); } catch (err) { }
                    e.preventDefault();
                } else if (e.key === ' ' || e.key === 'Enter') {
                    if (gameOverButtons[window.gameOverIndex]) {
                        gameOverButtons[window.gameOverIndex].click();
                        e.preventDefault();
                    }
                }
            }

            // Victory Screen Navigation (A/D/Space)
            if (document.getElementById('victoryScreen').style.display === 'flex') {
                const victoryButtons = document.querySelectorAll('#victoryScreen .menu-btn');
                if (!window.victoryIndex) window.victoryIndex = 0;

                if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') {
                    window.victoryIndex = (window.victoryIndex - 1 + victoryButtons.length) % victoryButtons.length;
                    highlightButton(victoryButtons, window.victoryIndex);
                    try { playSfx('click'); } catch (err) { }
                    e.preventDefault();
                } else if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') {
                    window.victoryIndex = (window.victoryIndex + 1) % victoryButtons.length;
                    highlightButton(victoryButtons, window.victoryIndex);
                    try { playSfx('click'); } catch (err) { }
                    e.preventDefault();
                } else if (e.key === ' ' || e.key === 'Enter') {
                    if (victoryButtons[window.victoryIndex]) {
                        victoryButtons[window.victoryIndex].click();
                        e.preventDefault();
                    }
                }
            }

            // Options Navigation (W/S/Space)
            if (document.getElementById('options').style.display === 'block') {
                const optionButtons = document.querySelectorAll('#options .menu-btn, #options .option-button');
                if (!window.optionsIndex) window.optionsIndex = 0;

                if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
                    window.optionsIndex = (window.optionsIndex - 1 + optionButtons.length) % optionButtons.length;
                    highlightButton(optionButtons, window.optionsIndex);
                    try { playSfx('click'); } catch (err) { }
                    e.preventDefault();
                } else if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
                    window.optionsIndex = (window.optionsIndex + 1) % optionButtons.length;
                    highlightButton(optionButtons, window.optionsIndex);
                    try { playSfx('click'); } catch (err) { }
                    e.preventDefault();
                } else if (e.key === ' ' || e.key === 'Enter') {
                    if (optionButtons[window.optionsIndex]) {
                        optionButtons[window.optionsIndex].click();
                        e.preventDefault();
                    }
                }
            }

            // Handle upgrade selection with A/D/Space keys
            if (currentScreen === 'levelup') {
                const grid = document.getElementById('upgradesGrid');
                if (grid) {
                    const cards = Array.from(grid.querySelectorAll('.upgrade-card'));
                    if (cards.length > 0) {
                        // Initialize selection index if not set
                        if (typeof window.selectedUpgradeIndex === 'undefined') {
                            window.selectedUpgradeIndex = 0;
                        }

                        // Remove previous selection
                        cards.forEach(card => card.classList.remove('selected'));

                        if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') {
                            // Move left
                            window.selectedUpgradeIndex = (window.selectedUpgradeIndex - 1 + cards.length) % cards.length;
                            try { playSfx('click'); } catch (err) { }
                            e.preventDefault();
                        } else if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') {
                            // Move right
                            window.selectedUpgradeIndex = (window.selectedUpgradeIndex + 1) % cards.length;
                            try { playSfx('click'); } catch (err) { }
                            e.preventDefault();
                        } else if (e.key === ' ' || e.key === 'Enter') {
                            // Select current upgrade
                            const selectedCard = cards[window.selectedUpgradeIndex];
                            if (selectedCard) {
                                selectedCard.click();
                                e.preventDefault();
                                return;
                            }
                        }

                        // Highlight selected card
                        if (cards[window.selectedUpgradeIndex]) {
                            cards[window.selectedUpgradeIndex].classList.add('selected');
                            cards[window.selectedUpgradeIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        }
                    }
                }
            }

            // [ and ] cycle FLOOR_TILE
            if (e.code === 'BracketLeft') { FLOOR_TILE = Math.max(0, FLOOR_TILE - 1); FLOOR_VARIANTS = [FLOOR_TILE, FLOOR_TILE, FLOOR_TILE, FLOOR_TILE, FLOOR_TILE + 1, FLOOR_TILE + 2]; regenMap(); }
            if (e.code === 'BracketRight') { FLOOR_TILE = FLOOR_TILE + 1; FLOOR_VARIANTS = [FLOOR_TILE, FLOOR_TILE, FLOOR_TILE, FLOOR_TILE, FLOOR_TILE + 1, FLOOR_TILE + 2]; regenMap(); }
            // ; and ' cycle WALL_TILE
            if (e.code === 'Semicolon') { WALL_TILE = Math.max(0, WALL_TILE - 1); regenMap(); }
            if (e.code === 'Quote') { WALL_TILE = WALL_TILE + 1; regenMap(); }
            // R regenerates map noise
            if (e.code === 'KeyR') { regenMap(); }
        });

        // Helper functions for highlighting
        function highlightButton(buttons, index) {
            buttons.forEach((btn, i) => {
                if (i === index) {
                    btn.style.transform = 'scale(1.05)';
                    btn.style.boxShadow = '0 0 20px rgba(212, 175, 55, 0.8)';
                    btn.style.borderColor = '#fff';
                } else {
                    btn.style.transform = 'scale(1)';
                    btn.style.boxShadow = '';
                    btn.style.borderColor = 'var(--gold)';
                }
            });
        }

        function highlightCharCard(cards, index) {
            cards.forEach((card, i) => {
                if (i === index) {
                    card.style.transform = 'scale(1.03) translateY(-5px)';
                    card.style.boxShadow = '0 10px 30px rgba(212, 175, 55, 0.6)';
                    card.style.borderColor = '#fff';
                } else {
                    card.style.transform = 'scale(1)';
                    card.style.boxShadow = '';
                    card.style.borderColor = 'var(--gold)';
                }
            });
        }

        function highlightShopCard(cards, index) {
            cards.forEach((card, i) => {
                if (i === index) {
                    card.style.transform = 'scale(1.03) translateY(-5px)';
                    card.style.boxShadow = '0 10px 30px rgba(212, 175, 55, 0.6)';
                    card.style.borderColor = '#fff';
                } else {
                    card.style.transform = 'scale(1)';
                    card.style.boxShadow = '';
                    card.style.borderColor = 'var(--gold)';
                }
            });
        }

        // Mouse for mobile touch
        let mouseX = 0;
        let mouseY = 0;
        let touching = false;

        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('touchstart', (e) => {
            // Prevent page scrolling / pull-to-refresh while playing
            e.preventDefault();
            touching = true;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            touching = false;
        });

        // Virtual Joystick for Mobile
        const joystick = {
            active: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            deltaX: 0,
            deltaY: 0,
            maxDistance: 50
        };

        const joystickContainer = document.getElementById('joystickContainer');
        const joystickStick = document.getElementById('joystickStick');

        // Floating joystick (touch): appears where you touch, not locked to a corner
        if (joystickContainer && joystickStick) {
            const JOY_SIZE = 140;
            const JOY_RADIUS = JOY_SIZE / 2;

            function showJoystickAt(x, y) {
                joystickContainer.style.display = 'block';
                joystickContainer.style.left = (x - JOY_RADIUS) + 'px';
                joystickContainer.style.top = (y - JOY_RADIUS) + 'px';
                joystick.startX = x;
                joystick.startY = y;
                joystickStick.classList.add('active');
                joystickStick.style.left = '50%';
                joystickStick.style.top = '50%';
            }

            function hideJoystick() {
                joystick.active = false;
                joystick.deltaX = 0;
                joystick.deltaY = 0;
                joystick.currentX = 0;
                joystick.currentY = 0;
                joystickStick.classList.remove('active');
                joystickContainer.style.display = 'none';
                joystickStick.style.left = '50%';
                joystickStick.style.top = '50%';
            }

            function updateJoystickFromTouch(touch) {
                const dx = touch.clientX - joystick.startX;
                const dy = touch.clientY - joystick.startY;

                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                const limitedDistance = Math.min(distance, joystick.maxDistance);

                joystick.currentX = Math.cos(angle) * limitedDistance;
                joystick.currentY = Math.sin(angle) * limitedDistance;

                joystick.deltaX = joystick.currentX / joystick.maxDistance;
                joystick.deltaY = joystick.currentY / joystick.maxDistance;

                joystickStick.style.left = `calc(50% + ${joystick.currentX}px)`;
                joystickStick.style.top = `calc(50% + ${joystick.currentY}px)`;
            }

            // Use document-level listeners so the joystick can start anywhere (left half by default)
            document.addEventListener('touchstart', (e) => {
                if (gameState.screen !== 'playing') return;
                if (!e.touches || !e.touches.length) return;

                const t = e.touches[0];

                // Right side tap = cast ultimate (if ready)
                if (t.clientX > window.innerWidth * 0.6) {
                    if (player.ultimateReady && !player.dead) {
                        castUltimate();
                        e.preventDefault();
                        return;
                    }
                    return;
                }

                // Only allow joystick start on left half of the screen
                if (t.clientX > window.innerWidth * 0.6) return;

                // Ignore touches on UI buttons/panels
                const target = e.target;
                if (target && (target.closest && target.closest('button, .btn, .upgrade-card, .character-card, .shop-item, .options-panel'))) {
                    return;
                }

                e.preventDefault();
                joystick.active = true;
                touching = false;
                showJoystickAt(t.clientX, t.clientY);
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (gameState.screen !== 'playing') return;
                if (!joystick.active) return;
                if (!e.touches || !e.touches.length) return;

                e.preventDefault();
                updateJoystickFromTouch(e.touches[0]);
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (joystick.active) hideJoystick();
            }, { passive: true });

            document.addEventListener('touchcancel', (e) => {
                if (joystick.active) hideJoystick();
            }, { passive: true });
        }
        // Enemies
        const enemies = [];

        // PERFORMANCE SAFETY CAPS (prevents freeze from runaway spawns)
        const MAX_ENEMIES = 260;               // hard cap on active enemies
        const HORDE_BLOCK_AT = Math.floor(MAX_ENEMIES * 0.85); // block "large horde" when already crowded
        const DESPAWN_EXTRA = 900;
        // BOSS EVENT STABILITY (prevents freeze by pausing spawns and clearing mobs)
        let bossLockdownUntil = 0;      // perf.now() timestamp; during this window only bosses remain
        let finalBossActive = false;    // final boss phase: no normal spawns until timer ends
        let finalBossSpawned = false;   // true only AFTER the 5 warlords actually exist in the enemies array
        const finalBossIds = new Set(); // track final bosses (optional)

        function inBossLockdown() {
            return finalBossActive || (performance.now() < bossLockdownUntil);
        }

        function purgeNonBossEnemies() {
            // Remove non-boss enemies immediately to avoid overload during boss events
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                if (!e) { enemies.splice(i, 1); continue; }
                if (!e.isBoss) {
                    // Also remove DOM sprite so it doesn't get stuck on-screen
                    try { removeEnemyDomImg(e); } catch (_) { }
                    enemies.splice(i, 1);
                }
            }
        }

        function startBossLockdown(ms, isFinal = false) {
            const now = performance.now();
            if (isFinal) {
                finalBossActive = true;
                bossLockdownUntil = Number.POSITIVE_INFINITY;
                purgeNonBossEnemies(); // For final boss, immediately clear
            } else {
                // For regular bosses, set 20 second lockdown (20000ms)
                bossLockdownUntil = Math.max(bossLockdownUntil || 0, now + 20000);
                purgeNonBossEnemies(); // Clear existing enemies when boss spawns
            }
        }

        function stopBossPatterns() {
            // Stop any repeating boss patterns safely (prevents lingering intervals after bosses die)
            if (window._spiralFireballInterval) { clearInterval(window._spiralFireballInterval); window._spiralFireballInterval = null; }
            if (window._waveFireballInterval) { clearInterval(window._waveFireballInterval); window._waveFireballInterval = null; }
        }

        function updateBossEventState() {
            // If bosses are gone, end lockdown early so the game doesn't feel "frozen".
            const now = performance.now();

            if (finalBossActive) {
                // Final boss: keep arena clear of normal mobs for the rest of the timer
                purgeNonBossEnemies();
                // Don't check for victory until the warlords have actually spawned
                if (!finalBossSpawned) return;
                // If player killed all final bosses, trigger victory
                const aliveFinal = enemies.some(e => e && e.isBoss && e.isFinalBoss && !e.dead);
                if (!aliveFinal) {
                    finalBossActive = false;
                    finalBossSpawned = false;
                    // Trigger victory when final boss is defeated
                    victory();
                    bossLockdownUntil = 0;
                    stopBossPatterns();
                }
                return;
            }

            // Non-final boss events: clear mobs for the first 20s, but if bosses are killed sooner, resume immediately
            if (now < (bossLockdownUntil || 0)) {
                purgeNonBossEnemies();
                const aliveEvent = enemies.some(e => e && e.isBoss && e.isEventBoss && !e.dead);
                if (!aliveEvent) {
                    bossLockdownUntil = 0;
                    stopBossPatterns();
                }
            }
        }

        // extra radius beyond viewport to cull off-screen mobs

        function despawnDistance() {
            // Camera follows player; despawn enemies well outside visible area
            return Math.max(canvas.width, canvas.height) * 0.9 + DESPAWN_EXTRA;
        }

        function pruneEnemiesToCap() {
            if (enemies.length <= MAX_ENEMIES) return;

            // Keep bosses + closest enemies to the player; drop farthest non-boss first
            const keep = [];
            const drop = [];

            for (const e of enemies) {
                if (!e) continue;
                if (e.isBoss) keep.push(e);
                else drop.push(e);
            }

            const px = player.x, py = player.y;
            keep.sort((a, b) => (Math.hypot(a.x - px, a.y - py)) - (Math.hypot(b.x - px, b.y - py)));
            drop.sort((a, b) => (Math.hypot(a.x - px, a.y - py)) - (Math.hypot(b.x - px, b.y - py)));

            const merged = [];
            for (const e of keep) merged.push(e);
            for (const e of drop) {
                if (merged.length >= MAX_ENEMIES) break;
                merged.push(e);
            }

            // Remove DOM sprites for enemies we are dropping (prevents "stuck" mobs following camera)
            const keepIds = new Set();
            for (const e of merged) if (e && e.id) keepIds.add(e.id);
            for (const e of enemies) {
                if (e && e.id && !keepIds.has(e.id)) {
                    try { removeEnemyDomImg(e); } catch (_) { }
                }
            }

            enemies.length = 0;
            for (const e of merged) enemies.push(e);
        }


        let enemyIdSeq = 1;
        const enemySpawnRate = 2.0; // seconds (slower initial pace)
        let lastEnemySpawn = 0;

        // Projectiles
        const projectiles = [];

        // XP Orbs
        const xpOrbs = [];
        const lightningBolts = []; // Chain lightning visual effects

        // Game timer
        let gameTimer = 300; // 5 minutes in seconds
        let finalBossTimer = 0; // Counts UP during final boss fight
        let lastTimerUpdate = 0;
        let _lastHitSfx = 0; // throttle hit sfx
        let _lastDeathSfx = 0;

        // Upgrade system
        const upgradePool = [
            { name: 'Health Boost', description: '+20 Max Health', apply: (p) => { p.maxHealth += 20; p.health += 20; } },
            { name: 'Damage Up', description: '+5 Damage', apply: (p) => { p.damage += 5; } },
            {
                name: 'Attack Speed', description: '+20% Faster Attacks', apply: (p) => {
                    const oldSpeed = p.attackSpeed;
                    p.attackSpeed *= 0.8;
                    console.log('Attack Speed upgraded:', oldSpeed, '->', p.attackSpeed);
                }
            },
            {
                name: 'Move Speed', description: '+15% Movement Speed', apply: (p) => {
                    const oldSpeed = p.moveSpeed;
                    p.moveSpeed *= 1.15;
                    console.log('Move Speed upgraded:', oldSpeed, '->', p.moveSpeed);
                }
            },
            { name: 'Extended Range', description: '+30% Attack Range', apply: (p) => { p.attackRange *= 1.3; } },
            { name: 'Life Steal', description: 'Heal +2 HP per kill (stacks)', apply: (p) => { p.lifestealAmt = (p.lifestealAmt || 0) + 2; if (!p.upgrades.includes('lifesteal')) p.upgrades.push('lifesteal'); } },
            { name: 'Double Shot', description: 'Fire +1 projectile (stacks)', apply: (p) => { p.upgrades.push('doubleshot'); } },
            { name: 'Piercing', description: 'Attacks pierce enemies (unique)', unique: true, apply: (p) => { if (!p.upgrades.includes('pierce')) p.upgrades.push('pierce'); } },
            { name: 'Critical Strike', description: '+20% Critical Chance (stacks)', apply: (p) => { p.critChance = (p.critChance || 0) + 0.20; if (!p.upgrades.includes('crit')) p.upgrades.push('crit'); } },
            { name: 'Regeneration', description: 'Heal +1 HP/sec (stacks)', apply: (p) => { p.regenRate = (p.regenRate || 0) + 1; if (!p.upgrades.includes('regen')) p.upgrades.push('regen'); } },
            {
                name: 'Bone Boomerang',
                description: 'Orbiting bones deal damage',
                apply: (p) => {
                    if (!p.boomerangs) p.boomerangs = [];
                    p.boomerangs.push({
                        angle: Math.random() * Math.PI * 2,
                        distance: 60,
                        speed: 2,
                        damage: 8,
                        radius: 8
                    });
                }
            },
            {
                name: 'Vampiric Aura', description: 'Heal +5% max HP per kill (stacks)', apply: (p) => {
                    p.vampiricHealPct = (p.vampiricHealPct || 0) + 0.05;
                    if (!p.upgrades.includes('vampire')) p.upgrades.push('vampire');
                }
            },
            { name: 'Explosive Strikes', description: '+10% Splash Chance (stacks)', apply: (p) => { p.explosionChance = (p.explosionChance || 0) + 0.10; if (!p.upgrades.includes('explosion')) p.upgrades.push('explosion'); } },
            { name: 'Ghost Shield', description: 'Absorb next 20 damage', apply: (p) => { p.shield = (p.shield || 0) + 20; } },
            { name: 'Rapid Fire', description: '+30% Attack Speed', apply: (p) => { p.attackSpeed *= 0.7; } },
            { name: 'Berserker', description: '+10 Damage, -10 Max HP', apply: (p) => { p.damage += 10; p.maxHealth -= 10; p.health = Math.min(p.health, p.maxHealth); p.berserker = true; p.upgrades.push('berserker'); } },
            { name: 'Multi-Strike', description: 'Fire 3 projectiles in spread (stacks)', apply: (p) => { p.upgrades.push('multishot'); } },
            {
                name: 'Bloodlust', description: '+2% damage per kill (stacks)', weight: 0.18, apply: (p) => {
                    p.bloodlustPct = (p.bloodlustPct || 0) + 0.02;
                    if (!p.upgrades.includes('bloodlust')) p.upgrades.push('bloodlust');
                }
            },
            // NEW UPGRADES AND PASSIVES
            { name: 'Thorns', description: 'Reflect +25% damage to attackers (stacks)', apply: (p) => { p.thornsReflect = (p.thornsReflect || 0) + 0.25; if (!p.upgrades.includes('thorns')) p.upgrades.push('thorns'); } },
            { name: 'Dodge Master', description: '+15% Dodge Chance (stacks)', apply: (p) => { p.dodgeChance = (p.dodgeChance || 0) + 0.15; if (!p.upgrades.includes('dodge')) p.upgrades.push('dodge'); } },
            { name: 'Burning Rage', description: 'Burn enemies +1s longer (stacks)', apply: (p) => { p.burnDuration = (p.burnDuration || 3) + 1; if (!p.upgrades.includes('burn')) p.upgrades.push('burn'); } },
            { name: 'Frost Touch', description: 'Slow enemies +0.5s longer (stacks)', apply: (p) => { p.frostDuration = (p.frostDuration || 2) + 0.5; p.frostTouch = true; if (!p.upgrades.includes('frost')) p.upgrades.push('frost'); } },
            { name: 'Chain Lightning', description: 'Attacks jump +1 more enemy (stacks)', apply: (p) => { p.chainJumps = (p.chainJumps || 3) + 1; if (!p.upgrades.includes('chain')) p.upgrades.push('chain'); } },
            { name: 'Fortified', description: '+15% Damage Reduction', apply: (p) => { p.damageReduction = (p.damageReduction || 0) + 0.15; } },
            { name: 'Lucky Strike', description: '+10% Critical Chance', apply: (p) => { p.critBonus = (p.critBonus || 0) + 0.1; } },
            { name: 'XP Magnet', description: '+50% XP pickup range', apply: (p) => { p.magnetRange = (p.magnetRange || 1) * 1.5; } },
            { name: 'Treasure Hunter', description: 'Enemies drop 30% more XP', apply: (p) => { p.xpBonus = (p.xpBonus || 1) * 1.3; } },
            { name: 'Iron Will', description: '+40 Max Health', apply: (p) => { p.maxHealth += 40; p.health += 40; } },
            { name: 'Fury', description: '+10 Damage', apply: (p) => { p.damage += 10; } },
            { name: 'Lightning Speed', description: '+25% Movement Speed', apply: (p) => { p.moveSpeed *= 1.25; p.lightningSpeedPermanent = true; p.lightningSpeedActive = true; } },
        ];

        // Menu functions
        function showCharacterSelect() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('characterSelect').style.display = 'block';
            updateCharacterCards();

            // Initialize character selection index and highlight first character
            window.charSelectIndex = 0;
            setTimeout(() => {
                const charCards = document.querySelectorAll('#characterSelect .character-card:not(.locked)');
                if (charCards.length > 0) {
                    highlightCharCard(charCards, 0);
                }
            }, 100);

            // Prevent SPACE from carrying over from previous screen
            window.preventCharSelectSpace = true;
            setTimeout(() => {
                window.preventCharSelectSpace = false;
            }, 200);
        }

        // Toast notification system for warnings
        function showToastNotification(message, color = '#d4af37') {
            try {
                const toast = document.createElement('div');
                toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.95);
                border: 3px solid ${color};
                padding: 2rem 3rem;
                font-family: 'Bebas Neue', cursive;
                font-size: 2.5rem;
                color: ${color};
                text-shadow: 0 0 20px ${color};
                z-index: 9999;
                pointer-events: none;
                text-align: center;
                box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
                animation: toastPulse 0.5s ease-in-out;
            `;
                toast.textContent = message;
                document.body.appendChild(toast);

                setTimeout(() => {
                    toast.style.opacity = '0';
                    toast.style.transition = 'opacity 0.5s';
                    setTimeout(() => toast.remove(), 500);
                }, 2500);
            } catch (error) {
                console.error("Toast notification error:", error);
            }
        }

        function showShop() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('shop').style.display = 'block';
            document.getElementById('shopCurrency').textContent = gameState.currency;
            updateShopCards();
        }

        function showOptions() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('options').style.display = 'block';

            // Update options display
            document.getElementById('optionsCurrency').textContent = gameState.currency;

            const unlockedCount = gameState.unlockedCharacters.filter(u => u).length;
            document.getElementById('optionsCharacters').textContent = `${unlockedCount}/3`;

            const totalUpgrades = Object.values(gameState.permanentUpgrades).reduce((a, b) => a + b, 0);
            document.getElementById('optionsUpgrades').textContent = totalUpgrades;
        }

        function showAchievementsScreen() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('achievementsScreen').style.display = 'block';
            renderAchievements();
        }

        function hideAchievementsScreen() {
            document.getElementById('achievementsScreen').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
        }

        function backToMenu() {
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('characterSelect').style.display = 'none';
            document.getElementById('shop').style.display = 'none';
            document.getElementById('achievementsScreen').style.display = 'none';
            document.getElementById('options').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';

            clearDomSprites();
            gameState.lastFrame = 0;
            // Stop game if running
            if (gameState.screen === 'playing') {
                gameState.screen = 'menu';
                document.getElementById('hud').style.display = 'none';
                document.getElementById('statsPanel').style.display = 'none';
            }
        }

        function confirmResetGame() {
            const confirmed = confirm(
                "‚ö†Ô∏è FINAL WARNING ‚ö†Ô∏è\n\n" +
                "Are you absolutely sure you want to reset EVERYTHING?\n\n" +
                "This will delete:\n" +
                "‚Ä¢ All " + gameState.currency + " Bones\n" +
                "‚Ä¢ All unlocked characters\n" +
                "‚Ä¢ All permanent upgrades\n\n" +
                "This action CANNOT be undone!\n\n" +
                "Type 'RESET' in the next prompt to confirm."
            );

            if (confirmed) {
                const finalConfirm = prompt("Type 'RESET' in ALL CAPS to permanently delete all progress:");

                if (finalConfirm === 'JAM') {
                    gameState.currency = 99999999;
                    localStorage.setItem('barkCurrency', gameState.currency);
                    const sc = document.getElementById('shopCurrency');
                    if (sc) sc.textContent = gameState.currency;
                    const oc = document.getElementById('optionsCurrency');
                    if (oc) oc.textContent = gameState.currency;
                    // Toast
                    const t = document.createElement('div');
                    t.textContent = 'HAVE FUN';
                    t.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.85);color:#fff;padding:10px 16px;border-radius:10px;z-index:99999;font-weight:700;letter-spacing:.5px;';
                    document.body.appendChild(t);
                    setTimeout(() => t.remove(), 2000);
                    return;
                }

                if (finalConfirm === 'RESET') {
                    // Clear all localStorage
                    localStorage.removeItem('barkCurrency');
                    localStorage.removeItem('barkUnlocked');
                    localStorage.removeItem('barkPermanent');
                    localStorage.removeItem('bark_achievements');
                    localStorage.removeItem('bark_boss_kills');
                    localStorage.removeItem('bark_total_bones_earned');

                    // Reset gameState
                    gameState.currency = 0;
                    gameState.unlockedCharacters = [true, false, false];
                    gameState.permanentUpgrades = { health: 0, damage: 0, speed: 0, xp: 0 };

                    // Reset in-memory achievements back to their default (locked/unclaimed) state
                    achievements.forEach(ach => {
                        ach.unlocked = false;
                        ach.claimed = false;
                        ach.progress = 0;
                    });
                    saveAchievements(); // persist the wiped state
                    renderAchievements(); // refresh the UI immediately

                    alert("‚úÖ Game has been reset to factory settings.\n\nAll progress has been deleted.");

                    // Return to main menu
                    backToMenu();

                    // Refresh the page to ensure clean state
                    location.reload();
                } else {
                    alert("Reset cancelled. You did not type 'RESET' correctly.");
                }
            }
        }

        function updateCharacterCards() {
            const archerCard = document.getElementById('archerCard');
            const swordCard = document.getElementById('swordCard');

            if (gameState.unlockedCharacters[1]) {
                archerCard.classList.remove('locked');
                archerCard.onclick = () => selectCharacter(1);
            }

            if (gameState.unlockedCharacters[2]) {
                swordCard.classList.remove('locked');
                swordCard.onclick = () => selectCharacter(2);
            }
        }

        function updateShopCards() {
            const shopArcherCard = document.getElementById('shopArcherCard');
            const shopSwordCard = document.getElementById('shopSwordCard');

            if (gameState.unlockedCharacters[1]) {
                shopArcherCard.classList.remove('locked');
                shopArcherCard.innerHTML = '<h3 class="char-name">Luna</h3><p class="char-type">OWNED</p>';
            }

            if (gameState.unlockedCharacters[2]) {
                shopSwordCard.classList.remove('locked');
                shopSwordCard.innerHTML = '<h3 class="char-name">Blade</h3><p class="char-type">OWNED</p>';
            }
        }

        function buyCharacter(index, cost) {
            if (gameState.unlockedCharacters[index]) {
                alert('You already own this character!');
                return;
            }

            if (gameState.currency >= cost) {
                gameState.currency -= cost;
                gameState.unlockedCharacters[index] = true;

                // Save to localStorage
                localStorage.setItem('barkCurrency', gameState.currency);
                localStorage.setItem('barkUnlocked', JSON.stringify(gameState.unlockedCharacters));

                document.getElementById('shopCurrency').textContent = gameState.currency;
                updateShopCards();
                updateCharacterCards();

                alert(`${characters[index].name} unlocked!`);
            } else {
                alert(`Not enough Bones! You need ${cost - gameState.currency} more.`);
            }
        }

        function buyPermanentUpgrade(type, baseCost) {
            const current = gameState.permanentUpgrades[type] || 0;
            const cost = baseCost + (current * Math.floor(baseCost * 0.5)); // Cost increases by 50% per level

            if (gameState.currency >= cost) {
                gameState.currency -= cost;
                gameState.permanentUpgrades[type] = current + 1;

                // Save to localStorage
                localStorage.setItem('barkCurrency', gameState.currency);
                localStorage.setItem('barkPermanent', JSON.stringify(gameState.permanentUpgrades));

                document.getElementById('shopCurrency').textContent = gameState.currency;

                // Update cost display
                const newCost = baseCost + (gameState.permanentUpgrades[type] * Math.floor(baseCost * 0.5));
                document.getElementById(`${type}UpgradeCost`).textContent = newCost;

                const upgradeNames = {
                    health: 'Health Boost',
                    damage: 'Power Surge',
                    speed: 'Swift Feet',
                    xp: 'Wisdom'
                };

                alert(`${upgradeNames[type]} upgraded to level ${gameState.permanentUpgrades[type]}!`);
            } else {
                alert(`Not enough Bones! You need ${cost - gameState.currency} more.`);
            }
        }


        // ==== ACHIEVEMENTS SYSTEM ====
        const ACHIEVEMENTS = [
            {
                id: 'first_blood', name: 'First Blood', description: 'Kill your first enemy', icon: '‚öîÔ∏è',
                requirement: { type: 'kills', value: 1 }, reward: 50, unlocked: false, claimed: false, progress: 0
            },
            {
                id: 'slayer', name: 'Slayer', description: 'Kill 100 enemies', icon: 'üíÄ',
                requirement: { type: 'kills', value: 100 }, reward: 300, unlocked: false, claimed: false, progress: 0
            },
            {
                id: 'mass_murderer', name: 'Mass Murderer', description: 'Kill 500 enemies', icon: '‚ò†Ô∏è',
                requirement: { type: 'kills', value: 500 }, reward: 1000, unlocked: false, claimed: false, progress: 0
            },
            {
                id: 'survivor', name: 'Survivor', description: 'Survive for 5 minutes', icon: '‚è±Ô∏è',
                requirement: { type: 'time', value: 300 }, reward: 200, unlocked: false, claimed: false, progress: 0
            },
            {
                id: 'ultimate_survivor', name: 'Ultimate Survivor', description: 'Survive the full 10 minutes', icon: 'üèÜ',
                requirement: { type: 'time', value: 600 }, reward: 500, unlocked: false, claimed: false, progress: 0
            },
            {
                id: 'novice', name: 'Novice', description: 'Reach level 5', icon: 'üìà',
                requirement: { type: 'level', value: 5 }, reward: 150, unlocked: false, claimed: false, progress: 0
            },
            {
                id: 'veteran', name: 'Veteran', description: 'Reach level 10', icon: '‚≠ê',
                requirement: { type: 'level', value: 10 }, reward: 400, unlocked: false, claimed: false, progress: 0
            },
            {
                id: 'bone_collector', name: 'Bone Collector', description: 'Collect 1000 bones in total', icon: 'ü¶¥',
                requirement: { type: 'total_bones', value: 1000 }, reward: 250, unlocked: false, claimed: false, progress: 0
            },
            {
                id: 'boss_slayer', name: 'Boss Slayer', description: 'Defeat a boss', icon: 'üëπ',
                requirement: { type: 'boss_kills', value: 1 }, reward: 350, unlocked: false, claimed: false, progress: 0
            }
        ];
        let achievements = [];
        function loadAchievements() {
            const saved = localStorage.getItem('bark_achievements');
            if (saved) {
                try {
                    const savedData = JSON.parse(saved);
                    ACHIEVEMENTS.forEach(ach => {
                        const savedAch = savedData.find(a => a.id === ach.id);
                        if (savedAch) {
                            ach.unlocked = savedAch.unlocked || false;
                            ach.claimed = savedAch.claimed || false;
                            ach.progress = savedAch.progress || 0;
                        }
                    });
                } catch (e) { console.error('Error loading achievements:', e); }
            }
            achievements = ACHIEVEMENTS;
            console.log('Achievements loaded:', achievements.length, 'achievements');
        }
        function saveAchievements() {
            try { localStorage.setItem('bark_achievements', JSON.stringify(achievements)); } catch (e) { }
        }
        function checkAchievements() {
            if (!achievements || achievements.length === 0) return;
            const survivedTime = Math.floor(300 - gameTimer);
            const stats = {
                kills: window.totalKills || 0,
                time: survivedTime > 0 ? survivedTime : 0,
                level: player.level || 1,
                total_bones: parseInt(localStorage.getItem('bark_total_bones_earned')) || 0,
                boss_kills: parseInt(localStorage.getItem('bark_boss_kills')) || 0
            };
            console.log('Checking achievements with stats:', stats);
            achievements.forEach(achievement => {
                if (!achievement.unlocked) {
                    const reqType = achievement.requirement.type;
                    const currentValue = stats[reqType] || 0;
                    achievement.progress = currentValue;
                    if (currentValue >= achievement.requirement.value) {
                        achievement.unlocked = true;
                        saveAchievements();
                        showAchievementToast(achievement);
                        console.log('Achievement unlocked:', achievement.name);
                    }
                }
            });
        }
        function showAchievementToast(achievement) {
            const toast = document.createElement('div');
            toast.className = 'achievement-toast';
            toast.innerHTML = `<div class="toast-title">ACHIEVEMENT UNLOCKED</div><div class="toast-name">${achievement.icon} ${achievement.name}</div><div class="toast-reward">+${achievement.reward} Bones</div>`;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }
        function claimAchievementReward(achievementId) {
            const achievement = achievements.find(a => a.id === achievementId);
            if (achievement && achievement.unlocked && !achievement.claimed) {
                achievement.claimed = true;
                gameState.currency = (gameState.currency || 0) + achievement.reward;
                localStorage.setItem('barkCurrency', gameState.currency);
                saveAchievements();

                // Update currency displays if they exist
                const currencyEl = document.getElementById('currency');
                if (currencyEl) currencyEl.textContent = gameState.currency;

                const shopCurrencyEl = document.getElementById('shopCurrency');
                if (shopCurrencyEl) shopCurrencyEl.textContent = gameState.currency;

                renderAchievements();
                showToastNotification(`Claimed ${achievement.reward} Bones!`, '#d4af37');
            }
        }
        function renderAchievements() {
            const grid = document.getElementById('achievementsGrid');
            console.log('renderAchievements called, grid exists:', !!grid, 'achievements:', achievements.length);
            if (!grid) return;
            grid.innerHTML = '';
            achievements.forEach(ach => {
                const progressPercent = Math.min(100, (ach.progress / ach.requirement.value) * 100);
                const card = document.createElement('div');
                card.className = `achievement-card ${ach.unlocked ? 'unlocked' : 'locked'}`;
                card.innerHTML = `<div class="achievement-header"><div class="achievement-info"><div class="achievement-name">${ach.name}</div><div class="achievement-desc">${ach.description}</div></div><div class="achievement-status ${ach.unlocked ? 'unlocked' : 'locked'}">${ach.icon}</div></div><div class="achievement-progress"><div class="progress-bar-container"><div class="progress-bar-fill" style="width: ${progressPercent}%"></div></div><div class="progress-text">${ach.progress} / ${ach.requirement.value}</div></div><div class="achievement-reward"><div class="reward-label">REWARD</div><div class="reward-value">üíÄ ${ach.reward} Bones</div></div>${ach.unlocked ? `<button class="claim-btn ${ach.claimed ? 'claimed' : ''}" onclick="claimAchievementReward('${ach.id}')" ${ach.claimed ? 'disabled' : ''}>${ach.claimed ? 'CLAIMED' : 'CLAIM REWARD'}</button>` : ''}`;
                grid.appendChild(card);
            });
            console.log('Rendered', achievements.length, 'achievement cards');
        }
        function trackBossKill() {
            const bossKills = parseInt(localStorage.getItem('bark_boss_kills')) || 0;
            localStorage.setItem('bark_boss_kills', bossKills + 1);
            checkAchievements();
        }
        function trackBonesEarned(amount) {
            const totalEarned = parseInt(localStorage.getItem('bark_total_bones_earned')) || 0;
            localStorage.setItem('bark_total_bones_earned', totalEarned + amount);
            checkAchievements();
        }

        function selectCharacter(index) {
            if (!gameState.unlockedCharacters[index]) {
                alert('This character is locked! Visit the shop to unlock.');
                return;
            }

            startGame(index);
        }

        function startGame(charIndex) {
            // Hide menus
            document.getElementById('characterSelect').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';

            document.getElementById('statsPanel').style.display = 'block';

            // Show mobile controls if on mobile device
            const mobileControls = document.getElementById('mobileControls');
            if (mobileControls && window.innerWidth <= 768) {
                mobileControls.style.display = 'block';
            }

            // Hard reset runtime state so restarts don't inherit previous run
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';
            clearDomSprites();
            gameState.lastFrame = 0;
            touching = false;
            mouseDown = false;
            // clear pressed keys (prevents 'stuck moving' after restart)
            for (const k in keys) { keys[k] = false; }

            // Initialize player
            const char = characters[charIndex];
            player.x = WORLD.w / 2;
            player.y = WORLD.h / 2;
            camera.x = player.x;
            camera.y = player.y;
            player.health = (Number.isFinite(char.baseHealth) ? char.baseHealth : 110);
            player.maxHealth = (Number.isFinite(char.baseHealth) ? char.baseHealth : 110);
            player.damage = char.baseDamage;
            player.attackRange = char.attackRange;
            player.attackSpeed = char.attackSpeed;
            player.moveSpeed = char.moveSpeed;
            player.projectileSpeed = char.projectileSpeed;
            player.xp = 0;
            player.level = 1;
            player.xpToNext = 30; // First level is very easy - only 3 kills needed!
            player.kills = 0;
            player.character = char;
            player.upgrades = [];
            player.boomerangs = [];
            player.shield = 0;
            player.armor = 0;
            player.thorns = 0;
            player.lastUltimate = performance.now();
            player.ultimateReady = false;
            player.lastAttack = 0;
            player.animState = 'idle';
            player.animStateTimer = 0;
            player.dead = false;

            // Apply permanent upgrades
            player.maxHealth += gameState.permanentUpgrades.health * 10;
            player.health = player.maxHealth;
            player.damage += gameState.permanentUpgrades.damage * 3;
            player.moveSpeed *= (1 + gameState.permanentUpgrades.speed * 0.05);

            // DYNAMIC DIFFICULTY SYSTEM
            // Calculate difficulty multiplier based on character power and shop upgrades
            let difficultyMultiplier = 1.0;

            // Character-based difficulty (ranged characters are easier, so increase difficulty)
            if (char.type === 'archer') {
                difficultyMultiplier += 0.25; // Luna is ranged and fast - increase difficulty
            } else if (char.type === 'swordsman') {
                difficultyMultiplier += 0.15; // Blade is balanced - slight increase
            }
            // Rex (brawler) keeps base difficulty as he's melee and tankier

            // Shop upgrade difficulty scaling
            const totalUpgrades = Object.values(gameState.permanentUpgrades).reduce((a, b) => a + b, 0);
            if (totalUpgrades > 0) {
                // Each shop upgrade increases difficulty by 3%
                difficultyMultiplier += totalUpgrades * 0.03;
            }

            // Store difficulty multiplier for use in enemy spawning
            player.difficultyMultiplier = difficultyMultiplier;

            // Clear arrays
            enemies.length = 0;
            projectiles.length = 0;
            xpOrbs.length = 0;
            bossFireballs.length = 0;

            // Reset timer
            gameTimer = 300;
            finalBossTimer = 0;
            lastTimerUpdate = performance.now();
            lastEnemySpawn = performance.now();

            // Reset boss events
            window.triggeredBossEvents = new Set();
            bossLockdownUntil = 0;
            finalBossActive = false;
            finalBossSpawned = false;
            finalBossIds.clear();
            if (window._spiralFireballInterval) {
                clearInterval(window._spiralFireballInterval);
                window._spiralFireballInterval = null;
            }
            if (window._waveFireballInterval) {
                clearInterval(window._waveFireballInterval);
                window._waveFireballInterval = null;
            }

            // Update HUD
            updateHUD();

            updateStatsPanel();

            // Start game loop
            gameState.screen = 'playing';
            gameLoop();
        }


        function updateStatsPanel() {
            if (!player) return;

            document.getElementById('statDamage').textContent = Math.floor(player.damage);
            document.getElementById('statAttackSpeed').textContent = player.attackSpeed.toFixed(2);
            document.getElementById('statMoveSpeed').textContent = player.moveSpeed.toFixed(2);
            document.getElementById('statCritChance').textContent = Math.floor(((player.critChance || 0) + (player.critBonus || 0)) * 100) + '%';
            document.getElementById('statMaxHP').textContent = player.maxHealth;
            document.getElementById('statDefense').textContent = (player.damageReduction ? Math.floor(player.damageReduction * 100) : 0) + '%';
            document.getElementById('statXPMult').textContent = (player.xpBonus || 1).toFixed(2) + 'x';
            document.getElementById('statDodge').textContent = Math.floor((player.dodgeChance || 0) * 100) + '%';
        }

        function updateHUD() {
            // Health (clamp to 0 minimum to prevent negative display)
            const healthPercent = Math.max(0, (player.health / player.maxHealth) * 100);
            document.getElementById('healthFill').style.width = healthPercent + '%';
            document.getElementById('healthText').textContent = Math.max(0, Math.ceil(player.health)) + '/' + player.maxHealth;

            // Timer - show countdown normally, count up during final boss
            if (finalBossActive) {
                const fbMinutes = Math.floor(finalBossTimer / 60);
                const fbSeconds = Math.floor(finalBossTimer % 60);
                document.getElementById('timerValue').textContent = '+' + fbMinutes + ':' + (fbSeconds < 10 ? '0' : '') + fbSeconds;
            } else {
                const minutes = Math.floor(gameTimer / 60);
                const seconds = Math.floor(gameTimer % 60);
                document.getElementById('timerValue').textContent = minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
            }

            // Level
            document.getElementById('levelValue').textContent = player.level;

            // Kills
            document.getElementById('killsValue').textContent = player.kills;

            // XP
            const xpPercent = (player.xp / player.xpToNext) * 100;
            document.getElementById('xpFill').style.width = xpPercent + '%';

            // Check achievements periodically (every 60 frames = ~1 second)
            if (!window.achievementCheckCounter) window.achievementCheckCounter = 0;
            window.achievementCheckCounter++;
            if (window.achievementCheckCounter >= 60) {
                window.achievementCheckCounter = 0;
                checkAchievements();
            }

            // Final Boss Health Bar
            const bossBar = document.getElementById('bossBossBar');
            if (finalBossActive && finalBossSpawned && bossBar) {
                bossBar.style.display = 'block';

                // Collect all 5 warlords (alive or dead-but-not-yet-spliced)
                const warlords = enemies.filter(e => e && e.isFinalBoss);
                const TOTAL_MAX = 100000; // 5 √ó 20k
                let totalHP = 0;
                for (let i = 0; i < warlords.length; i++) {
                    totalHP += Math.max(0, warlords[i].health);
                }
                // Clamp (dead enemies still linger briefly with negative health)
                totalHP = Math.max(0, Math.min(TOTAL_MAX, totalHP));

                const pct = (totalHP / TOTAL_MAX) * 100;
                document.getElementById('bossFill').style.width = pct + '%';
                document.getElementById('bossBarText').textContent =
                    totalHP.toLocaleString() + ' / ' + TOTAL_MAX.toLocaleString();

                // Animate the outer bar glow
                const outer = bossBar.querySelector('.boss-bar-outer');
                if (outer) outer.style.animation = 'bossBarPulse 1.4s ease-in-out infinite';

                // Update per-warlord pips (order matches spawn order 0-4)
                for (let i = 0; i < 5; i++) {
                    const pip = document.getElementById('bossPip' + i);
                    if (!pip) continue;
                    // Find the i-th warlord by spawn index embedded in its id (boss1_<i>_...)
                    const warlord = enemies.find(e => e && e.isFinalBoss && e.id && e.id.startsWith('boss1_' + i + '_'));
                    if (warlord && !warlord.dead) {
                        pip.classList.remove('dead');
                    } else {
                        pip.classList.add('dead');
                    }
                }
            } else if (bossBar) {
                bossBar.style.display = 'none';
            }
        }

        function spawnEnemy() {
            try {
                // 1. Safety Checks
                // Pause normal spawns during boss events / final boss to prevent freezing
                if (typeof inBossLockdown === "function" && inBossLockdown()) return;

                // Hard cap for performance
                if (typeof MAX_ENEMIES !== "undefined" && enemies.length >= MAX_ENEMIES) return;

                // 2. Position Calculation
                // Spawn in a ring around the player (open-world + camera follow)
                // Using a distance based on canvas size to ensure they spawn off-screen
                const spawnDist = Math.max(canvas.width, canvas.height) * 0.38 + 60;
                const ang = Math.random() * Math.PI * 2;
                let x = player.x + Math.cos(ang) * spawnDist;
                let y = player.y + Math.sin(ang) * spawnDist;

                // Clamp to world bounds
                if (typeof WORLD !== "undefined") {
                    x = Math.max(40, Math.min(x, WORLD.w - 40));
                    y = Math.max(40, Math.min(y, WORLD.h - 40));
                }

                // 3. Progressive Difficulty Scaling
                // Assuming gameTimer is a countdown from 300 seconds
                const minutesSurvived = Math.max(0, (300 - gameTimer) / 60);

                // Boss spawning - only after 1 minute of survival
                const canSpawnBoss = minutesSurvived >= 1.0;
                const isBoss = canSpawnBoss && Math.random() < 0.04;

                // Time + player level scaling
                const timeScale = 1 + Math.min(2.8, minutesSurvived * 0.55);
                const powerScale = 1 + Math.min(2.0, (player.level || 1) * 0.06);
                const difficulty = timeScale * powerScale * (player.difficultyMultiplier || 1.0);

                const baseHp = 18;
                const baseDmg = isBoss ? 12 : 5; // contact damage base
                const baseSpeed = 65;

                const radius = isBoss ? 26 : 16;
                const spriteScale = isBoss ? 1.35 : 1.0;

                const maxHealth = Math.round(baseHp * difficulty * (isBoss ? 18 : 1));
                const damage = Math.round(baseDmg * difficulty);
                const speed = (baseSpeed * (isBoss ? 0.85 : 1.0)) * (1 + Math.min(0.7, minutesSurvived * 0.08));

                const id = "e" + (enemyIdSeq++);

                // 4. Push to enemies array
                enemies.push({
                    id,
                    x, y,
                    vx: 0, vy: 0,
                    radius,
                    spriteScale,
                    speed,
                    health: maxHealth,
                    maxHealth,
                    damage,
                    isBoss,
                    dead: false,
                    deadTimer: 0,
                    hurtTimer: 0,
                    facingRight: true,

                    // movement variants used by update loop
                    behavior: Math.random() < 0.15 ? "circler" : (Math.random() < 0.12 ? "zigzag" : "chaser"),
                    circlerAngle: Math.random() * Math.PI * 2,
                    zigzagPhase: 0,

                    // float/wobble used by sprite renderer
                    floatSpeed: (isBoss ? 1.35 : 1.7) + Math.random() * 0.9,
                    floatOffset: Math.random() * Math.PI * 2,
                    wobbleSeed: Math.random() * 9999,

                    // dash / fireball support
                    dashCooldown: isBoss ? 5000 : 0,
                    lastDash: 0,
                    isDashing: false,
                    dashSpeed: 300,
                    dashDuration: 0.5,
                    dashTimer: 0,
                    dashDirX: 0,
                    dashDirY: 0,

                    fireballCooldown: isBoss ? 3000 : 0,
                    lastFireball: 0,

                    // final boss volley support
                    multiStrikeShots: 1,
                    isFinalBoss: false
                });

            } catch (error) {
                console.error("Spawn enemy error:", error);
            }
        }

        function spawnXPOrb(x, y, value) {
            xpOrbs.push({
                x: x,
                y: y,
                radius: 8,
                value: value,
                lifetime: 10000, // 10 seconds
                spawnTime: Date.now()
            });
        }



        function updateActiveUpgrades() {
            const upgradeList = document.getElementById('upgradeList');
            const activeDiv = document.getElementById('activeUpgrades');

            if (!upgradeList || !activeDiv) return;

            const activeUpgrades = [];
            const upgradeNames = {
                'lifesteal': 'Life Steal', 'doubleshot': 'Double Shot', 'multishot': 'Multi-Strike',
                'pierce': 'Piercing', 'crit': 'Critical', 'regen': 'Regeneration',
                'vampire': 'Vampiric', 'explosion': 'Explosive', 'bloodlust': 'Bloodlust',
                'magnet': 'XP Magnet', 'lucky': 'Lucky', 'knockback': 'Knockback', 'frenzy': 'Frenzy'
            };

            player.upgrades.forEach(upgrade => {
                if (upgradeNames[upgrade]) activeUpgrades.push(upgradeNames[upgrade]);
            });

            if (player.boomerangs && player.boomerangs.length > 0) {
                activeUpgrades.push(`Boomerangs x${player.boomerangs.length}`);
            }

            if (player.shield > 0) {
                activeUpgrades.push(`Shield: ${Math.floor(player.shield)}`);
            }

            if (activeUpgrades.length > 0) {
                activeDiv.style.display = 'block';
                upgradeList.innerHTML = activeUpgrades.map(u => `‚Ä¢ ${u}`).join('<br>');
            } else {
                activeDiv.style.display = 'none';
            }
        }


        // Weighted upgrade roll with uniqueness + anti-overflow safety
        function rollUpgradeOptions(count) {
            const opts = [];
            if (!player) return opts;

            const pool = upgradePool.filter(u => {
                if (!u) return false;
                if (u.unique && u.name === 'Piercing' && player.upgrades.includes('pierce')) return false;
                if (u.name === 'Berserker' && player.berserker) return false;
                return true;
            });

            if (pool.length <= count) return pool.slice(0, count);

            const pickOne = (arr) => {
                let total = 0;
                for (const u of arr) total += (typeof u.weight === 'number' ? u.weight : 1);
                let r = Math.random() * total;
                for (let i = 0; i < arr.length; i++) {
                    const w = (typeof arr[i].weight === 'number' ? arr[i].weight : 1);
                    r -= w;
                    if (r <= 0) return i;
                }
                return arr.length - 1;
            };

            const temp = pool.slice();
            for (let i = 0; i < count && temp.length > 0; i++) {
                const idx = pickOne(temp);
                opts.push(temp[idx]);
                temp.splice(idx, 1);
            }
            return opts;
        }


        function levelUp() {

            try { playSfx('levelup'); } catch (e) { }
            gameState.screen = 'levelup';
            document.getElementById('levelUpScreen').style.display = 'flex';

            // Reset upgrade selection
            window.selectedUpgradeIndex = 0;

            // Generate 3 upgrade options (weighted + uniqueness)
            const options = rollUpgradeOptions(3);

            const grid = document.getElementById('upgradesGrid');
            grid.innerHTML = '';

            options.forEach((upgrade, index) => {
                const card = document.createElement('div');
                card.className = `upgrade-card ${index === 0 ? 'selected' : ''}`;

                // Check if this is the first time picking this upgrade
                const upgradeKey = upgrade.name.toLowerCase().replace(/\s+/g, '_');
                const isFirstPick = !player.upgrades || !player.upgrades.includes(upgradeKey);

                // For first pick, show effect description. For repeats, just show the upgrade
                let displayHTML;
                if (isFirstPick) {
                    // First pick: Show full name with effect description
                    displayHTML = `
                        <div class="upgrade-name">${upgrade.name}</div>
                        <div class="upgrade-description">${upgrade.description}</div>
                    `;
                } else {
                    // Repeat pick: Shorter display
                    displayHTML = `
                        <div class="upgrade-name">${upgrade.name}</div>
                        <div class="upgrade-description" style="font-size: 0.9rem; opacity: 0.8;">Level Up</div>
                    `;
                }

                card.innerHTML = displayHTML;
                card.onclick = () => selectUpgrade(upgrade);
                grid.appendChild(card);
            });
        }


        function showUpgradeAnimation(upgradeName, player) {
            if (!player) return;

            const colors = {
                shield: '#00ffff',
                bloodlust: '#ff0000',
                fortified: '#ffa500',
                xpMagnet: '#1e90ff',
                treasureHunter: '#ffd700',
                luckyStrike: '#ffff00',
                ironWill: '#ffffff',
                fury: '#ff00ff',
                lightningSpeed: '#ffff00',
                berserker: '#8B0000',
                frostTouch: '#00ffff',
                // New upgrade colors
                damage: '#ff4444',
                attackSpeed: '#ff8800',
                moveSpeed: '#44ff44',
                health: '#00ff00',
                vampire: '#cc0066',
                explosion: '#ff6600',
                rapidFire: '#ffaa00',
                multiStrike: '#aa00ff',
                thorns: '#996633',
                dodge: '#66ccff',
                burn: '#ff3300',
                chain: '#ccff00',
                generic: '#d4af37'
            };

            const names = {
                shield: 'GHOST SHIELD',
                bloodlust: 'BLOODLUST',
                fortified: 'FORTIFIED',
                xpMagnet: 'XP MAGNET',
                treasureHunter: 'TREASURE HUNTER',
                luckyStrike: 'LUCKY STRIKE',
                ironWill: 'IRON WILL',
                fury: 'FURY',
                lightningSpeed: 'LIGHTNING SPEED',
                berserker: 'BERSERKER',
                frostTouch: 'FROST TOUCH',
                // New upgrade display names
                damage: 'DAMAGE BOOST',
                attackSpeed: 'ATTACK SPEED',
                moveSpeed: 'MOVE SPEED',
                health: 'MAX HEALTH',
                vampire: 'VAMPIRIC AURA',
                explosion: 'EXPLOSIVE STRIKES',
                rapidFire: 'RAPID FIRE',
                multiStrike: 'MULTI-STRIKE',
                thorns: 'THORNS',
                dodge: 'DODGE MASTER',
                burn: 'BURNING RAGE',
                chain: 'CHAIN LIGHTNING',
                generic: 'UPGRADE'
            };

            const color = colors[upgradeName] || '#ffffff';
            const displayName = names[upgradeName] || upgradeName.toUpperCase();

            // Create on-screen flash effect
            const flash = document.createElement('div');
            flash.className = 'upgrade-flash';
            flash.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                font-size: 3rem;
                font-family: 'Bebas Neue', cursive;
                color: ${color};
                text-shadow: 0 0 20px ${color}, 0 0 40px ${color};
                pointer-events: none;
                z-index: 9999;
                animation: upgradeActivate 1s ease-out forwards;
            `;
            flash.textContent = `‚ö° ${displayName} ‚ö°`;
            document.body.appendChild(flash);

            setTimeout(() => {
                flash.remove();
            }, 1000);

            // Create particle burst at player position
            if (!gameState || !gameState.particles) return;

            const particleCount = 20;
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const speed = 3 + Math.random() * 2;
                const size = 3 + Math.random() * 3;

                gameState.particles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 30 + Math.random() * 20,
                    maxLife: 30,
                    color: color,
                    size: size
                });
            }

            // Add pulsing ring
            let ringScale = 0;
            const ringInterval = setInterval(() => {
                ringScale += 0.15;

                if (gameState && gameState.particles && player) {
                    const ringSize = (player.size || 20) * (1 + ringScale * 2);
                    const segments = 16;

                    for (let i = 0; i < segments; i++) {
                        const angle = (Math.PI * 2 * i) / segments;
                        const px = player.x + Math.cos(angle) * ringSize;
                        const py = player.y + Math.sin(angle) * ringSize;

                        gameState.particles.push({
                            x: px,
                            y: py,
                            vx: Math.cos(angle) * 0.5,
                            vy: Math.sin(angle) * 0.5,
                            life: 15,
                            maxLife: 15,
                            color: color,
                            size: 3
                        });
                    }
                }

                if (ringScale >= 1.5) {
                    clearInterval(ringInterval);
                }
            }, 50);
        }

        function selectUpgrade(upgrade) {
            upgrade.apply(player);

            // Show upgrade animation based on upgrade type
            const upgradeName = upgrade.name || '';
            const animationUpgrades = {
                'Ghost Shield': 'shield',
                'Bloodlust': 'bloodlust',
                'Fortified': 'fortified',
                'XP Magnet': 'xpMagnet',
                'Treasure Hunter': 'treasureHunter',
                'Lucky Strike': 'luckyStrike',
                'Iron Will': 'ironWill',
                'Fury': 'fury',
                'Lightning Speed': 'lightningSpeed',
                'Berserker': 'berserker',
                'Frost Touch': 'frostTouch',
                // Add animations for other common upgrades
                'Damage Boost': 'damage',
                'Attack Speed': 'attackSpeed',
                'Move Speed': 'moveSpeed',
                'Max Health': 'health',
                'Vampiric Aura': 'vampire',
                'Explosive Strikes': 'explosion',
                'Rapid Fire': 'rapidFire',
                'Multi-Strike': 'multiStrike',
                'Thorns': 'thorns',
                'Dodge Master': 'dodge',
                'Burning Rage': 'burn',
                'Chain Lightning': 'chain'
            };

            if (animationUpgrades[upgradeName]) {
                showUpgradeAnimation(animationUpgrades[upgradeName], player);
            } else {
                // Show generic animation for upgrades without specific mapping
                showUpgradeAnimation('generic', player);
            }
            document.getElementById('levelUpScreen').style.display = 'none';
            gameState.screen = 'playing';
            updateHUD();

            // Resume game loop (only if not already running)
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            if (!gameState.loopRunning) {
                gameState.loopRunning = true;
                requestAnimationFrame(gameLoop);
            }
        }

        function attack() {
            const now = performance.now() / 1000;

            // Find nearest enemy
            let nearest = null;
            let minDist = Infinity;

            for (let i = 0; i < enemies.length; i++) {
                const e = enemies[i];
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const d = Math.sqrt(dx * dx + dy * dy);
                if (d < minDist) { minDist = d; nearest = e; }
            }

            // No enemies or none in range -> don't attack, don't trigger attack animation
            if (!nearest || minDist > player.attackRange) return;

            // Cooldown (only consumes when we actually have a target in range)
            if (now - player.lastAttack < player.attackSpeed) return;
            player.lastAttack = now;

            // Face target
            player.facingRight = (nearest.x - player.x) >= 0;

            // Play attack animation
            if (player.animState !== 'hurt' && player.animState !== 'dead') {
                player.animState = 'attack';
                player.animStateTimer = 0.5;
            }

            // Ranged vs melee
            if (player.projectileSpeed > 0) {
                const baseAngle = Math.atan2(nearest.y - player.y, nearest.x - player.x);

                const shootProjectile = (angleOffset = 0) => {
                    try { if (player.weapon === 'bone_boomerang') playSfx('boomerang'); } catch (e) { }
                    projectiles.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(baseAngle + angleOffset) * player.projectileSpeed,
                        vy: Math.sin(baseAngle + angleOffset) * player.projectileSpeed,
                        radius: 5,
                        damage: player.damage,
                        range: player.attackRange,
                        traveled: 0,
                        pierce: player.upgrades.includes('pierce')
                    });
                };

                // Double Shot + Multi-Strike stacking (applies to ALL ranged characters)
                const dsLevel = player.upgrades.filter(u => u === 'doubleshot').length;
                const msLevel = player.upgrades.filter(u => u === 'multishot').length;

                // Projectile count rules:
                // - Multi-Strike: base becomes 3 projectiles on first pick, then +1 per pick (3‚Üí4‚Üí5...)
                // - Double Shot: Creates additional volleys with delay, doesn't add to count
                let projCount = 1;
                if (msLevel > 0) projCount = 3 + (msLevel - 1);
                projCount = Math.min(projCount, 12);

                const playShotSfx = () => {
                    try {
                        if (player.name === 'Luna') playSfx('arrow');
                        else playSfx('shoot');
                    } catch (e) { }
                };

                // Function to fire a volley of projectiles
                const fireVolley = () => {
                    if (msLevel > 0) {
                        // Multi-Strike: spread around aim direction
                        const totalSpread = Math.min(0.75, 0.24 * (projCount - 1));
                        for (let i = 0; i < projCount; i++) {
                            const t = (projCount === 1) ? 0 : (i / (projCount - 1)) - 0.5;
                            const off = t * totalSpread;
                            shootProjectile(off);
                        }
                        playShotSfx();
                    } else {
                        // Single shot: fire all projectiles in same direction
                        for (let i = 0; i < projCount; i++) {
                            shootProjectile(0);
                        }
                        playShotSfx();
                    }
                };

                // Fire first volley immediately
                fireVolley();

                // Double Shot: Fire additional delayed volleys
                if (dsLevel > 0) {
                    for (let v = 1; v <= dsLevel; v++) {
                        setTimeout(() => {
                            // Re-find target (enemy might have moved or died)
                            let currentNearest = null;
                            let currentMinDist = Infinity;
                            for (let i = 0; i < enemies.length; i++) {
                                const e = enemies[i];
                                if (e.dead) continue;
                                const dx = e.x - player.x;
                                const dy = e.y - player.y;
                                const d = Math.sqrt(dx * dx + dy * dy);
                                if (d < currentMinDist && d <= player.attackRange) {
                                    currentMinDist = d;
                                    currentNearest = e;
                                }
                            }

                            if (currentNearest) {
                                // Update angle to current target
                                const currentAngle = Math.atan2(currentNearest.y - player.y, currentNearest.x - player.x);
                                const shootDelayedProjectile = (angleOffset = 0) => {
                                    projectiles.push({
                                        x: player.x,
                                        y: player.y,
                                        vx: Math.cos(currentAngle + angleOffset) * player.projectileSpeed,
                                        vy: Math.sin(currentAngle + angleOffset) * player.projectileSpeed,
                                        radius: 5,
                                        damage: player.damage,
                                        range: player.attackRange,
                                        traveled: 0,
                                        pierce: player.upgrades.includes('pierce')
                                    });
                                };

                                // Fire delayed volley
                                if (msLevel > 0) {
                                    const totalSpread = Math.min(0.75, 0.24 * (projCount - 1));
                                    for (let i = 0; i < projCount; i++) {
                                        const t = (projCount === 1) ? 0 : (i / (projCount - 1)) - 0.5;
                                        const off = t * totalSpread;
                                        shootDelayedProjectile(off);
                                    }
                                } else {
                                    for (let i = 0; i < projCount; i++) {
                                        shootDelayedProjectile(0);
                                    }
                                }
                                playShotSfx();
                            }
                        }, v * 150); // 150ms delay between volleys
                    }
                }
            } else {
                // Melee strikes (Double Shot + Multi-Strike)
                const dsLevel = player.upgrades.filter(u => u === 'doubleshot').length;
                const msLevel = player.upgrades.filter(u => u === 'multishot').length;

                // Strike count rules mirror ranged:
                // - Double Shot: +1 strike per pick (1‚Üí2‚Üí3...)
                // - Multi-Strike: base becomes 3 strikes on first pick, then +1 per pick (3‚Üí4‚Üí5...)
                // - If both exist, counts add together.
                let strikes = 1;
                if (msLevel > 0) strikes = 3 + (msLevel - 1);
                strikes += dsLevel;
                strikes = Math.min(strikes, 12);

                const baseAngle = Math.atan2(nearest.y - player.y, nearest.x - player.x);

                const findMeleeTarget = (angle) => {
                    let target = null;
                    let bestDist = Infinity;
                    const angleWindow = 0.75;
                    for (const e of enemies) {
                        if (!e || e.dead) continue;
                        const ex = e.x - player.x;
                        const ey = e.y - player.y;
                        const d = Math.hypot(ex, ey);
                        if (d > player.attackRange + e.radius) continue;
                        const a = Math.atan2(ey, ex);
                        let da = Math.abs(a - angle);
                        da = Math.min(da, Math.PI * 2 - da);
                        if (da <= angleWindow && d < bestDist) {
                            bestDist = d;
                            target = e;
                        }
                    }
                    return target;
                };

                const doStrike = (angle) => {
                    const target = findMeleeTarget(angle) || nearest;
                    if (!target || target.dead) return;

                    let damage = player.damage;
                    const totalCritChance = (player.critChance || 0) + (player.critBonus || 0);
                    if (totalCritChance > 0 && Math.random() < totalCritChance) {
                        damage *= 2;
                        try { playSfx('crit'); } catch (e) { }
                    }

                    target.health -= damage;

                    // Frost Touch: slow + aura on melee hit
                    if (player.frostDuration) {
                        target.slowUntil = performance.now() + (player.frostDuration * 1000);
                        target.slowFactor = 0.7;
                        target.frostFlash = 0.25;
                        frostHitEffects.push({ x: target.x, y: target.y, age: 0, lifetime: 0.35, r: target.radius + 10 });
                        if (frostHitEffects.length > 120) frostHitEffects.splice(0, frostHitEffects.length - 120);
                    }
                    if (target.health <= 0) {
                        markEnemyDead(target);
                    }

                    try {
                        if (player.name === 'Blade') playSfx('sword');
                        else if (player.name === 'Rex') playSfx('punch');
                        else playSfx('slash');
                    } catch (e) { }

                    slashEffects.push({
                        x: player.x,
                        y: player.y,
                        angle: angle,
                        range: player.attackRange,
                        lifetime: 0.3,
                        age: 0
                    });
                };

                if (strikes <= 1) {
                    doStrike(baseAngle);
                } else if (msLevel > 0) {
                    // Multi-Strike: spread strikes slightly in front of the player
                    const totalSpread = Math.min(1.0, 0.30 * (strikes - 1));
                    for (let i = 0; i < strikes; i++) {
                        const t = (strikes === 1) ? 0 : (i / (strikes - 1)) - 0.5;
                        const off = t * totalSpread;
                        setTimeout(() => doStrike(baseAngle + off), i * 110);
                    }
                } else {
                    // Double Shot only: repeated strikes at the same angle
                    doStrike(baseAngle);
                    for (let i = 1; i < strikes; i++) {
                        setTimeout(() => doStrike(baseAngle), i * 110);
                    }
                }

                // Explosive strikes for melee (optimized to reduce lag)
                if (player.explosionChance && Math.random() < player.explosionChance) {
                    try { playSfx('explosion'); } catch (e) { }
                    explosionEffects.push({
                        x: nearest.x,
                        y: nearest.y,
                        radius: 0,
                        maxRadius: 60,
                        lifetime: 0.4,
                        age: 0
                    });

                    // Splash damage to nearby enemies (optimized - only check enemies within range)
                    const explosionRadius = 60;
                    let hitCount = 0;
                    const maxHits = 15; // Limit splash hits to prevent lag

                    for (let i = 0; i < enemies.length && hitCount < maxHits; i++) {
                        const nearbyEnemy = enemies[i];
                        if (nearbyEnemy === nearest || nearbyEnemy.dead) continue;
                        if (nearbyEnemy.isFinalBoss) continue; // final bosses immune to splash

                        // Quick distance check first (cheaper than full calculation)
                        const dx2 = nearbyEnemy.x - nearest.x;
                        const dy2 = nearbyEnemy.y - nearest.y;

                        // Skip if obviously too far
                        if (Math.abs(dx2) > explosionRadius || Math.abs(dy2) > explosionRadius) continue;

                        const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

                        if (dist2 < explosionRadius) {
                            nearbyEnemy.health -= player.damage * 0.5;
                            nearbyEnemy.hurtTimer = 0.18;
                            if (nearbyEnemy.health <= 0) {
                                markEnemyDead(nearbyEnemy);
                            }
                            hitCount++;
                        }
                    }
                }
            }
        }


        function markEnemyDead(enemy) {
            if (!enemy || enemy.dead) return;
            enemy.dead = true;
            enemy.deadTimer = enemy.isBoss ? 0.95 : 0.65;
            enemy.hurtTimer = 0;
            // rewards & XP
            handleEnemyDeath(enemy);
        }

        function castUltimate() {
            if (!player.character) return;

            sounds.playUltimate();
            player.lastUltimate = performance.now();
            player.ultimateReady = false;

            const type = player.character.type;

            if (type === 'brawler') {
                // Rex ultimate - Shockwave
                ultimateEffects.push({
                    type: 'shockwave',
                    x: player.x,
                    y: player.y,
                    radius: 0,
                    maxRadius: 300,
                    lifetime: 1.5,
                    age: 0
                });

                enemies.forEach(enemy => {
                    const dx = enemy.x - player.x;
                    const dy = enemy.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);


                    // Frost slow
                    const slowMul = (enemy.slowUntil && now < enemy.slowUntil) ? (enemy.slowFactor || 0.7) : 1;
                    const eSpeed = enemy.speed * slowMul;
                    if (dist < 300) {
                        enemy.health -= 50;
                        if (enemy.health <= 0) markEnemyDead(enemy);
                    }
                });
            }

            if (type === 'archer') {
                // Luna ultimate - Arrow Storm
                let volleyCount = 0;
                const volleyInterval = setInterval(() => {
                    if (volleyCount >= 3 || player.dead) {
                        clearInterval(volleyInterval);
                        return;
                    }

                    sounds.playArrow();
                    for (let i = 0; i < 12; i++) {
                        const angle = (Math.PI * 2 * i) / 12;
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(angle) * 400,
                            vy: Math.sin(angle) * 400,
                            radius: 8,
                            damage: player.damage * 1.5,
                            range: 500,
                            traveled: 0,
                            pierce: true
                        });
                    }
                    volleyCount++;
                }, 300);
            }

            if (type === 'swordsman') {
                // Blade ultimate - Whirlwind Slash
                ultimateEffects.push({
                    type: 'tornado',
                    x: player.x,
                    y: player.y,
                    radius: 80,
                    lifetime: 2,
                    age: 0,
                    rotation: 0
                });
            }
        }

        function handleEnemyDeath(enemy) {
            player.kills++;

            // Track total kills for achievements
            if (!window.totalKills) window.totalKills = 0;
            window.totalKills++;

            // Life steal
            if (player.lifestealAmt) {
                player.health = Math.min(player.maxHealth, player.health + player.lifestealAmt);
            }

            // Vampiric Aura (stacking % heal per kill)
            if ((player.vampiricHealPct || 0) > 0 || player.upgrades.includes('vampire')) {
                const healPct = (player.vampiricHealPct || 0.05); // legacy fallback
                player.health = Math.min(player.maxHealth, player.health + player.maxHealth * healPct);
                try { playSfx('vampire'); } catch (e) { }
            }

            // Bloodlust (stacking % damage gain per kill)
            if ((player.bloodlustPct || 0) > 0 || player.upgrades.includes('bloodlust')) {
                const pct = (player.bloodlustPct || 0.02); // legacy fallback
                player.damage *= (1 + pct);
            }

            // Spawn XP - Event bosses give HUGE XP rewards!
            let xpValue = 10; // Normal enemy
            if (enemy.isEventBoss) {
                // Event bosses give massive XP based on their event number
                xpValue = 100 + (enemy.eventNumber * 50); // 150, 200, 250, 300 XP
                showToastNotification(`üíÄ EVENT BOSS DEFEATED! +${xpValue} XP! üíÄ`, '#d4af37');
            } else if (enemy.isBoss) {
                xpValue = 50; // Regular boss
            }
            spawnXPOrb(enemy.x, enemy.y, xpValue);

            updateHUD();
        }

        // SPECIAL BOSS EVENT SYSTEM
        function triggerBossEvent(minuteRemaining) {
            try {
                const minutesSurvived = (300 - gameTimer) / 60;
                const difficultyRamp = (1 + Math.min(2.5, minutesSurvived * 0.4)) * (player.difficultyMultiplier || 1.0);

                switch (minuteRemaining) {
                    case 4:
                        // 4 minutes left - First Boss (1 boss)
                        startBossLockdown(20000, false);
                        showToastNotification('‚ö†Ô∏è BOSS EVENT: SHADOW BEAST! ‚ö†Ô∏è', '#ff0000');
                        try { playSfx('warn'); } catch (e) { }
                        setTimeout(() => {
                            spawnEventBoss(4, difficultyRamp, 1);
                        }, 2000);
                        break;

                    case 3:
                        // 3 minutes left - Cross Boss (2 bosses)
                        startBossLockdown(20000, false);
                        showToastNotification('‚ö†Ô∏è BOSS EVENT: CROSSFIRE DEMONS! ‚ö†Ô∏è', '#ff0000');
                        try { playSfx('warn'); } catch (e) { }
                        setTimeout(() => {
                            spawnEventBoss(3, difficultyRamp, 2);
                            spawnCrossFireballs();
                        }, 2000);
                        break;

                    case 2:
                        // 2 minutes left - Wave Boss (3 bosses)
                        startBossLockdown(20000, false);
                        showToastNotification('‚ö†Ô∏è BOSS EVENT: TSUNAMI DEMONS! ‚ö†Ô∏è', '#ff0000');
                        try { playSfx('warn'); } catch (e) { }
                        setTimeout(() => {
                            spawnEventBoss(2, difficultyRamp, 3);
                            spawnWaveFireballs();
                        }, 2000);
                        break;

                    case 1:
                        // 1.5 min mark ‚Äî nothing happens here anymore.
                        // Toast, lockdown, and spawn all fire together at 0:00 (see gameTimer <= 0 block).
                        break;

                    default:
                        break;
                }
            } catch (error) {
                console.error("Boss event error:", error);
            }
        }

        // Spawn special event boss enemy (can spawn multiple)
        function spawnEventBoss(eventNumber, difficultyRamp, count = 1) {
            if (!player || !enemies) {
                console.error("Cannot spawn boss: player or enemies undefined");
                return;
            }

            try {

                // Spawn positions: deterministic angles (prevents bosses stacking in same direction)
                const baseAngle = Math.random() * Math.PI * 2;
                function spawnPos(i, total, baseDist) {
                    const ang = baseAngle + (Math.PI * 2 / total) * i;
                    // Reduce dist until inside bounds (avoids clamp collapsing multiple bosses into same corner)
                    let dist = baseDist;
                    let x, y;
                    for (let k = 0; k < 8; k++) {
                        x = player.x + Math.cos(ang) * dist;
                        y = player.y + Math.sin(ang) * dist;
                        if (x > 60 && x < WORLD.w - 60 && y > 60 && y < WORLD.h - 60) break;
                        dist *= 0.82;
                    }
                    x = clamp(x, 60, WORLD.w - 60);
                    y = clamp(y, 60, WORLD.h - 60);
                    return { x, y, ang };
                }
                // Spawn multiple bosses in different positions
                for (let b = 0; b < count; b++) {
                    // Spawn near player, evenly spaced (prevents stacking)
                    const baseDist = 360 + (eventNumber * 30) + (b * 40);
                    const pos = spawnPos(b, count, baseDist);
                    let x = pos.x;
                    let y = pos.y;
                    // Boss stats scale with event number (later bosses are stronger)
                    const baseHealth = 500 + (eventNumber * 200); // 700, 900, 1100, 1300 (much tankier)
                    const baseDamage = 15 + (eventNumber * 5); // 20, 25, 30, 35 (more dangerous)
                    const bossSpeed = 70 + (eventNumber * 10); // 80, 90, 100, 110

                    // FINAL BOSS: use demon warlords with multi-strike projectile volley (lighter than spiral patterns)
                    const isFinal = (eventNumber === 1);

                    // Scale health with player level to keep bosses challenging
                    const levelScaling = 1 + (player.level * 0.15); // +15% health per player level
                    // Final bosses have a fixed 20k HP each (100k total across 5 warlords)
                    const finalHealth = isFinal ? 20000 : (baseHealth * difficultyRamp * levelScaling);

                    enemies.push({
                        x,
                        y,
                        id: 'boss' + eventNumber + '_' + b + '_' + (enemyIdSeq++),
                        spriteScale: 1.2, // Larger than normal bosses
                        hurtTimer: 0,
                        dead: false,
                        deadTimer: 0,
                        radius: 45, // Bigger radius
                        health: finalHealth,
                        maxHealth: finalHealth,
                        damage: baseDamage * difficultyRamp,
                        speed: bossSpeed,
                        isBoss: true,
                        isEventBoss: true, // Mark as special event boss
                        eventNumber: eventNumber,
                        behavior: 'chase',
                        behaviorTimer: 0,
                        circleAngle: Math.random() * Math.PI * 2,
                        zigzagPhase: 0,
                        facingRight: true,
                        floatSpeed: 1.2 + Math.random() * 0.5,
                        floatOffset: Math.random() * Math.PI * 2,
                        wobbleSeed: Math.random() * 9999,
                        dashCooldown: 4000,
                        lastDash: 0,
                        isDashing: false,
                        dashSpeed: 350,
                        dashDuration: 0.6,
                        dashTimer: 0,
                        dashDirX: 0,
                        dashDirY: 0,
                        fireballCooldown: 2000, // Final boss: same as normal boss
                        lastFireball: 0,
                        multiStrikeShots: 1, // Single shot like normal boss
                        isFinalBoss: isFinal
                    });
                    if (isFinal) finalBossIds.add(enemies[enemies.length - 1].id);
                }
            } catch (error) {
                console.error("Spawn boss error:", error);
            }
        }

        // Boss Event 1: Spiral Fireballs (4 min remaining)
        function spawnSpiralFireballs() {
            // Final boss pattern: reduced fireballs to prevent lag
            if (window._spiralFireballInterval) {
                clearInterval(window._spiralFireballInterval);
                window._spiralFireballInterval = null;
            }

            let angle = 0;
            let wavesRemaining = 20; // Reduced from 40 to prevent freeze
            const FIREBALLS_PER_WAVE = 6; // Reduced from 10 to prevent lag
            const SPAWN_RADIUS = 420;
            const SPEED = 150;
            const MAX_BOSS_FIREBALLS = 100; // Reduced from 260

            window._spiralFireballInterval = setInterval(() => {
                if (gameState.screen !== 'playing' || !player || player.dead) {
                    clearInterval(window._spiralFireballInterval);
                    window._spiralFireballInterval = null;
                    return;
                }

                if (wavesRemaining-- <= 0) {
                    clearInterval(window._spiralFireballInterval);
                    window._spiralFireballInterval = null;
                    return;
                }

                // Cap list size to avoid frame drops if multiple patterns overlap
                if (bossFireballs.length > MAX_BOSS_FIREBALLS) {
                    bossFireballs.splice(0, bossFireballs.length - MAX_BOSS_FIREBALLS);
                }

                for (let i = 0; i < FIREBALLS_PER_WAVE; i++) {
                    const offsetAngle = angle + (Math.PI * 2 / FIREBALLS_PER_WAVE) * i;
                    const x = player.x + Math.cos(offsetAngle) * SPAWN_RADIUS;
                    const y = player.y + Math.sin(offsetAngle) * SPAWN_RADIUS;

                    bossFireballs.push({
                        x: x,
                        y: y,
                        vx: -Math.cos(offsetAngle) * SPEED,
                        vy: -Math.sin(offsetAngle) * SPEED,
                        radius: 15,
                        damage: 15,
                        lifetime: 5
                    });
                }

                angle += 0.3;
            }, 250); // Slightly slower interval (was 200ms)
        }

        // Boss Event 2: Cross Fireballs (3 min remaining)
        function spawnCrossFireballs() {
            try {
                let waveCount = 0;
                const maxWaves = 5;
                console.log('Starting cross fireballs pattern');

                const crossInterval = setInterval(() => {
                    try {
                        if (gameState.screen !== 'playing' || waveCount >= maxWaves) {
                            clearInterval(crossInterval);
                            console.log('Cross fireballs pattern ended');
                            return;
                        }

                        // Horizontal line
                        for (let i = -3; i <= 3; i++) {
                            bossFireballs.push({
                                x: player.x + i * 80,
                                y: player.y - 400,
                                vx: 0,
                                vy: 180,
                                radius: 15,
                                damage: 15,
                                lifetime: 5
                            });
                        }

                        // Vertical line
                        for (let i = -3; i <= 3; i++) {
                            bossFireballs.push({
                                x: player.x - 400,
                                y: player.y + i * 80,
                                vx: 180,
                                vy: 0,
                                radius: 15,
                                damage: 15,
                                lifetime: 5
                            });
                        }

                        waveCount++;
                    } catch (innerError) {
                        console.error('Error in cross fireball interval:', innerError);
                        clearInterval(crossInterval);
                    }
                }, 800);
            } catch (error) {
                console.error('Error starting cross fireballs:', error);
            }
        }

        // Boss Event 3: Wave Fireballs (2 min remaining)

        function spawnWaveFireballs() {
            try {
                // TSUNAMI DEMON pattern: 4 directional waves. Guard against stacked intervals.
                if (window._waveFireballInterval) {
                    clearInterval(window._waveFireballInterval);
                    window._waveFireballInterval = null;
                }

                if (gameState.screen !== 'playing' || !player) {
                    console.log('Wave fireballs cancelled - game not playing or no player');
                    return;
                }

                let waveCount = 0;
                const maxWaves = 8;
                const MAX_BOSS_FIREBALLS = 200;

                console.log('Starting wave fireballs pattern');

                window._waveFireballInterval = setInterval(() => {
                    try {
                        if (gameState.screen !== 'playing' || !player || waveCount >= maxWaves) {
                            clearInterval(window._waveFireballInterval);
                            window._waveFireballInterval = null;
                            console.log('Wave fireballs pattern ended');
                            return;
                        }

                        // Cap list size to avoid frame drops if multiple patterns overlap
                        if (bossFireballs.length > MAX_BOSS_FIREBALLS) {
                            bossFireballs.splice(0, bossFireballs.length - MAX_BOSS_FIREBALLS);
                        }

                        const side = waveCount % 4; // 0=top, 1=right, 2=bottom, 3=left

                        for (let i = 0; i < 8; i++) {
                            let x, y, vx, vy;

                            if (side === 0) { // Top
                                x = player.x - 300 + i * 75;
                                y = player.y - 400;
                                vx = 0;
                                vy = 160;
                            } else if (side === 1) { // Right
                                x = player.x + 400;
                                y = player.y - 300 + i * 75;
                                vx = -160;
                                vy = 0;
                            } else if (side === 2) { // Bottom
                                x = player.x - 300 + i * 75;
                                y = player.y + 400;
                                vx = 0;
                                vy = -160;
                            } else { // Left
                                x = player.x - 400;
                                y = player.y - 300 + i * 75;
                                vx = 160;
                                vy = 0;
                            }

                            if (!Number.isFinite(x) || !Number.isFinite(y)) continue;

                            bossFireballs.push({
                                x: x,
                                y: y,
                                vx: vx,
                                vy: vy,
                                radius: 15,
                                damage: 15,
                                lifetime: 5
                            });
                        }

                        waveCount++;
                    } catch (innerError) {
                        console.error('Error in wave fireball interval:', innerError);
                        clearInterval(window._waveFireballInterval);
                        window._waveFireballInterval = null;
                    }
                }, 600);
            } catch (error) {
                console.error('Error starting wave fireballs:', error);
            }
        }

        // Boss Event 4: Circle of Doom (1 min remaining) - Player trapped in middle
        function spawnCircleOfDoom() {
            showToastNotification('üî• DODGE THE INCOMING FIREBALLS! üî•', '#ff6600');

            let phase = 0;
            const maxPhases = 15;
            const doomInterval = setInterval(() => {
                if (gameState.screen !== 'playing' || phase >= maxPhases) {
                    clearInterval(doomInterval);
                    return;
                }

                // Spawn fireballs in a circle around player
                const numFireballs = 16;
                const radius = 450;

                for (let i = 0; i < numFireballs; i++) {
                    const angle = (Math.PI * 2 / numFireballs) * i + (phase * 0.3);
                    const x = player.x + Math.cos(angle) * radius;
                    const y = player.y + Math.sin(angle) * radius;

                    // Fire towards player with slight randomness
                    const targetAngle = Math.atan2(player.y - y, player.x - x);
                    const randomOffset = (Math.random() - 0.5) * 0.3;

                    bossFireballs.push({
                        x: x,
                        y: y,
                        vx: Math.cos(targetAngle + randomOffset) * 140,
                        vy: Math.sin(targetAngle + randomOffset) * 140,
                        radius: 18,
                        damage: 20,
                        lifetime: 5
                    });
                }

                try { playSfx('fireball'); } catch (e) { }
                phase++;
            }, 500);
        }

        function gameLoop() {
            if (!gameState || gameState.screen !== 'playing') {
                requestAnimationFrame(gameLoop);
                return;
            }

            const now = performance.now();
            if (!gameState.lastFrame) gameState.lastFrame = now;

            // FPS cap to prevent speedup (target 60 FPS = 16.67ms per frame)
            const frameDelay = now - gameState.lastFrame;
            if (frameDelay < 16) {
                // Too soon, skip this frame
                requestAnimationFrame(gameLoop);
                return;
            }

            let dt = frameDelay / 1000;
            gameState.lastFrame = now;
            dt = Math.min(0.033, Math.max(0.001, dt)); // clamp (30-1000 fps)
            dt *= TIME_SCALE;

            // Safety: prevent NaN health breaking UI/logic
            if (!Number.isFinite(player.health)) player.health = player.maxHealth || 110;
            if (!Number.isFinite(player.maxHealth)) player.maxHealth = 110;
            player.health = Math.max(0, Math.min(player.health, player.maxHealth));

            // Boss event housekeeping (prevents 'frozen' state after bosses die)
            try { updateBossEventState(); } catch (e) { console.error('updateBossEventState error', e); }
            // Debug: Log if game speed seems wrong
            if (dt > 0.05) {
                console.warn('Large dt detected:', dt, 'frames may be skipping');
            }

            // IMPORTANT: dt affects ALL game entities equally - never modify dt based on player stats!
            const baseDt = dt; // Store unmodified dt for timer calculations
            const GAME_SPEED = 1.0; // kept for legacy multipliers (now neutral)

            // Clear canvas (world is drawn as tiles)
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Camera follows player (open world)
            camera.x += (player.x - camera.x) * CAMERA_LERP;
            camera.y += (player.y - camera.y) * CAMERA_LERP;


            clampCameraToBounds();
            // World transform
            ctx.setTransform(1, 0, 0, 1, canvas.width / 2 - camera.x, canvas.height / 2 - camera.y);

            // Draw world tiles (open world)
            drawTiles();

            // Tile debug HUD (top-left under UI panels)
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.fillRect(16, 140, 210, 24);
            ctx.fillStyle = '#d4af37';
            ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
            // ctx.fillText(`Tiles: FLOOR=${FLOOR_TILE}  WALL=${WALL_TILE}  ( [ ] ; ' )  R=regen`, 22, 156);
            ctx.restore();

            // Subtle vignette in screen-space
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            const vg = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 50, canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) * 0.65);
            vg.addColorStop(0, 'rgba(0,0,0,0)');
            vg.addColorStop(1, 'rgba(0,0,0,0.55)');
            ctx.fillStyle = vg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Back to world transform for entities
            ctx.setTransform(1, 0, 0, 1, canvas.width / 2 - camera.x, canvas.height / 2 - camera.y);



            // Update timer
            if (now - lastTimerUpdate > 1000) {
                if (finalBossActive) {
                    finalBossTimer++; // Count UP during final boss
                } else {
                    gameTimer--;

                    // SPECIAL BOSS EVENT SYSTEM - triggers at specific time marks
                    // Timer counts DOWN from 300 (5:00) to 0
                    // Events at: 4 min left (240s), 3 min left (180s), 2 min left (120s), 1.5 min left (90s)
                    const timeRemaining = gameTimer;

                    // Track which events have been triggered
                    if (!window.triggeredBossEvents) window.triggeredBossEvents = new Set();

                    // Trigger boss events at specific thresholds
                    // Use <= only (no upper bound) so events can never be skipped if a tick jumps past them
                    if (timeRemaining <= 240 && !window.triggeredBossEvents.has(4)) {
                        window.triggeredBossEvents.add(4);
                        triggerBossEvent(4); // 4 minutes remaining
                    }
                    if (timeRemaining <= 180 && !window.triggeredBossEvents.has(3)) {
                        window.triggeredBossEvents.add(3);
                        triggerBossEvent(3); // 3 minutes remaining
                    }
                    if (timeRemaining <= 120 && !window.triggeredBossEvents.has(2)) {
                        window.triggeredBossEvents.add(2);
                        triggerBossEvent(2); // 2 minutes remaining
                    }
                    if (timeRemaining <= 90 && !window.triggeredBossEvents.has(1)) {
                        window.triggeredBossEvents.add(1);
                        triggerBossEvent(1); // 1.5 minutes remaining - FINAL BOSS EVENT
                    }

                    // Timer reached 0 ‚Äî this is where the final boss phase actually begins.
                    // Timer hit 0 ‚Äî toast, lockdown, and spawn all happen here together.
                    if (gameTimer <= 0) {
                        if (!finalBossActive) {
                            // Show the final boss announcement right now at 0:00
                            showToastNotification('üî• FINAL BOSS: DEMON WARLORDS! üî•', '#ff0000');
                            try { playSfx('warn'); } catch (e) { }

                            // Activate final boss phase: freezes countdown, switches to count-up
                            startBossLockdown(99999999, true);
                            finalBossTimer = 0;

                            // Recalculate difficulty at the moment of spawn
                            const minutesSurvived = (300 - gameTimer) / 60;
                            const diffRamp = (1 + Math.min(2.5, minutesSurvived * 0.4)) * (player.difficultyMultiplier || 1.0);

                            // Spawn after 2s dramatic pause; set finalBossSpawned only after they exist
                            setTimeout(() => {
                                spawnEventBoss(1, diffRamp, 5);
                                finalBossSpawned = true;
                            }, 2000);
                        }
                        // If finalBossActive is already true we're in count-up mode ‚Äî do nothing here.
                    }
                }
                lastTimerUpdate = now;
            }

            // Boss lockdown: keep fights clean (prevents spawn overload/freezes)
            if (inBossLockdown()) {
                purgeNonBossEnemies();
            }

            // Regeneration
            if (player.regenRate) {
                player.health = Math.min(player.maxHealth, player.health + player.regenRate * dt);
            }


            // Check ultimate cooldown (30 seconds)
            if (now - player.lastUltimate > 30000 && !player.ultimateReady) {
                player.ultimateReady = true;
                // Ultimate indicator at bottom will show it's ready (no toast)
            }

            // Update ultimate indicator
            const ultIndicator = document.getElementById('ultimateIndicator');
            if (ultIndicator) {
                ultIndicator.style.display = player.ultimateReady ? 'block' : 'none';
            }

            // Player movement
            let dx = 0;
            let dy = 0;

            // Can't move when dead
            if (!player.dead) {
                // Keyboard controls
                if (keys['w'] || keys['arrowup']) dy -= 1;
                if (keys['s'] || keys['arrowdown']) dy += 1;
                if (keys['a'] || keys['arrowleft']) dx -= 1;
                if (keys['d'] || keys['arrowright']) dx += 1;

                // Virtual joystick (mobile)
                if (joystick.active) {
                    dx += joystick.deltaX;
                    dy += joystick.deltaY;
                }

                // Touch/mouse movement (fallback for non-joystick touch)
                if ((touching || keys[' ']) && !joystick.active) {
                    const tdx = mouseX - player.x;
                    const tdy = mouseY - player.y;
                    const dist = Math.sqrt(tdx * tdx + tdy * tdy);

                    if (dist > 30) {
                        dx = tdx / dist;
                        dy = tdy / dist;
                    }
                }

                // Normalize diagonal movement
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len > 0) {
                    dx = (dx / len);
                    dy = (dy / len);

                    // Only set walk animation if not in a timed animation state
                    if (player.animStateTimer <= 0 && player.animState !== 'dead') {
                        player.animState = 'walk';
                    }
                    player.facingRight = dx > 0;
                } else {
                    // Only return to idle if not in a timed animation state
                    if (player.animStateTimer <= 0 && player.animState === 'walk') {
                        player.animState = 'idle';
                    }
                }

                player.x += dx * player.moveSpeed * dt; // moveSpeed is pixels per second
                player.y += dy * player.moveSpeed * dt;

                // Keep player in bounds
                const pb = getPlayBounds();
                player.x = clamp(player.x, pb.minX + player.radius, pb.maxX - player.radius);
                player.y = clamp(player.y, pb.minY + player.radius, pb.maxY - player.radius);
            }

            // Update boomerangs
            if (player.boomerangs && player.boomerangs.length > 0) {
                player.boomerangs.forEach(boom => {
                    boom.angle += boom.speed * dt;

                    // Calculate boomerang position
                    const boomX = player.x + Math.cos(boom.angle) * boom.distance;
                    const boomY = player.y + Math.sin(boom.angle) * boom.distance;

                    // Check collision with enemies
                    enemies.forEach(enemy => {
                        if (enemy.dead) return;
                        const dx = enemy.x - boomX;
                        const dy = enemy.y - boomY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < enemy.radius + boom.radius) {
                            enemy.health -= boom.damage * dt;
                            enemy.hurtTimer = 0.1;
                            if (enemy.health <= 0) {
                                markEnemyDead(enemy);
                            }
                        }
                    });
                });
            }

            // Spawn enemies - gradually increase spawn rate over time + difficulty scaling
            const minutesSurvived = (300 - gameTimer) / 60;
            // Start at 2.0s, gradually decrease to 0.8s over 5 minutes
            let spawnRateMultiplier = Math.max(0.4, 1.0 - (minutesSurvived * 0.12));

            // Apply difficulty-based spawn rate increase
            // Higher difficulty = faster spawns (lower multiplier)
            if (player.difficultyMultiplier > 1.0) {
                spawnRateMultiplier *= Math.max(0.7, 1.0 / player.difficultyMultiplier);
            }

            const spawnInterval = enemySpawnRate * 1000 * spawnRateMultiplier;

            if (now - lastEnemySpawn > spawnInterval) {
                // Only spawn if not in boss lockdown
                if (!inBossLockdown()) {
                    spawnEnemy();
                } else {
                    console.log('Boss lockdown active - enemy spawn blocked');
                }
                lastEnemySpawn = now;
            }

            // HORDE WARNING SYSTEM - spawn large hordes periodically (only after 1 minute)
            const hordeInterval = 50000; // Every 50 seconds (offset from boss events)
            if (!window.lastHordeTime) window.lastHordeTime = now;

            // Only trigger hordes after 1 minute of survival
            const minutesForHorde = (300 - gameTimer) / 60;
            // Check if we're near a boss event time to avoid overlap
            const timeRemaining = Math.ceil(gameTimer);
            const nearBossEvent = (timeRemaining > 235 && timeRemaining < 245) || // 4 min boss
                (timeRemaining > 175 && timeRemaining < 185) || // 3 min boss
                (timeRemaining > 115 && timeRemaining < 125) || // 2 min boss
                (timeRemaining > 85 && timeRemaining < 95);     // 1.5 min boss

            if (minutesForHorde >= 1.0 && now - window.lastHordeTime >= hordeInterval) {
                // Skip this horde if boss event is imminent
                if (nearBossEvent) {
                    window.lastHordeTime = now; // Reset timer to try again later
                    return; // Skip this horde
                }
                window.lastHordeTime = now;
                // Ensure minimum delay between event toasts
                if (window.lastEventToast && now - window.lastEventToast < 5000) {
                    return; // Wait at least 5 seconds between event notifications
                }
                window.lastEventToast = now;



                // Skip horde during boss lockdown (boss fights should be clean)
                if (inBossLockdown()) {
                    return;
                }

                // If we're already near the cap, skip the horde to avoid freezing
                if (enemies.length >= HORDE_BLOCK_AT) {
                    return;
                }

                // Show warning toast
                showToastNotification('‚ö†Ô∏è LARGE HORDE INCOMING! ‚ö†Ô∏è', '#ff3333');
                try { playSfx('warn'); } catch (e) { }

                // Spawn horde after 3 seconds
                setTimeout(() => {
                    // Horde size scales with level AND difficulty
                    let hordeSize = 12 + Math.floor(player.level * 1.5);
                    hordeSize = Math.floor(hordeSize * (player.difficultyMultiplier || 1.0));

                    for (let i = 0; i < hordeSize; i++) {
                        setTimeout(() => {
                            if (!inBossLockdown() && enemies.length < MAX_ENEMIES) spawnEnemy();
                        }, i * 80); // Stagger spawns slightly
                    }
                }, 3000);
            }



            // Update and draw burn effects
            ctx.save();
            for (let i = burnEffects.length - 1; i >= 0; i--) {
                const burn = burnEffects[i];
                burn.x += burn.vx;
                burn.y += burn.vy;
                burn.vy -= 0.08; // Rise up
                burn.life--;

                if (burn.life <= 0) {
                    burnEffects.splice(i, 1);
                    continue;
                }

                const alpha = burn.life / burn.maxLife;
                ctx.fillStyle = burn.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                ctx.shadowColor = burn.color;
                ctx.shadowBlur = 8;

                ctx.beginPath();
                ctx.arc(burn.x, burn.y, burn.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // Apply burn damage over time
            enemies.forEach(e => {
                if (e.burning && now < e.burnEndTime) {
                    // Tick damage every 0.5 seconds
                    if (now - e.lastBurnTick > 500) {
                        e.health -= e.burnDamage;
                        e.hurtTimer = 0.15;
                        e.lastBurnTick = now;

                        // Spawn fire particle
                        burnEffects.push({
                            x: e.x + (Math.random() - 0.5) * e.radius,
                            y: e.y + (Math.random() - 0.5) * e.radius,
                            vx: (Math.random() - 0.5),
                            vy: -Math.random() * 2,
                            life: 20,
                            maxLife: 20,
                            size: 2 + Math.random() * 2,
                            color: Math.random() < 0.5 ? '#ff4400' : '#ff6600'
                        });

                        if (e.health <= 0) {
                            markEnemyDead(e);
                        }
                    }
                } else if (e.burning) {
                    e.burning = false;
                }
            });

            // Draw lightning bolts (Chain Lightning)
            ctx.save();
            if (window.lightningBolts) {
                for (let i = lightningBolts.length - 1; i >= 0; i--) {
                    const bolt = lightningBolts[i];
                    bolt.life--;

                    if (bolt.life <= 0) {
                        lightningBolts.splice(i, 1);
                        continue;
                    }

                    const alpha = bolt.life / bolt.maxLife;

                    // Check if bolt has points array (new chain lightning) or x1/y1/x2/y2 (old style)
                    if (bolt.points && bolt.points.length > 0) {
                        // New style: draw through points array
                        ctx.strokeStyle = `rgba(100, 149, 237, ${alpha})`;
                        ctx.shadowColor = 'rgba(173, 216, 230, 0.8)';
                        ctx.shadowBlur = 12;
                        ctx.lineWidth = 3;

                        ctx.beginPath();
                        ctx.moveTo(bolt.points[0].x, bolt.points[0].y);
                        for (let p = 1; p < bolt.points.length; p++) {
                            ctx.lineTo(bolt.points[p].x, bolt.points[p].y);
                        }
                        ctx.stroke();

                        // Thicker glow layer
                        ctx.strokeStyle = `rgba(173, 216, 230, ${alpha * 0.5})`;
                        ctx.lineWidth = 6;
                        ctx.shadowBlur = 18;
                        ctx.stroke();

                        // Glow at end point
                        const endPoint = bolt.points[bolt.points.length - 1];
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.arc(endPoint.x, endPoint.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (bolt.x1 !== undefined) {
                        // Old style: zigzag between two points
                        ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`;
                        ctx.shadowColor = '#ffff00';
                        ctx.shadowBlur = 15;
                        ctx.lineWidth = 3;

                        ctx.beginPath();
                        ctx.moveTo(bolt.x1, bolt.y1);

                        // Create zigzag effect
                        const segments = 4;
                        for (let s = 1; s < segments; s++) {
                            const t = s / segments;
                            const midX = bolt.x1 + (bolt.x2 - bolt.x1) * t;
                            const midY = bolt.y1 + (bolt.y2 - bolt.y1) * t;
                            const offsetX = (Math.random() - 0.5) * 30;
                            const offsetY = (Math.random() - 0.5) * 30;
                            ctx.lineTo(midX + offsetX, midY + offsetY);
                        }

                        ctx.lineTo(bolt.x2, bolt.y2);
                        ctx.stroke();

                        // Add glow points at ends
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.arc(bolt.x2, bolt.y2, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            ctx.restore();

            // Update and draw enemies
            const time = Date.now() / 1000;
            for (let ei = enemies.length - 1; ei >= 0; ei--) {
                const enemy = enemies[ei];

                // Timers
                if (enemy.hurtTimer > 0) enemy.hurtTimer = Math.max(0, enemy.hurtTimer - dt);
                if (enemy.frostFlash > 0) enemy.frostFlash = Math.max(0, enemy.frostFlash - dt);

                // Floating animation (used for both canvas + DOM sprites)
                const floatY = Math.sin(time * enemy.floatSpeed + enemy.floatOffset) * 5;

                if (enemy.dead) {
                    enemy.deadTimer -= dt;

                    // Update DOM sprite (dead)
                    if (USE_DOM_SPRITES && spriteOverlay) {
                        const sx = (enemy.x - camera.x) + canvas.width / 2;
                        const sy = (enemy.y - camera.y) + canvas.height / 2 + floatY;
                        const src = enemy.isBoss ? ENEMY_SPRITES.boss.dead : ENEMY_SPRITES.normal.dead;
                        const sizePx = Math.max(28, (enemy.radius * 2) * (enemy.spriteScale || 1));
                        setEnemyDomSprite(enemy, src, sx, sy, sizePx);
                    }

                    if (enemy.deadTimer <= 0) {
                        removeEnemyAtIndex(enemies, ei);
                    }
                    continue;
                }

                // Move towards player with behavior variations
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Update enemy facing direction
                if (Math.abs(dx) > 1) {
                    enemy.facingRight = dx > 0;
                }

                // Calculate enemy speed with slow effects
                const slowMul = (enemy.slowUntil && now < enemy.slowUntil) ? (enemy.slowFactor || 0.7) : 1;
                const eSpeed = enemy.speed * slowMul;

                if (dist > enemy.radius + player.radius) {
                    // ENHANCED ENEMY BEHAVIORS
                    let moveX = 0, moveY = 0;

                    switch (enemy.behavior) {
                        case 'zigzag':
                            // Zigzag pattern while approaching
                            enemy.zigzagPhase += dt * 3;
                            const perpX = -dy / dist;
                            const perpY = dx / dist;
                            const zigzagOffset = Math.sin(enemy.zigzagPhase) * 40;
                            moveX = (dx / dist + perpX * zigzagOffset / 100) * eSpeed * dt;
                            moveY = (dy / dist + perpY * zigzagOffset / 100) * eSpeed * dt;
                            break;

                        case 'circler':
                            // Circle around player at medium distance
                            const preferredDist = 180;
                            if (dist > preferredDist + 50) {
                                // Move closer
                                moveX = (dx / dist) * eSpeed * dt;
                                moveY = (dy / dist) * eSpeed * dt;
                            } else if (dist < preferredDist - 50) {
                                // Move away
                                moveX = -(dx / dist) * eSpeed * dt;
                                moveY = -(dy / dist) * eSpeed * dt;
                            } else {
                                // Circle around
                                enemy.circleAngle += dt * 1.5;
                                const targetX = player.x + Math.cos(enemy.circleAngle) * preferredDist;
                                const targetY = player.y + Math.sin(enemy.circleAngle) * preferredDist;
                                const tdx = targetX - enemy.x;
                                const tdy = targetY - enemy.y;
                                const tdist = Math.sqrt(tdx * tdx + tdy * tdy);
                                if (tdist > 10) {
                                    moveX = (tdx / tdist) * eSpeed * dt;
                                    moveY = (tdy / tdist) * eSpeed * dt;
                                }
                            }
                            break;

                        case 'rusher':
                            // Fast straight rush with brief pauses
                            enemy.behaviorTimer += dt;
                            if (enemy.behaviorTimer < 1.5) {
                                // Rush phase - faster movement
                                moveX = (dx / dist) * enemy.speed * 1.5 * dt;
                                moveY = (dy / dist) * enemy.speed * 1.5 * dt;
                            } else if (enemy.behaviorTimer < 2.0) {
                                // Pause phase
                                moveX = 0;
                                moveY = 0;
                            } else {
                                enemy.behaviorTimer = 0; // Reset cycle
                            }
                            break;

                        case 'retreater':
                            // Hit and run - approaches then retreats
                            enemy.behaviorTimer += dt;
                            if (enemy.behaviorTimer < 2.0) {
                                // Approach phase
                                moveX = (dx / dist) * eSpeed * dt;
                                moveY = (dy / dist) * eSpeed * dt;
                            } else if (enemy.behaviorTimer < 3.5) {
                                // Retreat phase
                                moveX = -(dx / dist) * enemy.speed * 0.8 * dt;
                                moveY = -(dy / dist) * enemy.speed * 0.8 * dt;
                            } else {
                                enemy.behaviorTimer = 0; // Reset cycle
                            }
                            break;

                        case 'chain':
                            // Chain behavior - should have movement
                            moveX = (dx / dist) * eSpeed * dt;
                            moveY = (dy / dist) * eSpeed * dt;
                            // Only beep occasionally, not every frame
                            if (!enemy.lastBeep || now - enemy.lastBeep > 500) {
                                enemy.lastBeep = now;
                                try {
                                    beep({ freq: 900, dur: 0.05, type: 'square', gain: 0.12 });
                                    setTimeout(() => beep({ freq: 1200, dur: 0.04, type: 'square', gain: 0.10 }), 35);
                                    setTimeout(() => beep({ freq: 1500, dur: 0.03, type: 'square', gain: 0.08 }), 65);
                                } catch (e) { }
                            }
                            break;
                        default: // 'chase' - normal behavior
                            moveX = (dx / dist) * eSpeed * dt;
                            moveY = (dy / dist) * eSpeed * dt;
                            break;
                    }

                    enemy.x += moveX;
                    enemy.y += moveY;
                }

                // Boss special attacks
                if (enemy.isBoss && !enemy.dead) {
                    // Dash attack
                    if (!enemy.isDashing && now - enemy.lastDash > enemy.dashCooldown) {
                        enemy.isDashing = true;
                        enemy.dashTimer = enemy.dashDuration;
                        enemy.lastDash = now;
                        const dx = player.x - enemy.x;
                        const dy = player.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        enemy.dashDirX = dx / dist;
                        enemy.dashDirY = dy / dist;
                    }

                    if (enemy.isDashing) {
                        enemy.x += enemy.dashDirX * enemy.dashSpeed * dt;
                        enemy.y += enemy.dashDirY * enemy.dashSpeed * dt;
                        enemy.dashTimer -= dt;
                        if (enemy.dashTimer <= 0) enemy.isDashing = false;
                    }

                    // Fireball attack
                    if (now - enemy.lastFireball > enemy.fireballCooldown) {
                        enemy.lastFireball = now;

                        // Cap boss projectiles to prevent lag
                        const MAX_BOSS_FIREBALLS_DYNAMIC = finalBossActive ? 140 : 220;
                        if (bossFireballs.length > MAX_BOSS_FIREBALLS_DYNAMIC) {
                            bossFireballs.splice(0, bossFireballs.length - MAX_BOSS_FIREBALLS_DYNAMIC);
                        }

                        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        const shots = Math.max(1, enemy.multiStrikeShots || 1);
                        const spread = (shots > 1) ? 0.18 : 0;

                        for (let s = 0; s < shots; s++) {
                            const t = shots === 1 ? 0 : (s - (shots - 1) / 2);
                            const a = angle + t * spread;

                            bossFireballs.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: Math.cos(a) * (finalBossActive ? 210 : 200),
                                vy: Math.sin(a) * (finalBossActive ? 210 : 200),
                                radius: 15,
                                damage: finalBossActive ? 18 : 20,
                                lifetime: 5
                            });
                        }
                    }
                }

                // Collision with player
                if (dist < enemy.radius + player.radius) {
                    // Dodge check ‚Äî roll before any damage lands
                    if (player.dodgeChance && Math.random() < player.dodgeChance) {
                        // Dodged ‚Äî skip all damage and effects for this tick
                    } else {
                        let contactDmg = (enemy.damage || 5) * dt;
                        if (player.damageReduction) contactDmg *= (1 - player.damageReduction);
                        // Ghost Shield absorbs first
                        if (player.shield && player.shield > 0) {
                            player.shield -= contactDmg;
                            if (player.shield < 0) {
                                contactDmg = -player.shield;
                                player.shield = 0;
                            } else {
                                contactDmg = 0;
                            }
                        }
                        player.health -= contactDmg;

                        // Thorns: reflect damage back to attacker
                        if (player.thornsReflect && contactDmg > 0) {
                            enemy.health -= contactDmg * player.thornsReflect;
                            if (enemy.health <= 0 && !enemy.dead) {
                                markEnemyDead(enemy);
                            }
                        }

                        const _nowH = performance.now();
                        if (_nowH - _lastHitSfx > 150) { _lastHitSfx = _nowH; try { playSfx('hit'); } catch (e) { } }

                        // Trigger hurt animation occasionally
                        if (Math.random() < 0.05 && player.animState !== 'dead' && player.animState !== 'attack') {
                            player.animState = 'hurt';
                            player.animStateTimer = 0.3;
                        }

                        if (player.health <= 0) {
                            player.animState = 'dead';
                            player.dead = true;
                            const _nowD = performance.now();
                            if (_nowD - _lastDeathSfx > 500) { _lastDeathSfx = _nowD; try { playSfx('death'); } catch (e) { } }
                            setTimeout(() => {
                                gameOver();
                            }, 1000); // Wait for death animation
                            return;
                        }
                    }
                }


                // Ghost sprite (DOM overlay so GIFs animate reliably)
                if (USE_DOM_SPRITES && spriteOverlay) {
                    const sx = (enemy.x - camera.x) + canvas.width / 2;
                    const sy = (enemy.y - camera.y) + canvas.height / 2 + floatY;

                    let src;
                    if (enemy.isBoss) {
                        src = ENEMY_SPRITES.boss.walk;
                    } else if (enemy.hurtTimer > 0) {
                        src = ENEMY_SPRITES.normal.hurt;
                    } else {
                        src = ENEMY_SPRITES.normal.walk;
                    }
                    const sizePx = Math.max(28, (enemy.radius * 2) * (enemy.spriteScale || 1));
                    setEnemyDomSprite(enemy, src, sx, sy, sizePx);
                } else {
                    // Fallback: simple visible blob if DOM sprites are disabled
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y + floatY);
                    ctx.fillStyle = enemy.isBoss ? 'rgba(255,80,80,0.9)' : 'rgba(210,220,255,0.9)';
                    ctx.beginPath();
                    ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                // Boss indicator - crown
                if (enemy.isBoss) {
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y - enemy.radius - 10 + floatY);
                    ctx.fillStyle = '#FFD700';
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 1;

                    // Crown shape
                    ctx.beginPath();
                    ctx.moveTo(-8, 5);
                    ctx.lineTo(-6, 0);
                    ctx.lineTo(-3, 3);
                    ctx.lineTo(0, -2);
                    ctx.lineTo(3, 3);
                    ctx.lineTo(6, 0);
                    ctx.lineTo(8, 5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                }

                // Health bar
                if (enemy.health < enemy.maxHealth) {
                    const barWidth = enemy.radius * 2;
                    const barHeight = 4;
                    const barX = enemy.x - enemy.radius;
                    const barY = enemy.y - enemy.radius - 15;

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(barX, barY, barWidth, barHeight);

                    ctx.fillStyle = enemy.isBoss ? '#ff0000' : '#00ff00';
                    ctx.fillRect(barX, barY, barWidth * (enemy.health / enemy.maxHealth), barHeight);

                    // Health bar border
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                }

            }

            // Update and draw projectiles
            if (projectiles.length > 650) projectiles.splice(0, projectiles.length - 650);
            if (bossFireballs.length > 320) bossFireballs.splice(0, bossFireballs.length - 320);
            if (xpOrbs.length > 420) xpOrbs.splice(0, xpOrbs.length - 420);
            // Distance-based culling + hard cap (prevents mid/late-run freezing)
            const dd = despawnDistance();
            for (let ei = enemies.length - 1; ei >= 0; ei--) {
                const e = enemies[ei];
                if (!e) { enemies.splice(ei, 1); continue; }
                if (e.isBoss) continue;          // never despawn bosses via distance
                if (e.dead) continue;            // allow death animation
                const d = Math.hypot(e.x - player.x, e.y - player.y);
                if (d > dd) { try { removeEnemyDomImg(e); } catch (_) { } enemies.splice(ei, 1); }
            }

            pruneEnemiesToCap();

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];

                proj.x += proj.vx * dt;
                proj.y += proj.vy * dt;
                proj.traveled += Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy) * dt;

                // Remove if out of range
                if (proj.traveled > proj.range) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // Check collision with enemies
                let hit = false;
                for (let ei = 0; ei < enemies.length; ei++) {
                    const enemy = enemies[ei];
                    if (!enemy || enemy.dead) continue;

                    const dx = enemy.x - proj.x;
                    const dy = enemy.y - proj.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < enemy.radius + proj.radius) {
                        let damage = proj.damage;

                        const totalCritChance = (player.critChance || 0) + (player.critBonus || 0);
                        if (totalCritChance > 0 && Math.random() < totalCritChance) {
                            damage *= 2;
                            try { playSfx('crit'); } catch (e) { }
                        }

                        enemy.health -= damage;

                        // Frost Touch: slow + blue aura on hit (reduced on bosses)
                        if (player.frostDuration) {
                            enemy.slowUntil = performance.now() + (player.frostDuration * 1000);
                            enemy.slowFactor = 0.7; // 30% slow
                            enemy.frostFlash = 0.25;
                            // Skip visual effects on bosses to prevent lag
                            if (!enemy.isBoss) {
                                frostHitEffects.push({ x: enemy.x, y: enemy.y, age: 0, lifetime: 0.35, r: enemy.radius + 10 });
                                if (frostHitEffects.length > 120) frostHitEffects.splice(0, frostHitEffects.length - 120);
                            }
                        }

                        // Burning Rage: burn enemies over time with fire particles
                        if (player.burnDuration) {
                            enemy.burning = true;
                            enemy.burnEndTime = performance.now() + (player.burnDuration * 1000);
                            enemy.burnDamage = damage * 0.3; // 30% of hit damage per tick
                            enemy.lastBurnTick = performance.now();

                            // Create initial burst of fire particles
                            for (let f = 0; f < 5; f++) {
                                burnEffects.push({
                                    x: enemy.x + (Math.random() - 0.5) * enemy.radius,
                                    y: enemy.y + (Math.random() - 0.5) * enemy.radius,
                                    vx: (Math.random() - 0.5) * 2,
                                    vy: -Math.random() * 3,
                                    life: 25,
                                    maxLife: 25,
                                    size: 3 + Math.random() * 3,
                                    color: Math.random() < 0.5 ? '#ff4400' : '#ff6600'
                                });
                            }
                            if (burnEffects.length > 200) burnEffects.splice(0, burnEffects.length - 200);
                        }

                        // Chain Lightning: jump to nearby enemies with visual effects
                        if (player.chainJumps) {
                            const chainRange = 120;
                            const chainDamage = damage * 0.5;
                            const maxChains = player.chainJumps;
                            const chainedEnemies = new Set([enemy]);
                            let currentTargets = [enemy];

                            for (let chain = 0; chain < maxChains; chain++) {
                                const nextTargets = [];

                                currentTargets.forEach(currentEnemy => {
                                    for (let ci = 0; ci < enemies.length && nextTargets.length < 2; ci++) {
                                        const nextEnemy = enemies[ci];
                                        if (!nextEnemy || nextEnemy.dead || chainedEnemies.has(nextEnemy)) continue;
                                        if (nextEnemy.isFinalBoss) continue; // final bosses are immune to chain

                                        const dx = nextEnemy.x - currentEnemy.x;
                                        const dy = nextEnemy.y - currentEnemy.y;
                                        const dist = Math.sqrt(dx * dx + dy * dy);

                                        if (dist < chainRange) {
                                            chainedEnemies.add(nextEnemy);
                                            nextTargets.push(nextEnemy);

                                            // Apply damage
                                            nextEnemy.health -= chainDamage;
                                            nextEnemy.hurtTimer = 0.15;
                                            if (nextEnemy.health <= 0) {
                                                markEnemyDead(nextEnemy);
                                            }

                                            // Create lightning bolt effect
                                            if (!window.lightningBolts) window.lightningBolts = [];
                                            const boltPoints = [];
                                            const segments = 6;
                                            for (let s = 0; s <= segments; s++) {
                                                const t = s / segments;
                                                const lx = currentEnemy.x + dx * t + (Math.random() - 0.5) * 20;
                                                const ly = currentEnemy.y + dy * t + (Math.random() - 0.5) * 20;
                                                boltPoints.push({ x: lx, y: ly });
                                            }

                                            window.lightningBolts.push({
                                                points: boltPoints,
                                                life: 15,
                                                maxLife: 15
                                            });
                                        }
                                    }
                                });

                                if (nextTargets.length === 0) break;
                                currentTargets = nextTargets;
                            }
                        }

                        // Explosive strikes - create explosion effect and splash damage (reduced on bosses)
                        if (player.explosionChance && Math.random() < player.explosionChance) {
                            // Skip explosion effects on bosses to prevent lag
                            if (!enemy.isBoss) {
                                try { playSfx('explosion'); } catch (e) { }
                                explosionEffects.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    radius: 0,
                                    maxRadius: 60,
                                    lifetime: 0.4,
                                    age: 0
                                });
                            }

                            // Splash damage to nearby enemies (capped to reduce lag, reduced on bosses)
                            const splashR = 60;
                            let splashHits = 0;
                            const splashMax = enemy.isBoss ? 5 : 15; // Reduce splash hits on bosses
                            for (let sj = 0; sj < enemies.length && splashHits < splashMax; sj++) {
                                const nearbyEnemy = enemies[sj];
                                if (!nearbyEnemy || nearbyEnemy === enemy || nearbyEnemy.dead) continue;
                                if (nearbyEnemy.isFinalBoss) continue; // final bosses immune to splash
                                const dx2 = nearbyEnemy.x - enemy.x;
                                const dy2 = nearbyEnemy.y - enemy.y;
                                if (Math.abs(dx2) > splashR || Math.abs(dy2) > splashR) continue;
                                const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                                if (dist2 < splashR) {
                                    nearbyEnemy.health -= damage * 0.5;
                                    nearbyEnemy.hurtTimer = 0.18;
                                    if (nearbyEnemy.health <= 0) {
                                        markEnemyDead(nearbyEnemy);
                                    }
                                    splashHits++;
                                }
                            }
                        }

                        enemy.hurtTimer = 0.18;
                        if (enemy.health <= 0) {
                            markEnemyDead(enemy);
                        }

                        // Stop at first hit unless piercing is enabled
                        if (!proj.pierce) {
                            hit = true;
                            break;
                        }
                    }
                }

                if (hit) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // Draw projectile
                if (player.character.type === 'archer') {
                    // Draw proper arrow for Luna
                    const angle = Math.atan2(proj.vy, proj.vx);
                    const size = proj.radius * 2;

                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    ctx.rotate(angle);

                    // Arrow shaft
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-size * 1.5, -size * 0.15, size * 2, size * 0.3);

                    // Arrow head
                    ctx.beginPath();
                    ctx.moveTo(size * 0.5, 0);
                    ctx.lineTo(size * 0.5 - size * 0.6, -size * 0.4);
                    ctx.lineTo(size * 0.5 - size * 0.6, size * 0.4);
                    ctx.closePath();
                    ctx.fillStyle = '#696969';
                    ctx.fill();

                    // Arrow fletching
                    ctx.fillStyle = '#DC143C';
                    ctx.beginPath();
                    ctx.moveTo(-size * 1.5, -size * 0.3);
                    ctx.lineTo(-size * 1.8, 0);
                    ctx.lineTo(-size * 1.5, size * 0.3);
                    ctx.closePath();
                    ctx.fill();

                    // Outline
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(size * 0.5, 0);
                    ctx.lineTo(size * 0.5 - size * 0.6, -size * 0.4);
                    ctx.lineTo(-size * 1.5, -size * 0.3);
                    ctx.lineTo(-size * 1.8, 0);
                    ctx.lineTo(-size * 1.5, size * 0.3);
                    ctx.lineTo(size * 0.5 - size * 0.6, size * 0.4);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.restore();
                } else {
                    // Circle projectile for non-archers
                    ctx.fillStyle = '#d4af37';
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            // Update boss fireballs (moved outside projectile loop to fix scoping)
            for (let i = bossFireballs.length - 1; i >= 0; i--) {
                const fb = bossFireballs[i];
                fb.x += fb.vx * dt;
                fb.y += fb.vy * dt;
                fb.lifetime -= dt;

                if (fb.lifetime <= 0) {
                    bossFireballs.splice(i, 1);
                    continue;
                }

                const dx = player.x - fb.x;
                const dy = player.y - fb.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < player.radius + fb.radius) {
                    // Dodge check
                    if (player.dodgeChance && Math.random() < player.dodgeChance) {
                        bossFireballs.splice(i, 1);
                        continue;
                    }
                    let dmg = fb.damage;
                    if (player.damageReduction) dmg *= (1 - player.damageReduction);
                    // Ghost Shield absorbs first
                    if (player.shield && player.shield > 0) {
                        player.shield -= dmg;
                        if (player.shield < 0) {
                            dmg = -player.shield;
                            player.shield = 0;
                        } else {
                            dmg = 0;
                        }
                    }
                    player.health -= dmg;

                    explosionEffects.push({
                        x: fb.x,
                        y: fb.y,
                        radius: 0,
                        maxRadius: 50,
                        lifetime: 0.3,
                        age: 0
                    });

                    bossFireballs.splice(i, 1);

                    // Check if player died from fireball
                    if (player.health <= 0 && !player.dead) {
                        player.animState = 'dead';
                        player.dead = true;
                        try { playSfx('death'); } catch (e) { }
                        setTimeout(() => {
                            gameOver();
                        }, 1000); // Wait for death animation
                        return;
                    }

                    continue;
                }

                // Draw fireball
                ctx.save();
                ctx.translate(fb.x, fb.y);
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, fb.radius);
                gradient.addColorStop(0, '#ffff00');
                gradient.addColorStop(0.5, '#ff6600');
                gradient.addColorStop(1, '#ff0000');
                ctx.fillStyle = gradient;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff6600';
                ctx.beginPath();
                ctx.arc(0, 0, fb.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Update ultimate effects
            for (let i = ultimateEffects.length - 1; i >= 0; i--) {
                const ult = ultimateEffects[i];
                ult.age += dt;

                if (ult.age >= ult.lifetime) {
                    ultimateEffects.splice(i, 1);
                    continue;
                }

                if (ult.type === 'shockwave') {
                    ult.radius = (ult.age / ult.lifetime) * ult.maxRadius;
                    ctx.save();
                    ctx.translate(ult.x, ult.y);
                    const alpha = 1 - (ult.age / ult.lifetime);
                    ctx.strokeStyle = `rgba(212, 175, 55, ${alpha})`;
                    ctx.lineWidth = 15;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = 'rgba(212, 175, 55, 0.8)';
                    ctx.beginPath();
                    ctx.arc(0, 0, ult.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }

                if (ult.type === 'tornado') {
                    ult.rotation += 10 * dt;

                    enemies.forEach(enemy => {
                        const dx = enemy.x - player.x;
                        const dy = enemy.y - player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < ult.radius) {
                            enemy.health -= 15 * dt;
                            enemy.hurtTimer = 0.1;
                            if (enemy.health <= 0) markEnemyDead(enemy);
                        }
                    });

                    ctx.save();
                    ctx.translate(player.x, player.y);
                    for (let b = 0; b < 8; b++) {
                        const angle = ult.rotation + (Math.PI * 2 * b) / 8;
                        const dist = ult.radius * 0.7;
                        const x = Math.cos(angle) * dist;
                        const y = Math.sin(angle) * dist;
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(angle);
                        ctx.strokeStyle = 'rgba(100, 150, 255, 0.8)';
                        ctx.lineWidth = 6;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = 'rgba(100, 150, 255, 0.8)';
                        ctx.beginPath();
                        ctx.moveTo(-20, 0);
                        ctx.lineTo(20, 0);
                        ctx.stroke();
                        ctx.restore();
                    }
                    ctx.restore();
                }
            }

            // Update and draw slash effects
            for (let i = slashEffects.length - 1; i >= 0; i--) {
                const slash = slashEffects[i];
                slash.age += dt;

                if (slash.age >= slash.lifetime) {
                    slashEffects.splice(i, 1);
                    continue;
                }

                const progress = slash.age / slash.lifetime;
                const alpha = 1 - progress;
                const arcLength = Math.PI * 0.6; // 108 degrees

                ctx.save();
                ctx.translate(slash.x, slash.y);
                ctx.rotate(slash.angle);

                // Draw arc slash with golden glow
                ctx.strokeStyle = `rgba(212, 175, 55, ${alpha * 0.8})`;
                ctx.lineWidth = 8 * (1 - progress * 0.5);
                ctx.lineCap = 'round';
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(212, 175, 55, 0.8)';

                ctx.beginPath();
                const startAngle = -arcLength / 2 + (progress * arcLength * 0.3);
                const endAngle = arcLength / 2 + (progress * arcLength * 0.3);
                ctx.arc(0, 0, slash.range * 0.7, startAngle, endAngle);
                ctx.stroke();

                // Inner white glow
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
                ctx.lineWidth = 4 * (1 - progress * 0.5);
                ctx.shadowBlur = 5;
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(0, 0, slash.range * 0.7, startAngle, endAngle);
                ctx.stroke();

                ctx.restore();
            }

            // Update and draw frost hit aura effects
            for (let i = frostHitEffects.length - 1; i >= 0; i--) {
                const fx = frostHitEffects[i];
                fx.age += dt;
                if (fx.age >= fx.lifetime) { frostHitEffects.splice(i, 1); continue; }
                const t = fx.age / fx.lifetime;
                const alpha = (1 - t) * 0.55;
                const rad = fx.r * (0.6 + t * 0.8);
                ctx.save();
                ctx.translate(fx.x, fx.y);
                ctx.strokeStyle = `rgba(100, 180, 255, ${alpha})`;
                ctx.lineWidth = 10 * (1 - t * 0.6);
                ctx.shadowBlur = 18;
                ctx.shadowColor = 'rgba(120, 200, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(0, 0, rad, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // Draw burning aura on burning enemies
            ctx.save();
            enemies.forEach(enemy => {
                if (enemy.burning && now < enemy.burnEndTime && !enemy.dead) {
                    const burnProgress = (enemy.burnEndTime - now) / 3000;
                    const pulseSize = Math.sin(now / 100) * 3;

                    // Orange/red glow around burning enemies
                    ctx.translate(enemy.x, enemy.y);

                    // Outer glow
                    const grad = ctx.createRadialGradient(0, 0, enemy.radius, 0, 0, enemy.radius + 15 + pulseSize);
                    grad.addColorStop(0, 'rgba(255, 100, 0, 0)');
                    grad.addColorStop(0.5, `rgba(255, 80, 0, ${burnProgress * 0.3})`);
                    grad.addColorStop(1, 'rgba(255, 50, 0, 0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, enemy.radius + 15 + pulseSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Inner flame ring
                    ctx.strokeStyle = `rgba(255, 120, 0, ${burnProgress * 0.6})`;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(255, 100, 0, 0.8)';
                    ctx.beginPath();
                    ctx.arc(0, 0, enemy.radius + 5, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.translate(-enemy.x, -enemy.y);
                }
            });
            ctx.restore();

            // Update and draw explosion effects
            for (let i = explosionEffects.length - 1; i >= 0; i--) {
                const explosion = explosionEffects[i];
                explosion.age += dt;

                if (explosion.age >= explosion.lifetime) {
                    explosionEffects.splice(i, 1);
                    continue;
                }

                const progress = explosion.age / explosion.lifetime;
                explosion.radius = explosion.maxRadius * progress;
                const alpha = 1 - progress;

                ctx.save();
                ctx.translate(explosion.x, explosion.y);

                // Outer explosion ring (orange/red)
                ctx.strokeStyle = `rgba(255, 100, 0, ${alpha * 0.8})`;
                ctx.lineWidth = 12 * (1 - progress * 0.3);
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(255, 100, 0, 0.8)';
                ctx.beginPath();
                ctx.arc(0, 0, explosion.radius, 0, Math.PI * 2);
                ctx.stroke();

                // Middle ring (yellow)
                ctx.strokeStyle = `rgba(255, 200, 0, ${alpha * 0.6})`;
                ctx.lineWidth = 8 * (1 - progress * 0.3);
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(255, 200, 0, 0.6)';
                ctx.beginPath();
                ctx.arc(0, 0, explosion.radius * 0.8, 0, Math.PI * 2);
                ctx.stroke();

                // Inner core (white)
                ctx.fillStyle = `rgba(255, 255, 200, ${alpha * 0.8})`;
                ctx.shadowBlur = 25;
                ctx.shadowColor = 'rgba(255, 255, 255, 1)';
                ctx.beginPath();
                ctx.arc(0, 0, explosion.radius * 0.3, 0, Math.PI * 2);
                ctx.fill();

                // Particles
                for (let p = 0; p < 8; p++) {
                    const angle = (Math.PI * 2 * p) / 8 + (progress * 0.5);
                    const particleDist = explosion.radius * (0.7 + Math.random() * 0.3);
                    const px = Math.cos(angle) * particleDist;
                    const py = Math.sin(angle) * particleDist;

                    ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            // Draw bone boomerangs
            if (player.boomerangs && player.boomerangs.length > 0) {
                player.boomerangs.forEach(boom => {
                    const boomX = player.x + Math.cos(boom.angle) * boom.distance;
                    const boomY = player.y + Math.sin(boom.angle) * boom.distance;

                    ctx.save();
                    ctx.translate(boomX, boomY);
                    ctx.rotate(boom.angle);

                    // Bone shape
                    ctx.fillStyle = '#f0e6d2';
                    ctx.strokeStyle = '#8B7355';
                    ctx.lineWidth = 2;

                    // Draw bone (dumbbell shape)
                    ctx.beginPath();
                    // Left bulb
                    ctx.arc(-boom.radius * 0.7, 0, boom.radius * 0.5, 0, Math.PI * 2);
                    // Right bulb
                    ctx.arc(boom.radius * 0.7, 0, boom.radius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Middle bar
                    ctx.fillRect(-boom.radius * 0.7, -boom.radius * 0.25, boom.radius * 1.4, boom.radius * 0.5);
                    ctx.strokeRect(-boom.radius * 0.7, -boom.radius * 0.25, boom.radius * 1.4, boom.radius * 0.5);

                    // Add glow effect
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = 'rgba(212, 175, 55, 0.6)';
                    ctx.fillStyle = 'rgba(212, 175, 55, 0.3)';
                    ctx.beginPath();
                    ctx.arc(0, 0, boom.radius * 1.2, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                });
            }

            // Update and draw XP orbs
            for (let i = xpOrbs.length - 1; i >= 0; i--) {
                const orb = xpOrbs[i];

                // Remove if expired
                if (now - orb.spawnTime > orb.lifetime) {
                    xpOrbs.splice(i, 1);
                    continue;
                }

                // Calculate distance to player (no automatic movement - orbs stay where they spawned)
                const dx = player.x - orb.x;
                const dy = player.y - orb.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Only collect when player touches the orb
                if (dist < player.radius + orb.radius + 5) {
                    const xpMultiplier = 1 + (gameState.permanentUpgrades.xp * 0.1);
                    player.xp += orb.value * xpMultiplier;
                    sounds.playOrbPickup();

                    if (player.xp >= player.xpToNext) {
                        player.xp -= player.xpToNext;
                        player.level++;

                        // FIXED XP PROGRESSION - Easy early, progressively harder
                        // Each enemy gives 10 XP, so divide by 10 to get kill count
                        // Level 1->2: 30 XP (3 kills) - Very easy start!
                        // Level 2->3: 40 XP (4 kills)
                        // Level 3->4: 50 XP (5 kills)
                        // Level 4->5: 60 XP (6 kills)
                        // Level 5->6: 70 XP (7 kills)
                        // Level 6->10: 80-120 XP (8-12 kills)
                        // Level 10+: Exponential growth

                        if (player.level <= 5) {
                            // Levels 1-5: Very easy, linear growth
                            player.xpToNext = 20 + (player.level * 10);
                        } else if (player.level <= 10) {
                            // Levels 6-10: Moderate growth
                            player.xpToNext = 70 + ((player.level - 5) * 10);
                        } else if (player.level <= 15) {
                            // Levels 11-15: Quadratic growth
                            const levelAbove10 = player.level - 10;
                            player.xpToNext = 120 + (levelAbove10 * levelAbove10 * 15);
                        } else {
                            // Levels 16+: Exponential for late game challenge
                            player.xpToNext = Math.floor(player.xpToNext * 1.4 + 60);
                        }

                        levelUp();
                    }

                    xpOrbs.splice(i, 1);
                    continue;
                }

                // Draw bone-shaped orb
                ctx.save();
                ctx.translate(orb.x, orb.y);

                // Add rotation for visual interest
                if (!orb.rotation) orb.rotation = Math.random() * Math.PI * 2;
                orb.rotation += 0.02;
                ctx.rotate(orb.rotation);

                // Bone color - off-white/cream
                ctx.fillStyle = '#f5deb3';
                ctx.strokeStyle = '#d2b48c';
                ctx.lineWidth = 1.5;

                const boneW = orb.radius * 2;
                const boneH = orb.radius * 0.8;

                // Left bulb
                ctx.beginPath();
                ctx.arc(-boneW * 0.4, 0, boneH * 0.8, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Right bulb
                ctx.beginPath();
                ctx.arc(boneW * 0.4, 0, boneH * 0.8, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Center bar
                ctx.fillRect(-boneW * 0.4, -boneH * 0.5, boneW * 0.8, boneH);
                ctx.strokeRect(-boneW * 0.4, -boneH * 0.5, boneW * 0.8, boneH);

                // Add shine/highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.beginPath();
                ctx.arc(-boneW * 0.25, -boneH * 0.2, boneH * 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            // Draw vampiric aura if player has the upgrade
            if (player.upgrades.includes('vampire')) {
                const auraTime = Date.now() / 1000;
                const pulseSize = Math.sin(auraTime * 3) * 10 + 70;
                const pulseAlpha = (Math.sin(auraTime * 3) * 0.3 + 0.4);

                ctx.save();
                ctx.translate(player.x, player.y);

                // Outer aura ring (dark red)
                ctx.strokeStyle = `rgba(139, 0, 0, ${pulseAlpha * 0.6})`;
                ctx.lineWidth = 8;
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(139, 0, 0, 0.8)';
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.stroke();

                // Middle ring (blood red)
                ctx.strokeStyle = `rgba(200, 0, 0, ${pulseAlpha * 0.5})`;
                ctx.lineWidth = 5;
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(200, 0, 0, 0.6)';
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize * 0.7, 0, Math.PI * 2);
                ctx.stroke();

                // Inner glow
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, pulseSize * 0.5);
                gradient.addColorStop(0, `rgba(255, 0, 0, ${pulseAlpha * 0.3})`);
                gradient.addColorStop(1, 'rgba(139, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize * 0.5, 0, Math.PI * 2);
                ctx.fill();

                // Floating blood particles
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 * i / 6) + auraTime;
                    const distance = pulseSize * 0.6;
                    const px = Math.cos(angle) * distance;
                    const py = Math.sin(angle) * distance + Math.sin(auraTime * 2 + i) * 5;

                    ctx.fillStyle = `rgba(200, 0, 0, ${pulseAlpha * 0.8})`;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            // Draw player with sprite
            if (sprites.loaded && player.character) {
                // Update animation state timer
                if (player.animStateTimer > 0) {
                    player.animStateTimer -= dt;
                    if (player.animStateTimer <= 0) {
                        // Return to idle after timed animation
                        if (player.animState === 'attack') {
                            player.animState = 'idle';
                        }
                    }
                }


                // Get the appropriate sprite (fallback if a specific state gif is missing)
                const desiredKey = `${player.animState}_${player.character.animPrefix}`;
                const idleKey = `idle_${player.character.animPrefix}`;
                const walkKey = `walk_${player.character.animPrefix}`;
                const attackKey = `attack_${player.character.animPrefix}`;

                let spriteKey = desiredKey;
                let sprite = sprites.images[spriteKey];

                const spriteOk = (img) => img && img.complete && img.naturalWidth > 0;

                // If current state's gif is missing, gracefully fallback:
                if (!spriteOk(sprite)) {
                    if (player.animState === 'attack' && spriteOk(sprites.images[attackKey])) {
                        spriteKey = attackKey; sprite = sprites.images[spriteKey];
                    } else if (player.animState === 'walk' && spriteOk(sprites.images[walkKey])) {
                        spriteKey = walkKey; sprite = sprites.images[spriteKey];
                    } else if (spriteOk(sprites.images[idleKey])) {
                        spriteKey = idleKey; sprite = sprites.images[spriteKey];
                    }
                }

                // Debug logging every 60 frames (once per second at 60fps)
                if (Math.random() < 0.016) {
                    console.log(`Current animation: ${spriteKey}, Status: ${sprites.loadStatus[spriteKey]}, Has sprite: ${!!sprite}, Complete: ${sprite?.complete}, Width: ${sprite?.naturalWidth}`);
                }

                // Check if sprite is properly loaded (has width)
                if (spriteOk(sprite)) {
                    ctx.save();
                    ctx.translate(player.x, player.y);

                    // Range indicator (current attack range)
                    (function drawRange() {
                        const r = Math.max(10, player.attackRange || 0);
                        const pulse = 0.5 + 0.5 * Math.sin(time * 2.2);
                        ctx.save();
                        ctx.globalAlpha = 0.22 + pulse * 0.10;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([8, 6]);
                        ctx.strokeStyle = 'rgba(200, 220, 255, 0.75)';
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Soft fill so it reads on dark backgrounds
                        ctx.globalAlpha = 0.05 + pulse * 0.03;
                        ctx.fillStyle = 'rgba(200, 220, 255, 0.45)';
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    })();

                    // Flip horizontally if facing left
                    if (!player.facingRight) {
                        ctx.scale(-1, 1);
                    }


                    // Subtle bob to imply motion even if a GIF is effectively static in canvas
                    const t = Date.now() / 1000;
                    const bob = (player.animState === 'walk') ? Math.sin(t * 10) * 1.5 : 0;
                    const recoil = (player.animState === 'attack') ? -Math.sin(t * 30) * 1.0 : 0;
                    ctx.translate(0, bob + recoil);

                    // Draw sprite centered and scaled
                    const scale = player.character.spriteScale;
                    const w = sprite.naturalWidth * scale;
                    const h = sprite.naturalHeight * scale;

                    // Use image smoothing for better quality
                    ctx.imageSmoothingEnabled = false; // Keeps pixel art crisp
                    if (!USE_DOM_SPRITES) {
                        ctx.drawImage(sprite, -w / 2, -h / 2, w, h);
                    }
                    // Update DOM sprite so GIF always animates
                    const screenX = (player.x - camera.x) + canvas.width / 2;
                    const screenY = (player.y - camera.y) + canvas.height / 2;
                    setPlayerDomSprite(sprite.src, screenX, screenY, w, h, player.facingRight, (bob + recoil));

                    // Extra attack readability (helps if attack GIF appears static)
                    if (player.animState === 'attack') {
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, Math.max(18, player.attackRange * 0.22), -0.6, 0.6);
                        ctx.stroke();
                        ctx.restore();
                    }

                    ctx.restore();
                } else {
                    // Fallback to circle if sprite not loaded
                    if (Math.random() < 0.016) {
                        console.warn(`‚ö† Sprite not rendering: ${spriteKey} - Using fallback circle`);
                    }
                    hidePlayerDomSprite();
                    drawPlayerCircle();
                }
            } else {
                // Fallback to circle
                hidePlayerDomSprite();
                drawPlayerCircle();
            }

            function drawPlayerCircle() {
                ctx.save();
                ctx.translate(player.x, player.y);
                if (!player.facingRight) {
                    ctx.scale(-1, 1);
                }

                const colors = {
                    'brawler': '#d4af37',
                    'archer': '#8B4513',
                    'swordsman': '#c0c0c0'
                };

                ctx.fillStyle = player.character ? colors[player.character.type] : '#d4af37';
                ctx.beginPath();
                ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            }

            // Auto-attack
            if (!player.dead) {
                attack();
            }

            // Update HUD
            updateHUD();

            updateStatsPanel();

            // Continue loop
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameState.screen = 'gameover';
            gameState.loopRunning = false;
            document.getElementById('hud').style.display = 'none';
            document.getElementById('statsPanel').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'flex';

            // Hide mobile controls
            const mobileControls = document.getElementById('mobileControls');
            if (mobileControls) {
                mobileControls.style.display = 'none';
            }

            // Calculate rewards - 1 bone per kill only (harder economy)
            const bonesEarned = player.kills * 3;
            gameState.currency += bonesEarned;
            localStorage.setItem('barkCurrency', gameState.currency);

            // Update stats
            const minutes = Math.floor((300 - gameTimer) / 60);
            const seconds = Math.floor((300 - gameTimer) % 60);
            document.getElementById('finalTime').textContent = minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
            document.getElementById('finalKills').textContent = player.kills;
            document.getElementById('finalLevel').textContent = player.level;
            document.getElementById('bonesEarned').textContent = bonesEarned;

            // Initialize keyboard navigation - highlight first button
            window.gameOverIndex = 0;
            setTimeout(() => {
                const buttons = document.querySelectorAll('#gameOverScreen .menu-btn');
                if (buttons.length > 0) {
                    highlightButton(buttons, 0);
                }
            }, 100);
        }

        function victory() {
            gameState.screen = 'victory';
            gameState.loopRunning = false;
            document.getElementById('hud').style.display = 'none';
            document.getElementById('statsPanel').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'flex';

            // Hide mobile controls
            const mobileControls = document.getElementById('mobileControls');
            if (mobileControls) {
                mobileControls.style.display = 'none';
            }

            // Calculate rewards - 2x bones for victory (2 per kill)
            const bonesEarned = player.kills * 6;
            gameState.currency += bonesEarned;
            localStorage.setItem('barkCurrency', gameState.currency);

            // Update stats
            document.getElementById('victoryKills').textContent = player.kills;
            document.getElementById('victoryLevel').textContent = player.level;
            document.getElementById('victoryBones').textContent = bonesEarned;

            // Initialize keyboard navigation - highlight first button
            window.victoryIndex = 0;
            setTimeout(() => {
                const buttons = document.querySelectorAll('#victoryScreen .menu-btn');
                if (buttons.length > 0) {
                    highlightButton(buttons, 0);
                }
            }, 100);
        }

        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';
            clearDomSprites();
            gameState.lastFrame = 0;
            touching = false;
            mouseDown = false;
            for (const k in keys) { keys[k] = false; }
            showCharacterSelect();
        }

        // Initialize
        updateCharacterCards();
    </script>

    <script>
        /* ===============================
           BOSS ABILITIES PATCH (GLOBAL)
           Dash + Melee + Fireball + Warning
           Works on ALL platforms
        ================================= */

        (function () {
            if (!window.enemies) return;

            const FIREBALL_SPEED = 4;
            const FIREBALL_DAMAGE = 15;
            const FIREBALL_COOLDOWN = 2200;
            const DASH_COOLDOWN = 3000;
            const DASH_SPEED = 12;
            const WARNING_TIME = 600;

            window.bossProjectiles = [];

            function spawnWarning(x, y, r, color) {
                try { playSfx('warn'); } catch (e) { }
                bossProjectiles.push({
                    x, y, r, color, warning: true, t: performance.now()
                });
            }

            function spawnFireball(x, y, vx, vy) {
                try { playSfx('fireball'); } catch (e) { }
                bossProjectiles.push({
                    x, y, vx, vy, r: 10, warning: false
                });
            }

            function updateBossAbilities(boss, player) {
                const now = performance.now();
                if (!boss._ai) {
                    boss._ai = {
                        lastFireball: 0,
                        lastDash: 0,
                        state: "idle"
                    };
                }

                const dx = player.x - boss.x;
                const dy = player.y - boss.y;
                const dist = Math.hypot(dx, dy);

                // FIREBALL (long range)
                if (dist > 180 && now - boss._ai.lastFireball > FIREBALL_COOLDOWN) {
                    boss._ai.lastFireball = now;
                    boss._ai.state = "fireball";

                    spawnWarning(boss.x, boss.y, 40, "rgba(255,80,0,0.4)");

                    setTimeout(() => {
                        const len = Math.hypot(dx, dy) || 1;
                        const shots = Math.max(1, boss.multiStrikeShots || 1);
                        const baseAng = Math.atan2(dy, dx);
                        const spread = (shots === 1) ? 0 : (Math.PI / 24); // ~7.5deg
                        for (let i = 0; i < shots; i++) {
                            const t = (shots === 1) ? 0 : (i - (shots - 1) / 2);
                            const a = baseAng + t * spread;
                            spawnFireball(
                                boss.x,
                                boss.y,
                                Math.cos(a) * FIREBALL_SPEED,
                                Math.sin(a) * FIREBALL_SPEED
                            );
                        }
                        boss._ai.state = "idle";
                    }, WARNING_TIME);
                }

                // DASH (short range)
                if (dist < 160 && now - boss._ai.lastDash > DASH_COOLDOWN) {
                    boss._ai.lastDash = now;
                    boss._ai.state = "dash";

                    spawnWarning(boss.x, boss.y, 30, "rgba(255,0,0,0.35)");

                    setTimeout(() => {
                        const len = Math.hypot(dx, dy) || 1;
                        boss.vx = (dx / len) * DASH_SPEED;
                        boss.vy = (dy / len) * DASH_SPEED;
                        try { playSfx('dash'); } catch (e) { }
                        boss._ai.state = "idle";
                    }, WARNING_TIME);
                }
            }

            // PATCH GAME LOOP
            const _origUpdate = window.updateGame;
            window.updateGame = function () {
                _origUpdate();

                const boss = enemies.find(e => e.isBoss);
                if (boss && window.player) {
                    updateBossAbilities(boss, player);
                }

                // UPDATE PROJECTILES
                bossProjectiles = bossProjectiles.filter(p => {
                    if (p.warning) return performance.now() - p.t < WARNING_TIME;
                    p.x += p.vx;
                    p.y += p.vy;

                    const dx = p.x - player.x;
                    const dy = p.y - player.y;
                    if (Math.hypot(dx, dy) < p.r + 12) {
                        // Dodge check
                        if (player.dodgeChance && Math.random() < player.dodgeChance) {
                            return false; // dodged, remove projectile
                        }
                        let dmg = FIREBALL_DAMAGE;
                        if (player.damageReduction) dmg *= (1 - player.damageReduction);
                        if (player.shield && player.shield > 0) {
                            player.shield -= dmg;
                            if (player.shield < 0) { dmg = -player.shield; player.shield = 0; }
                            else { dmg = 0; }
                        }
                        player.health -= dmg;
                        try { playSfx('hit'); } catch (e) { }
                        return false;
                    }
                    return true;
                });
            };

            // PATCH RENDER
            const _origRender = window.renderGame;
            window.renderGame = function () {
                _origRender();
                const ctx = window.ctx;
                bossProjectiles.forEach(p => {
                    ctx.beginPath();
                    ctx.fillStyle = p.color || "orange";
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.fill();
                });
            };
        })();
    </script>


    <script>
        /* ===============================
           AUDIO SYSTEM (SFX + MUSIC)
           - No external assets required (WebAudio)
           - Music can be toggled in Options
           - SFX can be toggled in Options
        ================================= */
        (function () {
            const LS_MUSIC = 'bos_music_enabled';
            const LS_SFX = 'bos_sfx_enabled';

            window.audioSettings = window.audioSettings || {
                musicEnabled: (localStorage.getItem(LS_MUSIC) ?? '1') === '1',
                sfxEnabled: (localStorage.getItem(LS_SFX) ?? '1') === '1'
            };

            let ctx = null;
            let master = null;
            let musicGain = null;
            let sfxGain = null;
            let musicTimer = null;
            let musicOsc = null;

            function ensureCtx() {
                if (ctx) return ctx;
                const AC = window.AudioContext || window.webkitAudioContext;
                if (!AC) return null;
                ctx = new AC();
                master = ctx.createGain();
                musicGain = ctx.createGain();
                sfxGain = ctx.createGain();
                master.gain.value = 0.9;
                musicGain.gain.value = window.audioSettings.musicEnabled ? 0.20 : 0.0;
                sfxGain.gain.value = window.audioSettings.sfxEnabled ? 0.55 : 0.0;
                musicGain.connect(master);
                sfxGain.connect(master);
                master.connect(ctx.destination);
                return ctx;
            }

            function unlock() {
                const c = ensureCtx();
                if (!c) return;
                if (c.state === 'suspended') c.resume().catch(() => { });
                // Start music only after a user gesture
                if (window.audioSettings.musicEnabled) startMusic();
                window.removeEventListener('pointerdown', unlock, { passive: true });
                window.removeEventListener('touchstart', unlock, { passive: true });
                window.removeEventListener('keydown', unlock);
            }

            window.addEventListener('pointerdown', unlock, { passive: true });
            window.addEventListener('touchstart', unlock, { passive: true });
            window.addEventListener('keydown', unlock);

            function beep({ freq = 440, dur = 0.08, type = 'square', gain = 0.15, slideTo = null } = {}) {
                const c = ensureCtx();
                if (!c) return;
                const o = c.createOscillator();
                const g = c.createGain();
                o.type = type;
                o.frequency.setValueAtTime(freq, c.currentTime);
                if (slideTo) {
                    o.frequency.exponentialRampToValueAtTime(Math.max(40, slideTo), c.currentTime + dur);
                }
                g.gain.setValueAtTime(0.0001, c.currentTime);
                g.gain.exponentialRampToValueAtTime(gain, c.currentTime + 0.01);
                g.gain.exponentialRampToValueAtTime(0.0001, c.currentTime + dur);
                o.connect(g);
                g.connect(sfxGain);
                o.start();
                o.stop(c.currentTime + dur + 0.02);
            }

            window.playSfx = function (name) {
                if (!window.audioSettings.sfxEnabled) return;
                // Basic palette (lightweight)
                switch (name) {
                    case 'click': beep({ freq: 660, dur: 0.05, type: 'square', gain: 0.10, slideTo: 520 }); break;
                    case 'pickup': beep({ freq: 880, dur: 0.07, type: 'triangle', gain: 0.12, slideTo: 1200 }); break;
                    case 'levelup':
                        beep({ freq: 523.25, dur: 0.08, type: 'triangle', gain: 0.13, slideTo: 659.25 });
                        setTimeout(() => beep({ freq: 659.25, dur: 0.08, type: 'triangle', gain: 0.13, slideTo: 783.99 }), 80);
                        setTimeout(() => beep({ freq: 783.99, dur: 0.10, type: 'triangle', gain: 0.13, slideTo: 1046.5 }), 160);
                        break;
                    case 'hit': beep({ freq: 180, dur: 0.06, type: 'sawtooth', gain: 0.16, slideTo: 120 }); break;
                    case 'death':
                        beep({ freq: 140, dur: 0.10, type: 'sawtooth', gain: 0.18, slideTo: 80 });
                        setTimeout(() => beep({ freq: 90, dur: 0.12, type: 'sawtooth', gain: 0.18, slideTo: 60 }), 110);
                        break;
                    case 'shoot': beep({ freq: 520, dur: 0.04, type: 'square', gain: 0.08, slideTo: 420 }); break;
                    case 'slash': beep({ freq: 380, dur: 0.06, type: 'triangle', gain: 0.12, slideTo: 520 }); break;

                    case 'explosion': beep({ freq: 120, dur: 0.12, type: 'sawtooth', gain: 0.18, slideTo: 60 }); break;
                    case 'vampire': beep({ freq: 420, dur: 0.06, type: 'triangle', gain: 0.08, slideTo: 520 }); break;
                    case 'boomerang': beep({ freq: 520, dur: 0.05, type: 'triangle', gain: 0.05, slideTo: 420 }); break;

                    // CHARACTER-SPECIFIC ATTACK SOUNDS (POLISHED)
                    case 'arrow':
                        // Luna - crisp arrow shooting sound with whoosh
                        beep({ freq: 1100, dur: 0.05, type: 'sine', gain: 0.14, slideTo: 1500 });
                        setTimeout(() => beep({ freq: 1500, dur: 0.03, type: 'sine', gain: 0.08, slideTo: 1200 }), 30);
                        break;
                    case 'punch':
                        // Rex - deep punching impact sound
                        beep({ freq: 150, dur: 0.08, type: 'square', gain: 0.20, slideTo: 90 });
                        setTimeout(() => beep({ freq: 80, dur: 0.06, type: 'sawtooth', gain: 0.16, slideTo: 60 }), 45);
                        break;
                    case 'sword':
                        // Blade - sharp sword slash with metallic ring
                        beep({ freq: 550, dur: 0.08, type: 'triangle', gain: 0.16, slideTo: 920 });
                        setTimeout(() => beep({ freq: 420, dur: 0.06, type: 'sawtooth', gain: 0.12, slideTo: 320 }), 50);
                        break;

                    case 'slash': beep({ freq: 380, dur: 0.06, type: 'triangle', gain: 0.12, slideTo: 520 }); break;
                    case 'shoot': beep({ freq: 520, dur: 0.04, type: 'square', gain: 0.08, slideTo: 420 }); break;

                    case 'crit':
                        // bright, short "ping" layered
                        beep({ freq: 1200, dur: 0.04, type: 'triangle', gain: 0.14, slideTo: 1600 });
                        setTimeout(() => beep({ freq: 1600, dur: 0.05, type: 'triangle', gain: 0.10, slideTo: 1100 }), 25);
                        break;

                    case 'dash': beep({ freq: 220, dur: 0.09, type: 'square', gain: 0.12, slideTo: 660 }); break;
                    case 'fireball': beep({ freq: 300, dur: 0.10, type: 'sawtooth', gain: 0.12, slideTo: 180 }); break;
                    case 'warn':
                        // Warning sound for horde
                        beep({ freq: 900, dur: 0.10, type: 'square', gain: 0.14, slideTo: 750 });
                        setTimeout(() => beep({ freq: 900, dur: 0.10, type: 'square', gain: 0.14, slideTo: 750 }), 200);
                        break;
                    case 'chain':
                        beep({ freq: 800, dur: 0.06, type: 'square', gain: 0.12, slideTo: 1200 });
                        setTimeout(() => beep({ freq: 1200, dur: 0.04, type: 'square', gain: 0.10, slideTo: 1600 }), 40);
                        break;
                    default: beep({ freq: 440, dur: 0.06, type: 'square', gain: 0.10 }); break;
                }
            };

            function startMusic() {
                const c = ensureCtx();
                if (!c || musicTimer || !window.audioSettings.musicEnabled) return;

                // One-osc loop with a simple progression (low CPU)
                const seq = [
                    261.63, 329.63, 392.00, 329.63, // C E G E
                    246.94, 311.13, 369.99, 311.13, // B‚ô≠ D# F# D#
                    220.00, 277.18, 329.63, 277.18, // A C# E C#
                    233.08, 293.66, 349.23, 293.66  // Bb D F D
                ];
                let i = 0;

                musicOsc = c.createOscillator();
                const g = c.createGain();
                musicOsc.type = 'triangle';
                g.gain.value = 0.0001;
                musicOsc.connect(g);
                g.connect(musicGain);
                musicOsc.start();

                // Soft attack
                g.gain.setTargetAtTime(0.16, c.currentTime, 0.06);

                musicTimer = setInterval(() => {
                    if (!window.audioSettings.musicEnabled) return;
                    const f = seq[i++ % seq.length];
                    musicOsc.frequency.setTargetAtTime(f, c.currentTime, 0.02);
                }, 180);
            }

            function stopMusic() {
                if (musicTimer) { clearInterval(musicTimer); musicTimer = null; }
                if (musicOsc) {
                    try { musicOsc.stop(); } catch (e) { }
                    try { musicOsc.disconnect(); } catch (e) { }
                    musicOsc = null;
                }
            }


            window.startBossMusic = function () {
                const c = ensureCtx();
                if (!c || bossTimer || !window.audioSettings.musicEnabled) return;

                // Stop normal music first
                window.stopMusic();

                // Boss music - more intense, faster rhythm
                const bossSeq = [
                    164.81, 220.00, 277.18, 220.00, // E A C# A
                    155.56, 207.65, 261.63, 207.65, // D# G# C G#
                    146.83, 196.00, 246.94, 196.00, // D G B‚ô≠ G
                    138.59, 185.00, 233.08, 185.00  // C# F# Bb F#
                ];
                let i = 0;

                bossOsc = c.createOscillator();
                const g = c.createGain();
                bossOsc.type = 'sawtooth'; // More aggressive sound
                g.gain.value = 0.0001;
                bossOsc.connect(g);
                g.connect(musicGain);
                bossOsc.start();

                g.gain.setTargetAtTime(0.20, c.currentTime, 0.06);

                bossTimer = setInterval(() => {
                    if (!window.audioSettings.musicEnabled) return;
                    const f = bossSeq[i++ % bossSeq.length];
                    bossOsc.frequency.setTargetAtTime(f, c.currentTime, 0.01);
                }, 120); // Faster tempo
            };

            window.stopBossMusic = function () {
                if (bossTimer) { clearInterval(bossTimer); bossTimer = null; }
                if (bossOsc) {
                    try { bossOsc.stop(); } catch (e) { }
                    try { bossOsc.disconnect(); } catch (e) { }
                    bossOsc = null;
                }
            };

            window.toggleMusic = function () {
                window.audioSettings.musicEnabled = !window.audioSettings.musicEnabled;
                localStorage.setItem(LS_MUSIC, window.audioSettings.musicEnabled ? '1' : '0');
                ensureCtx();
                if (musicGain) musicGain.gain.value = window.audioSettings.musicEnabled ? 0.20 : 0.0;
                if (window.audioSettings.musicEnabled) {
                    if (gameState.bossRoundActive) {
                        startBossMusic();
                    } else {
                        startMusic();
                    }
                } else {
                    stopMusic();
                    stopBossMusic();
                }
                updateAudioButtons();
                try { playSfx('click'); } catch (e) { }
            };

            window.toggleSfx = function () {
                window.audioSettings.sfxEnabled = !window.audioSettings.sfxEnabled;
                localStorage.setItem(LS_SFX, window.audioSettings.sfxEnabled ? '1' : '0');
                ensureCtx();
                if (sfxGain) sfxGain.gain.value = window.audioSettings.sfxEnabled ? 0.55 : 0.0;
                updateAudioButtons();
                if (window.audioSettings.sfxEnabled) try { playSfx('click'); } catch (e) { }
            };

            window.updateAudioButtons = function () {
                const mBtn = document.getElementById('musicToggleBtn');
                const sBtn = document.getElementById('sfxToggleBtn');
                if (mBtn) mBtn.textContent = 'Music: ' + (window.audioSettings.musicEnabled ? 'ON' : 'OFF');
                if (sBtn) sBtn.textContent = 'SFX: ' + (window.audioSettings.sfxEnabled ? 'ON' : 'OFF');
            };

            // UI clicks -> SFX
            document.addEventListener('click', (e) => {
                const t = e.target;
                if (!t) return;
                if (t.classList && (t.classList.contains('menu-btn') || t.classList.contains('back-btn'))) {
                    try { playSfx('click'); } catch (e) { }
                }
            });

            // Initialize button labels if options exists
            window.addEventListener('load', () => {
                updateAudioButtons();
            });

        })();
    </script>


    <script>
        /* ===== Runtime Error Overlay (non-invasive) ===== */
        (function () {
            function showErr(msg) {
                let el = document.getElementById('runtimeErrOverlay');
                if (!el) {
                    el = document.createElement('div');
                    el.id = 'runtimeErrOverlay';
                    el.style.cssText = 'position:fixed;left:12px;right:12px;bottom:12px;z-index:999999;background:rgba(120,0,0,.88);border:1px solid rgba(255,255,255,.25);color:#fff;padding:10px 12px;border-radius:10px;font:12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;white-space:pre-wrap;max-height:45vh;overflow:auto;';
                    document.body.appendChild(el);
                }
                el.textContent = msg;
            }
            window.addEventListener('error', (e) => {
                const msg = 'Runtime error:\n' + (e.error && (e.error.stack || e.error.message) ? (e.error.stack || e.error.message) : (e.message || String(e)));
                showErr(msg);
            });
            window.addEventListener('unhandledrejection', (e) => {
                const r = e.reason;
                const msg = 'Unhandled promise rejection:\n' + (r && (r.stack || r.message) ? (r.stack || r.message) : String(r));
                showErr(msg);
            });
        })();
    </script>


    <!-- Active Upgrades Indicator -->
    <div id="activeUpgrades" style="position: fixed; bottom: 20px; right: 20px; 
         background: rgba(0,0,0,0.9); border: 2px solid var(--gold); 
         padding: 0.5rem; max-width: 200px; display: none; z-index: 100;
         font-family: 'Rajdhani', sans-serif; box-sizing: border-box;">
        <div style="font-family: 'Bebas Neue'; color: var(--gold); font-size: 0.9rem; margin-bottom: 0.3rem;">ACTIVE
        </div>
        <div id="upgradeList" style="font-size: 0.7rem; color: #aaa; line-height: 1.4;"></div>
    </div>

    <!-- Ultimate Ready Indicator -->
    <div id="ultimateIndicator" style="position: fixed; bottom: 120px; left: 50%; 
         transform: translateX(-50%); display: none; z-index: 150;
         font-family: 'Bebas Neue'; font-size: 2rem; color: #ffaa00; 
         text-shadow: 0 0 20px #ffaa00; animation: ultPulse 1s infinite;">
        ‚ö° ULTIMATE READY ‚ö°
    </div>

    <style>
        @keyframes ultPulse {

            0%,
            100% {
                opacity: 1;
                transform: translateX(-50%) scale(1);
            }

            50% {
                opacity: 0.6;
                transform: translateX(-50%) scale(1.1);
            }
        }

        /* Upgrade Activation Animations */
        @keyframes upgradeActivate {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }

            50% {
                transform: scale(1.3);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 0;
            }
        }

        .upgrade-flash {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            animation: upgradeActivate 1s ease-out forwards;
        }

        @keyframes permanentGlow {

            0%,
            100% {
                opacity: 0.6;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.1);
            }
        }


        /* Landscape Mode Enforcement for Mobile */
        @media (max-width: 768px) {
            body {
                zoom: 0.5;
                /* 50% zoom for mobile */
                -moz-transform: scale(0.5);
                -moz-transform-origin: 0 0;
            }
        }

        /* Portrait Mode Warning Overlay */
        #landscapeWarning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 99999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            padding: 2rem;
        }

        #landscapeWarning .rotate-icon {
            font-size: 5rem;
            margin-bottom: 2rem;
            animation: rotateDevice 2s ease-in-out infinite;
        }

        #landscapeWarning h2 {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            color: var(--gold);
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.6);
        }

        #landscapeWarning p {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.2rem;
            color: #aaa;
            max-width: 400px;
        }

        @keyframes rotateDevice {

            0%,
            100% {
                transform: rotate(0deg);
            }

            25% {
                transform: rotate(-90deg);
            }

            50% {
                transform: rotate(-90deg);
            }

            75% {
                transform: rotate(-90deg);
            }
        }

        /* Desktop - no zoom */
        @media (min-width: 769px) {
            body {
                zoom: 1;
            }
        }

        /* Achievements Screen */
        #achievementsScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.97);
            z-index: 1001;
            overflow-y: auto;
            padding: 2rem;
        }

        .achievements-title {
            font-family: 'Cinzel', serif;
            font-size: 3rem;
            color: var(--gold);
            text-align: center;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }

        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1.5rem;
            max-width: 1200px;
            margin: 0 auto;
            padding-bottom: 2rem;
        }

        .achievement-card {
            background: linear-gradient(135deg, var(--stone-gray) 0%, #1a1a1a 100%);
            border: 2px solid var(--wood-brown);
            padding: 1.5rem;
            transition: all 0.3s ease;
        }

        .achievement-card.unlocked {
            border-color: var(--gold);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
        }

        .achievement-card.locked {
            opacity: 0.6;
        }

        .achievement-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }

        .achievement-info {
            flex: 1;
        }

        .achievement-name {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.5rem;
            color: var(--gold);
            margin-bottom: 0.3rem;
        }

        .achievement-desc {
            color: #aaa;
            font-size: 0.95rem;
            line-height: 1.4;
        }

        .achievement-status {
            font-size: 2rem;
            margin-left: 1rem;
        }

        .achievement-status.locked {
            opacity: 0.3;
        }

        .achievement-progress {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(212, 175, 55, 0.2);
        }

        .progress-bar-container {
            width: 100%;
            height: 10px;
            background: rgba(61, 40, 23, 0.5);
            border: 1px solid var(--wood-brown);
            margin-bottom: 0.5rem;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--wood-brown) 0%, var(--gold) 100%);
            transition: width 0.3s ease;
        }

        .progress-text {
            font-family: 'Bebas Neue', cursive;
            font-size: 0.9rem;
            color: #aaa;
        }

        .achievement-reward {
            margin-top: 1rem;
            padding: 0.8rem;
            background: rgba(212, 175, 55, 0.1);
            border: 1px solid var(--gold);
            text-align: center;
        }

        .reward-label {
            font-family: 'Bebas Neue', cursive;
            font-size: 0.8rem;
            color: var(--gold);
            margin-bottom: 0.3rem;
        }

        .reward-value {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.3rem;
            color: #ffaa00;
        }

        .claim-btn {
            margin-top: 1rem;
            width: 100%;
            padding: 0.8rem;
            font-family: 'Bebas Neue', cursive;
            font-size: 1.3rem;
            background: linear-gradient(135deg, var(--wood-brown) 0%, #2d1e0f 100%);
            border: 2px solid var(--gold);
            color: var(--gold);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .claim-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, var(--gold) 0%, #b8941f 100%);
            color: var(--dark-bg);
            transform: translateY(-2px);
        }

        .claim-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .claim-btn.claimed {
            background: var(--stone-gray);
            border-color: #555;
            color: #777;
        }

        .achievement-toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.95) 0%, rgba(10, 10, 10, 0.95) 100%);
            border: 3px solid var(--gold);
            padding: 1.5rem 2.5rem;
            z-index: 9999;
            animation: toastFadeTop 3s ease-out forwards;
            pointer-events: none;
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.4);
            text-align: center;
            max-width: 500px;
        }

        .achievement-toast .toast-title {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.2rem;
            color: #aaa;
            margin-bottom: 0.5rem;
            letter-spacing: 0.3rem;
        }

        .achievement-toast .toast-name {
            font-family: 'Bebas Neue', cursive;
            font-size: 2rem;
            color: var(--gold);
            margin-bottom: 0.3rem;
        }

        .achievement-toast .toast-reward {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.5rem;
            color: #ffaa00;
        }

        @keyframes toastFadeTop {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }

            10% {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }

            80% {
                opacity: 1;
            }

            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px);
            }
        }
    </style>


    <script>
        /* ===== Landscape Mode Enforcement for Mobile ===== */
        (function () {
            function checkOrientation() {
                const warning = document.getElementById('landscapeWarning');
                if (!warning) return;

                // Only enforce on mobile devices (width <= 768px)
                const isMobile = window.innerWidth <= 768 ||
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                if (isMobile) {
                    // Check if in portrait mode
                    const isPortrait = window.innerHeight > window.innerWidth;

                    if (isPortrait) {
                        // Show warning
                        warning.style.display = 'flex';

                        // Pause game if it's running
                        if (window.gameState && window.gameState.screen === 'playing') {
                            // Don't actually pause, just show overlay
                        }
                    } else {
                        // Hide warning - device is in landscape
                        warning.style.display = 'none';
                    }
                } else {
                    // Desktop - always hide warning
                    warning.style.display = 'none';
                }
            }

            // Check on load
            window.addEventListener('load', checkOrientation);

            // Check on resize
            window.addEventListener('resize', checkOrientation);

            // Check on orientation change
            window.addEventListener('orientationchange', () => {
                setTimeout(checkOrientation, 100);
            });

            // Initial check
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', checkOrientation);
            } else {
                checkOrientation();
            }
        })();

        // Initialize menu navigation on page load
        function initializeMenuNavigation() {
            // Load achievements on page load
            loadAchievements();

            // Highlight first menu button on load
            window.mainMenuIndex = 0;
            const menuButtons = document.querySelectorAll('#mainMenu .menu-btn');
            if (menuButtons.length > 0) {
                const mainMenu = document.getElementById('mainMenu');
                const isVisible = mainMenu && (mainMenu.style.display === '' || mainMenu.style.display === 'flex' || mainMenu.style.display === 'block');
                if (isVisible) {
                    highlightButton(menuButtons, 0);
                }
            }
        }

        // Try multiple initialization methods to ensure it works
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(initializeMenuNavigation, 100);
            });
        } else {
            // DOM already loaded
            setTimeout(initializeMenuNavigation, 100);
        }

        // Also try on window load as backup
        window.addEventListener('load', () => {
            setTimeout(initializeMenuNavigation, 100);
        });
    </script>

</body>

</html>